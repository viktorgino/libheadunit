// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AndroidAuto.proto
// Protobuf C++ Version: 4.25.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_AndroidAuto_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_AndroidAuto_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_AndroidAuto_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_AndroidAuto_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_AndroidAuto_2eproto;
namespace HU {
class AbsoluteInputEvent;
struct AbsoluteInputEventDefaultTypeInternal;
extern AbsoluteInputEventDefaultTypeInternal _AbsoluteInputEvent_default_instance_;
class AbsoluteInputEventWrapper;
struct AbsoluteInputEventWrapperDefaultTypeInternal;
extern AbsoluteInputEventWrapperDefaultTypeInternal _AbsoluteInputEventWrapper_default_instance_;
class AudioCofig;
struct AudioCofigDefaultTypeInternal;
extern AudioCofigDefaultTypeInternal _AudioCofig_default_instance_;
class AudioFocusRequest;
struct AudioFocusRequestDefaultTypeInternal;
extern AudioFocusRequestDefaultTypeInternal _AudioFocusRequest_default_instance_;
class AudioFocusResponse;
struct AudioFocusResponseDefaultTypeInternal;
extern AudioFocusResponseDefaultTypeInternal _AudioFocusResponse_default_instance_;
class AuthCompleteResponse;
struct AuthCompleteResponseDefaultTypeInternal;
extern AuthCompleteResponseDefaultTypeInternal _AuthCompleteResponse_default_instance_;
class BindingRequest;
struct BindingRequestDefaultTypeInternal;
extern BindingRequestDefaultTypeInternal _BindingRequest_default_instance_;
class BindingResponse;
struct BindingResponseDefaultTypeInternal;
extern BindingResponseDefaultTypeInternal _BindingResponse_default_instance_;
class BluetoothAuthData;
struct BluetoothAuthDataDefaultTypeInternal;
extern BluetoothAuthDataDefaultTypeInternal _BluetoothAuthData_default_instance_;
class BluetoothPairingRequest;
struct BluetoothPairingRequestDefaultTypeInternal;
extern BluetoothPairingRequestDefaultTypeInternal _BluetoothPairingRequest_default_instance_;
class BluetoothPairingResponse;
struct BluetoothPairingResponseDefaultTypeInternal;
extern BluetoothPairingResponseDefaultTypeInternal _BluetoothPairingResponse_default_instance_;
class ButtonInfo;
struct ButtonInfoDefaultTypeInternal;
extern ButtonInfoDefaultTypeInternal _ButtonInfo_default_instance_;
class ButtonInfoWrapper;
struct ButtonInfoWrapperDefaultTypeInternal;
extern ButtonInfoWrapperDefaultTypeInternal _ButtonInfoWrapper_default_instance_;
class ChannelDescriptor;
struct ChannelDescriptorDefaultTypeInternal;
extern ChannelDescriptorDefaultTypeInternal _ChannelDescriptor_default_instance_;
class ChannelDescriptor_BluetoothService;
struct ChannelDescriptor_BluetoothServiceDefaultTypeInternal;
extern ChannelDescriptor_BluetoothServiceDefaultTypeInternal _ChannelDescriptor_BluetoothService_default_instance_;
class ChannelDescriptor_GenericNotificationService;
struct ChannelDescriptor_GenericNotificationServiceDefaultTypeInternal;
extern ChannelDescriptor_GenericNotificationServiceDefaultTypeInternal _ChannelDescriptor_GenericNotificationService_default_instance_;
class ChannelDescriptor_InputEventChannel;
struct ChannelDescriptor_InputEventChannelDefaultTypeInternal;
extern ChannelDescriptor_InputEventChannelDefaultTypeInternal _ChannelDescriptor_InputEventChannel_default_instance_;
class ChannelDescriptor_InputEventChannel_TouchScreenConfig;
struct ChannelDescriptor_InputEventChannel_TouchScreenConfigDefaultTypeInternal;
extern ChannelDescriptor_InputEventChannel_TouchScreenConfigDefaultTypeInternal _ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_;
class ChannelDescriptor_InputStreamChannel;
struct ChannelDescriptor_InputStreamChannelDefaultTypeInternal;
extern ChannelDescriptor_InputStreamChannelDefaultTypeInternal _ChannelDescriptor_InputStreamChannel_default_instance_;
class ChannelDescriptor_NavigationStatusService;
struct ChannelDescriptor_NavigationStatusServiceDefaultTypeInternal;
extern ChannelDescriptor_NavigationStatusServiceDefaultTypeInternal _ChannelDescriptor_NavigationStatusService_default_instance_;
class ChannelDescriptor_NavigationStatusService_ImageOptions;
struct ChannelDescriptor_NavigationStatusService_ImageOptionsDefaultTypeInternal;
extern ChannelDescriptor_NavigationStatusService_ImageOptionsDefaultTypeInternal _ChannelDescriptor_NavigationStatusService_ImageOptions_default_instance_;
class ChannelDescriptor_OutputStreamChannel;
struct ChannelDescriptor_OutputStreamChannelDefaultTypeInternal;
extern ChannelDescriptor_OutputStreamChannelDefaultTypeInternal _ChannelDescriptor_OutputStreamChannel_default_instance_;
class ChannelDescriptor_OutputStreamChannel_VideoConfig;
struct ChannelDescriptor_OutputStreamChannel_VideoConfigDefaultTypeInternal;
extern ChannelDescriptor_OutputStreamChannel_VideoConfigDefaultTypeInternal _ChannelDescriptor_OutputStreamChannel_VideoConfig_default_instance_;
class ChannelDescriptor_PhoneStatusService;
struct ChannelDescriptor_PhoneStatusServiceDefaultTypeInternal;
extern ChannelDescriptor_PhoneStatusServiceDefaultTypeInternal _ChannelDescriptor_PhoneStatusService_default_instance_;
class ChannelDescriptor_SensorChannel;
struct ChannelDescriptor_SensorChannelDefaultTypeInternal;
extern ChannelDescriptor_SensorChannelDefaultTypeInternal _ChannelDescriptor_SensorChannel_default_instance_;
class ChannelDescriptor_SensorChannel_Sensor;
struct ChannelDescriptor_SensorChannel_SensorDefaultTypeInternal;
extern ChannelDescriptor_SensorChannel_SensorDefaultTypeInternal _ChannelDescriptor_SensorChannel_Sensor_default_instance_;
class ChannelDescriptor_VendorExtensionService;
struct ChannelDescriptor_VendorExtensionServiceDefaultTypeInternal;
extern ChannelDescriptor_VendorExtensionServiceDefaultTypeInternal _ChannelDescriptor_VendorExtensionService_default_instance_;
class ChannelOpenRequest;
struct ChannelOpenRequestDefaultTypeInternal;
extern ChannelOpenRequestDefaultTypeInternal _ChannelOpenRequest_default_instance_;
class ChannelOpenResponse;
struct ChannelOpenResponseDefaultTypeInternal;
extern ChannelOpenResponseDefaultTypeInternal _ChannelOpenResponse_default_instance_;
class GenericNotificationRequest;
struct GenericNotificationRequestDefaultTypeInternal;
extern GenericNotificationRequestDefaultTypeInternal _GenericNotificationRequest_default_instance_;
class GenericNotificationResponse;
struct GenericNotificationResponseDefaultTypeInternal;
extern GenericNotificationResponseDefaultTypeInternal _GenericNotificationResponse_default_instance_;
class InputEvent;
struct InputEventDefaultTypeInternal;
extern InputEventDefaultTypeInternal _InputEvent_default_instance_;
class MediaAck;
struct MediaAckDefaultTypeInternal;
extern MediaAckDefaultTypeInternal _MediaAck_default_instance_;
class MediaSetupRequest;
struct MediaSetupRequestDefaultTypeInternal;
extern MediaSetupRequestDefaultTypeInternal _MediaSetupRequest_default_instance_;
class MediaSetupResponse;
struct MediaSetupResponseDefaultTypeInternal;
extern MediaSetupResponseDefaultTypeInternal _MediaSetupResponse_default_instance_;
class MediaStartRequest;
struct MediaStartRequestDefaultTypeInternal;
extern MediaStartRequestDefaultTypeInternal _MediaStartRequest_default_instance_;
class MediaStopRequest;
struct MediaStopRequestDefaultTypeInternal;
extern MediaStopRequestDefaultTypeInternal _MediaStopRequest_default_instance_;
class MicRequest;
struct MicRequestDefaultTypeInternal;
extern MicRequestDefaultTypeInternal _MicRequest_default_instance_;
class MicResponse;
struct MicResponseDefaultTypeInternal;
extern MicResponseDefaultTypeInternal _MicResponse_default_instance_;
class NAVDistanceMessage;
struct NAVDistanceMessageDefaultTypeInternal;
extern NAVDistanceMessageDefaultTypeInternal _NAVDistanceMessage_default_instance_;
class NAVMessagesStatus;
struct NAVMessagesStatusDefaultTypeInternal;
extern NAVMessagesStatusDefaultTypeInternal _NAVMessagesStatus_default_instance_;
class NAVTurnMessage;
struct NAVTurnMessageDefaultTypeInternal;
extern NAVTurnMessageDefaultTypeInternal _NAVTurnMessage_default_instance_;
class NavigationFocusRequest;
struct NavigationFocusRequestDefaultTypeInternal;
extern NavigationFocusRequestDefaultTypeInternal _NavigationFocusRequest_default_instance_;
class NavigationFocusResponse;
struct NavigationFocusResponseDefaultTypeInternal;
extern NavigationFocusResponseDefaultTypeInternal _NavigationFocusResponse_default_instance_;
class PhoneStatus;
struct PhoneStatusDefaultTypeInternal;
extern PhoneStatusDefaultTypeInternal _PhoneStatus_default_instance_;
class PhoneStatusInput;
struct PhoneStatusInputDefaultTypeInternal;
extern PhoneStatusInputDefaultTypeInternal _PhoneStatusInput_default_instance_;
class PhoneStatus_Call;
struct PhoneStatus_CallDefaultTypeInternal;
extern PhoneStatus_CallDefaultTypeInternal _PhoneStatus_Call_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class RelativeInputEvent;
struct RelativeInputEventDefaultTypeInternal;
extern RelativeInputEventDefaultTypeInternal _RelativeInputEvent_default_instance_;
class RelativeInputEventWrapper;
struct RelativeInputEventWrapperDefaultTypeInternal;
extern RelativeInputEventWrapperDefaultTypeInternal _RelativeInputEventWrapper_default_instance_;
class SensorEvent;
struct SensorEventDefaultTypeInternal;
extern SensorEventDefaultTypeInternal _SensorEvent_default_instance_;
class SensorEvent_Accel;
struct SensorEvent_AccelDefaultTypeInternal;
extern SensorEvent_AccelDefaultTypeInternal _SensorEvent_Accel_default_instance_;
class SensorEvent_CompassData;
struct SensorEvent_CompassDataDefaultTypeInternal;
extern SensorEvent_CompassDataDefaultTypeInternal _SensorEvent_CompassData_default_instance_;
class SensorEvent_DeadReckoning;
struct SensorEvent_DeadReckoningDefaultTypeInternal;
extern SensorEvent_DeadReckoningDefaultTypeInternal _SensorEvent_DeadReckoning_default_instance_;
class SensorEvent_Diagnostics;
struct SensorEvent_DiagnosticsDefaultTypeInternal;
extern SensorEvent_DiagnosticsDefaultTypeInternal _SensorEvent_Diagnostics_default_instance_;
class SensorEvent_Door;
struct SensorEvent_DoorDefaultTypeInternal;
extern SensorEvent_DoorDefaultTypeInternal _SensorEvent_Door_default_instance_;
class SensorEvent_DrivingStatus;
struct SensorEvent_DrivingStatusDefaultTypeInternal;
extern SensorEvent_DrivingStatusDefaultTypeInternal _SensorEvent_DrivingStatus_default_instance_;
class SensorEvent_Environment;
struct SensorEvent_EnvironmentDefaultTypeInternal;
extern SensorEvent_EnvironmentDefaultTypeInternal _SensorEvent_Environment_default_instance_;
class SensorEvent_FuelLevel;
struct SensorEvent_FuelLevelDefaultTypeInternal;
extern SensorEvent_FuelLevelDefaultTypeInternal _SensorEvent_FuelLevel_default_instance_;
class SensorEvent_GearData;
struct SensorEvent_GearDataDefaultTypeInternal;
extern SensorEvent_GearDataDefaultTypeInternal _SensorEvent_GearData_default_instance_;
class SensorEvent_Gyro;
struct SensorEvent_GyroDefaultTypeInternal;
extern SensorEvent_GyroDefaultTypeInternal _SensorEvent_Gyro_default_instance_;
class SensorEvent_HVAC;
struct SensorEvent_HVACDefaultTypeInternal;
extern SensorEvent_HVACDefaultTypeInternal _SensorEvent_HVAC_default_instance_;
class SensorEvent_Light;
struct SensorEvent_LightDefaultTypeInternal;
extern SensorEvent_LightDefaultTypeInternal _SensorEvent_Light_default_instance_;
class SensorEvent_LocationData;
struct SensorEvent_LocationDataDefaultTypeInternal;
extern SensorEvent_LocationDataDefaultTypeInternal _SensorEvent_LocationData_default_instance_;
class SensorEvent_NightMode;
struct SensorEvent_NightModeDefaultTypeInternal;
extern SensorEvent_NightModeDefaultTypeInternal _SensorEvent_NightMode_default_instance_;
class SensorEvent_OdometerData;
struct SensorEvent_OdometerDataDefaultTypeInternal;
extern SensorEvent_OdometerDataDefaultTypeInternal _SensorEvent_OdometerData_default_instance_;
class SensorEvent_ParkingBreak;
struct SensorEvent_ParkingBreakDefaultTypeInternal;
extern SensorEvent_ParkingBreakDefaultTypeInternal _SensorEvent_ParkingBreak_default_instance_;
class SensorEvent_Passenger;
struct SensorEvent_PassengerDefaultTypeInternal;
extern SensorEvent_PassengerDefaultTypeInternal _SensorEvent_Passenger_default_instance_;
class SensorEvent_RPM;
struct SensorEvent_RPMDefaultTypeInternal;
extern SensorEvent_RPMDefaultTypeInternal _SensorEvent_RPM_default_instance_;
class SensorEvent_SpeedData;
struct SensorEvent_SpeedDataDefaultTypeInternal;
extern SensorEvent_SpeedDataDefaultTypeInternal _SensorEvent_SpeedData_default_instance_;
class SensorStartRequest;
struct SensorStartRequestDefaultTypeInternal;
extern SensorStartRequestDefaultTypeInternal _SensorStartRequest_default_instance_;
class SensorStartResponse;
struct SensorStartResponseDefaultTypeInternal;
extern SensorStartResponseDefaultTypeInternal _SensorStartResponse_default_instance_;
class ServiceDiscoveryRequest;
struct ServiceDiscoveryRequestDefaultTypeInternal;
extern ServiceDiscoveryRequestDefaultTypeInternal _ServiceDiscoveryRequest_default_instance_;
class ServiceDiscoveryResponse;
struct ServiceDiscoveryResponseDefaultTypeInternal;
extern ServiceDiscoveryResponseDefaultTypeInternal _ServiceDiscoveryResponse_default_instance_;
class ShutdownRequest;
struct ShutdownRequestDefaultTypeInternal;
extern ShutdownRequestDefaultTypeInternal _ShutdownRequest_default_instance_;
class ShutdownResponse;
struct ShutdownResponseDefaultTypeInternal;
extern ShutdownResponseDefaultTypeInternal _ShutdownResponse_default_instance_;
class StartGenericNotifications;
struct StartGenericNotificationsDefaultTypeInternal;
extern StartGenericNotificationsDefaultTypeInternal _StartGenericNotifications_default_instance_;
class StopGenericNotifications;
struct StopGenericNotificationsDefaultTypeInternal;
extern StopGenericNotificationsDefaultTypeInternal _StopGenericNotifications_default_instance_;
class TouchInfo;
struct TouchInfoDefaultTypeInternal;
extern TouchInfoDefaultTypeInternal _TouchInfo_default_instance_;
class TouchInfo_Location;
struct TouchInfo_LocationDefaultTypeInternal;
extern TouchInfo_LocationDefaultTypeInternal _TouchInfo_Location_default_instance_;
class VideoFocus;
struct VideoFocusDefaultTypeInternal;
extern VideoFocusDefaultTypeInternal _VideoFocus_default_instance_;
class VideoFocusRequest;
struct VideoFocusRequestDefaultTypeInternal;
extern VideoFocusRequestDefaultTypeInternal _VideoFocusRequest_default_instance_;
class VoiceSessionRequest;
struct VoiceSessionRequestDefaultTypeInternal;
extern VoiceSessionRequestDefaultTypeInternal _VoiceSessionRequest_default_instance_;
}  // namespace HU
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace HU {
enum TouchInfo_TOUCH_ACTION : int {
  TouchInfo_TOUCH_ACTION_TOUCH_ACTION_PRESS = 0,
  TouchInfo_TOUCH_ACTION_TOUCH_ACTION_RELEASE = 1,
  TouchInfo_TOUCH_ACTION_TOUCH_ACTION_DRAG = 2,
};

bool TouchInfo_TOUCH_ACTION_IsValid(int value);
extern const uint32_t TouchInfo_TOUCH_ACTION_internal_data_[];
constexpr TouchInfo_TOUCH_ACTION TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MIN = static_cast<TouchInfo_TOUCH_ACTION>(0);
constexpr TouchInfo_TOUCH_ACTION TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MAX = static_cast<TouchInfo_TOUCH_ACTION>(2);
constexpr int TouchInfo_TOUCH_ACTION_TOUCH_ACTION_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TouchInfo_TOUCH_ACTION_descriptor();
template <typename T>
const std::string& TouchInfo_TOUCH_ACTION_Name(T value) {
  static_assert(std::is_same<T, TouchInfo_TOUCH_ACTION>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TOUCH_ACTION_Name().");
  return TouchInfo_TOUCH_ACTION_Name(static_cast<TouchInfo_TOUCH_ACTION>(value));
}
template <>
inline const std::string& TouchInfo_TOUCH_ACTION_Name(TouchInfo_TOUCH_ACTION value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TouchInfo_TOUCH_ACTION_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TouchInfo_TOUCH_ACTION_Parse(absl::string_view name, TouchInfo_TOUCH_ACTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TouchInfo_TOUCH_ACTION>(
      TouchInfo_TOUCH_ACTION_descriptor(), name, value);
}
enum SensorEvent_DrivingStatus_STATUS : int {
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_FULLY_RESTRICTED = 31,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_LIMIT_MESSAGE_LEN = 16,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_CONFIG = 8,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_KEYBOARD_INPUT = 2,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VIDEO = 1,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VOICE_INPUT = 4,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_UNRESTRICTED = 0,
};

bool SensorEvent_DrivingStatus_STATUS_IsValid(int value);
extern const uint32_t SensorEvent_DrivingStatus_STATUS_internal_data_[];
constexpr SensorEvent_DrivingStatus_STATUS SensorEvent_DrivingStatus_STATUS_STATUS_MIN = static_cast<SensorEvent_DrivingStatus_STATUS>(0);
constexpr SensorEvent_DrivingStatus_STATUS SensorEvent_DrivingStatus_STATUS_STATUS_MAX = static_cast<SensorEvent_DrivingStatus_STATUS>(31);
constexpr int SensorEvent_DrivingStatus_STATUS_STATUS_ARRAYSIZE = 31 + 1;
const ::google::protobuf::EnumDescriptor*
SensorEvent_DrivingStatus_STATUS_descriptor();
template <typename T>
const std::string& SensorEvent_DrivingStatus_STATUS_Name(T value) {
  static_assert(std::is_same<T, SensorEvent_DrivingStatus_STATUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to STATUS_Name().");
  return ::google::protobuf::internal::NameOfEnum(SensorEvent_DrivingStatus_STATUS_descriptor(), value);
}
inline bool SensorEvent_DrivingStatus_STATUS_Parse(absl::string_view name, SensorEvent_DrivingStatus_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorEvent_DrivingStatus_STATUS>(
      SensorEvent_DrivingStatus_STATUS_descriptor(), name, value);
}
enum SensorEvent_Light_HEADLIGHT_STATE : int {
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_0 = 0,
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_1 = 1,
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_2 = 2,
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_3 = 3,
};

bool SensorEvent_Light_HEADLIGHT_STATE_IsValid(int value);
extern const uint32_t SensorEvent_Light_HEADLIGHT_STATE_internal_data_[];
constexpr SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MIN = static_cast<SensorEvent_Light_HEADLIGHT_STATE>(0);
constexpr SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MAX = static_cast<SensorEvent_Light_HEADLIGHT_STATE>(3);
constexpr int SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SensorEvent_Light_HEADLIGHT_STATE_descriptor();
template <typename T>
const std::string& SensorEvent_Light_HEADLIGHT_STATE_Name(T value) {
  static_assert(std::is_same<T, SensorEvent_Light_HEADLIGHT_STATE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HEADLIGHT_STATE_Name().");
  return SensorEvent_Light_HEADLIGHT_STATE_Name(static_cast<SensorEvent_Light_HEADLIGHT_STATE>(value));
}
template <>
inline const std::string& SensorEvent_Light_HEADLIGHT_STATE_Name(SensorEvent_Light_HEADLIGHT_STATE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SensorEvent_Light_HEADLIGHT_STATE_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SensorEvent_Light_HEADLIGHT_STATE_Parse(absl::string_view name, SensorEvent_Light_HEADLIGHT_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorEvent_Light_HEADLIGHT_STATE>(
      SensorEvent_Light_HEADLIGHT_STATE_descriptor(), name, value);
}
enum SensorEvent_Light_TURN_INDICATOR_STATE : int {
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_0 = 0,
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_1 = 1,
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_2 = 2,
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_3 = 3,
};

bool SensorEvent_Light_TURN_INDICATOR_STATE_IsValid(int value);
extern const uint32_t SensorEvent_Light_TURN_INDICATOR_STATE_internal_data_[];
constexpr SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MIN = static_cast<SensorEvent_Light_TURN_INDICATOR_STATE>(0);
constexpr SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MAX = static_cast<SensorEvent_Light_TURN_INDICATOR_STATE>(3);
constexpr int SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SensorEvent_Light_TURN_INDICATOR_STATE_descriptor();
template <typename T>
const std::string& SensorEvent_Light_TURN_INDICATOR_STATE_Name(T value) {
  static_assert(std::is_same<T, SensorEvent_Light_TURN_INDICATOR_STATE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TURN_INDICATOR_STATE_Name().");
  return SensorEvent_Light_TURN_INDICATOR_STATE_Name(static_cast<SensorEvent_Light_TURN_INDICATOR_STATE>(value));
}
template <>
inline const std::string& SensorEvent_Light_TURN_INDICATOR_STATE_Name(SensorEvent_Light_TURN_INDICATOR_STATE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SensorEvent_Light_TURN_INDICATOR_STATE_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SensorEvent_Light_TURN_INDICATOR_STATE_Parse(absl::string_view name, SensorEvent_Light_TURN_INDICATOR_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorEvent_Light_TURN_INDICATOR_STATE>(
      SensorEvent_Light_TURN_INDICATOR_STATE_descriptor(), name, value);
}
enum SensorEvent_GearData_GEAR : int {
  SensorEvent_GearData_GEAR_GEAR_DRIVE = 100,
  SensorEvent_GearData_GEAR_GEAR_EIGHTH = 8,
  SensorEvent_GearData_GEAR_GEAR_FIFTH = 5,
  SensorEvent_GearData_GEAR_GEAR_FIRST = 1,
  SensorEvent_GearData_GEAR_GEAR_FOURTH = 4,
  SensorEvent_GearData_GEAR_GEAR_NEUTRAL = 0,
  SensorEvent_GearData_GEAR_GEAR_NINTH = 9,
  SensorEvent_GearData_GEAR_GEAR_PARK = 101,
  SensorEvent_GearData_GEAR_GEAR_REVERSE = 102,
  SensorEvent_GearData_GEAR_GEAR_SECOND = 2,
  SensorEvent_GearData_GEAR_GEAR_SEVENTH = 7,
  SensorEvent_GearData_GEAR_GEAR_SIXTH = 6,
  SensorEvent_GearData_GEAR_GEAR_TENTH = 10,
  SensorEvent_GearData_GEAR_GEAR_THIRD = 3,
};

bool SensorEvent_GearData_GEAR_IsValid(int value);
extern const uint32_t SensorEvent_GearData_GEAR_internal_data_[];
constexpr SensorEvent_GearData_GEAR SensorEvent_GearData_GEAR_GEAR_MIN = static_cast<SensorEvent_GearData_GEAR>(0);
constexpr SensorEvent_GearData_GEAR SensorEvent_GearData_GEAR_GEAR_MAX = static_cast<SensorEvent_GearData_GEAR>(102);
constexpr int SensorEvent_GearData_GEAR_GEAR_ARRAYSIZE = 102 + 1;
const ::google::protobuf::EnumDescriptor*
SensorEvent_GearData_GEAR_descriptor();
template <typename T>
const std::string& SensorEvent_GearData_GEAR_Name(T value) {
  static_assert(std::is_same<T, SensorEvent_GearData_GEAR>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GEAR_Name().");
  return ::google::protobuf::internal::NameOfEnum(SensorEvent_GearData_GEAR_descriptor(), value);
}
inline bool SensorEvent_GearData_GEAR_Parse(absl::string_view name, SensorEvent_GearData_GEAR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorEvent_GearData_GEAR>(
      SensorEvent_GearData_GEAR_descriptor(), name, value);
}
enum ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION : int {
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_800x480 = 1,
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1280x720 = 2,
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1920x1080 = 3,
};

bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_IsValid(int value);
extern const uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_internal_data_[];
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MIN = static_cast<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>(1);
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MAX = static_cast<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>(3);
constexpr int ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor();
template <typename T>
const std::string& ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name(T value) {
  static_assert(std::is_same<T, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VIDEO_RESOLUTION_Name().");
  return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name(static_cast<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>(value));
}
template <>
inline const std::string& ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name(ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Parse(absl::string_view name, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>(
      ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor(), name, value);
}
enum ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS : int {
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_30 = 1,
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_60 = 2,
};

bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_IsValid(int value);
extern const uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_internal_data_[];
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MIN = static_cast<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>(1);
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MAX = static_cast<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>(2);
constexpr int ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor();
template <typename T>
const std::string& ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name(T value) {
  static_assert(std::is_same<T, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VIDEO_FPS_Name().");
  return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name(static_cast<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>(value));
}
template <>
inline const std::string& ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name(ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Parse(absl::string_view name, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>(
      ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor(), name, value);
}
enum ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE : int {
  ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CUSTOM_IMAGES_SUPPORTED = 1,
  ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IMAGE_CODES_ONLY = 2,
};

bool ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IsValid(int value);
extern const uint32_t ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_internal_data_[];
constexpr ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MIN = static_cast<ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>(1);
constexpr ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MAX = static_cast<ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>(2);
constexpr int ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor();
template <typename T>
const std::string& ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name(T value) {
  static_assert(std::is_same<T, ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CLUSTER_TYPE_Name().");
  return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name(static_cast<ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>(value));
}
template <>
inline const std::string& ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name(ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Parse(absl::string_view name, ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>(
      ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor(), name, value);
}
enum ShutdownRequest_REASON : int {
  ShutdownRequest_REASON_REASON_QUIT = 1,
};

bool ShutdownRequest_REASON_IsValid(int value);
extern const uint32_t ShutdownRequest_REASON_internal_data_[];
constexpr ShutdownRequest_REASON ShutdownRequest_REASON_REASON_MIN = static_cast<ShutdownRequest_REASON>(1);
constexpr ShutdownRequest_REASON ShutdownRequest_REASON_REASON_MAX = static_cast<ShutdownRequest_REASON>(1);
constexpr int ShutdownRequest_REASON_REASON_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ShutdownRequest_REASON_descriptor();
template <typename T>
const std::string& ShutdownRequest_REASON_Name(T value) {
  static_assert(std::is_same<T, ShutdownRequest_REASON>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to REASON_Name().");
  return ShutdownRequest_REASON_Name(static_cast<ShutdownRequest_REASON>(value));
}
template <>
inline const std::string& ShutdownRequest_REASON_Name(ShutdownRequest_REASON value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShutdownRequest_REASON_descriptor,
                                                 1, 1>(
      static_cast<int>(value));
}
inline bool ShutdownRequest_REASON_Parse(absl::string_view name, ShutdownRequest_REASON* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShutdownRequest_REASON>(
      ShutdownRequest_REASON_descriptor(), name, value);
}
enum MediaSetupResponse_MEDIA_STATUS : int {
  MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_1 = 1,
  MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_2 = 2,
};

bool MediaSetupResponse_MEDIA_STATUS_IsValid(int value);
extern const uint32_t MediaSetupResponse_MEDIA_STATUS_internal_data_[];
constexpr MediaSetupResponse_MEDIA_STATUS MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MIN = static_cast<MediaSetupResponse_MEDIA_STATUS>(1);
constexpr MediaSetupResponse_MEDIA_STATUS MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MAX = static_cast<MediaSetupResponse_MEDIA_STATUS>(2);
constexpr int MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MediaSetupResponse_MEDIA_STATUS_descriptor();
template <typename T>
const std::string& MediaSetupResponse_MEDIA_STATUS_Name(T value) {
  static_assert(std::is_same<T, MediaSetupResponse_MEDIA_STATUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MEDIA_STATUS_Name().");
  return MediaSetupResponse_MEDIA_STATUS_Name(static_cast<MediaSetupResponse_MEDIA_STATUS>(value));
}
template <>
inline const std::string& MediaSetupResponse_MEDIA_STATUS_Name(MediaSetupResponse_MEDIA_STATUS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MediaSetupResponse_MEDIA_STATUS_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool MediaSetupResponse_MEDIA_STATUS_Parse(absl::string_view name, MediaSetupResponse_MEDIA_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MediaSetupResponse_MEDIA_STATUS>(
      MediaSetupResponse_MEDIA_STATUS_descriptor(), name, value);
}
enum VoiceSessionRequest_VOICE_STATUS : int {
  VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_START = 1,
  VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_STOP = 2,
};

bool VoiceSessionRequest_VOICE_STATUS_IsValid(int value);
extern const uint32_t VoiceSessionRequest_VOICE_STATUS_internal_data_[];
constexpr VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MIN = static_cast<VoiceSessionRequest_VOICE_STATUS>(1);
constexpr VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MAX = static_cast<VoiceSessionRequest_VOICE_STATUS>(2);
constexpr int VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VoiceSessionRequest_VOICE_STATUS_descriptor();
template <typename T>
const std::string& VoiceSessionRequest_VOICE_STATUS_Name(T value) {
  static_assert(std::is_same<T, VoiceSessionRequest_VOICE_STATUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VOICE_STATUS_Name().");
  return VoiceSessionRequest_VOICE_STATUS_Name(static_cast<VoiceSessionRequest_VOICE_STATUS>(value));
}
template <>
inline const std::string& VoiceSessionRequest_VOICE_STATUS_Name(VoiceSessionRequest_VOICE_STATUS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VoiceSessionRequest_VOICE_STATUS_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool VoiceSessionRequest_VOICE_STATUS_Parse(absl::string_view name, VoiceSessionRequest_VOICE_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VoiceSessionRequest_VOICE_STATUS>(
      VoiceSessionRequest_VOICE_STATUS_descriptor(), name, value);
}
enum AudioFocusRequest_AUDIO_FOCUS : int {
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN = 1,
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_TRANSIENT = 2,
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_NAVI = 3,
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_RELEASE = 4,
};

bool AudioFocusRequest_AUDIO_FOCUS_IsValid(int value);
extern const uint32_t AudioFocusRequest_AUDIO_FOCUS_internal_data_[];
constexpr AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MIN = static_cast<AudioFocusRequest_AUDIO_FOCUS>(1);
constexpr AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MAX = static_cast<AudioFocusRequest_AUDIO_FOCUS>(4);
constexpr int AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AudioFocusRequest_AUDIO_FOCUS_descriptor();
template <typename T>
const std::string& AudioFocusRequest_AUDIO_FOCUS_Name(T value) {
  static_assert(std::is_same<T, AudioFocusRequest_AUDIO_FOCUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AUDIO_FOCUS_Name().");
  return AudioFocusRequest_AUDIO_FOCUS_Name(static_cast<AudioFocusRequest_AUDIO_FOCUS>(value));
}
template <>
inline const std::string& AudioFocusRequest_AUDIO_FOCUS_Name(AudioFocusRequest_AUDIO_FOCUS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AudioFocusRequest_AUDIO_FOCUS_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool AudioFocusRequest_AUDIO_FOCUS_Parse(absl::string_view name, AudioFocusRequest_AUDIO_FOCUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioFocusRequest_AUDIO_FOCUS>(
      AudioFocusRequest_AUDIO_FOCUS_descriptor(), name, value);
}
enum AudioFocusResponse_AUDIO_FOCUS_STATE : int {
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN = 1,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT = 2,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS = 3,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK = 4,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 5,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY = 6,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY = 7,
};

bool AudioFocusResponse_AUDIO_FOCUS_STATE_IsValid(int value);
extern const uint32_t AudioFocusResponse_AUDIO_FOCUS_STATE_internal_data_[];
constexpr AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MIN = static_cast<AudioFocusResponse_AUDIO_FOCUS_STATE>(1);
constexpr AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MAX = static_cast<AudioFocusResponse_AUDIO_FOCUS_STATE>(7);
constexpr int AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor();
template <typename T>
const std::string& AudioFocusResponse_AUDIO_FOCUS_STATE_Name(T value) {
  static_assert(std::is_same<T, AudioFocusResponse_AUDIO_FOCUS_STATE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AUDIO_FOCUS_STATE_Name().");
  return AudioFocusResponse_AUDIO_FOCUS_STATE_Name(static_cast<AudioFocusResponse_AUDIO_FOCUS_STATE>(value));
}
template <>
inline const std::string& AudioFocusResponse_AUDIO_FOCUS_STATE_Name(AudioFocusResponse_AUDIO_FOCUS_STATE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor,
                                                 1, 7>(
      static_cast<int>(value));
}
inline bool AudioFocusResponse_AUDIO_FOCUS_STATE_Parse(absl::string_view name, AudioFocusResponse_AUDIO_FOCUS_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioFocusResponse_AUDIO_FOCUS_STATE>(
      AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor(), name, value);
}
enum PhoneStatus_PHONE_STATE : int {
  PhoneStatus_PHONE_STATE_PHONE_STATE_IN_CALL = 1,
  PhoneStatus_PHONE_STATE_PHONE_STATE_ON_HOLD = 2,
  PhoneStatus_PHONE_STATE_PHONE_STATE_HANGINGUP = 3,
  PhoneStatus_PHONE_STATE_PHONE_STATE_INCOMING = 4,
  PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_5 = 5,
  PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_6 = 6,
};

bool PhoneStatus_PHONE_STATE_IsValid(int value);
extern const uint32_t PhoneStatus_PHONE_STATE_internal_data_[];
constexpr PhoneStatus_PHONE_STATE PhoneStatus_PHONE_STATE_PHONE_STATE_MIN = static_cast<PhoneStatus_PHONE_STATE>(1);
constexpr PhoneStatus_PHONE_STATE PhoneStatus_PHONE_STATE_PHONE_STATE_MAX = static_cast<PhoneStatus_PHONE_STATE>(6);
constexpr int PhoneStatus_PHONE_STATE_PHONE_STATE_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PhoneStatus_PHONE_STATE_descriptor();
template <typename T>
const std::string& PhoneStatus_PHONE_STATE_Name(T value) {
  static_assert(std::is_same<T, PhoneStatus_PHONE_STATE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PHONE_STATE_Name().");
  return PhoneStatus_PHONE_STATE_Name(static_cast<PhoneStatus_PHONE_STATE>(value));
}
template <>
inline const std::string& PhoneStatus_PHONE_STATE_Name(PhoneStatus_PHONE_STATE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PhoneStatus_PHONE_STATE_descriptor,
                                                 1, 6>(
      static_cast<int>(value));
}
inline bool PhoneStatus_PHONE_STATE_Parse(absl::string_view name, PhoneStatus_PHONE_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PhoneStatus_PHONE_STATE>(
      PhoneStatus_PHONE_STATE_descriptor(), name, value);
}
enum BluetoothPairingResponse_PAIRING_STATUS : int {
  BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_1 = 1,
  BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_2 = 2,
};

bool BluetoothPairingResponse_PAIRING_STATUS_IsValid(int value);
extern const uint32_t BluetoothPairingResponse_PAIRING_STATUS_internal_data_[];
constexpr BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MIN = static_cast<BluetoothPairingResponse_PAIRING_STATUS>(1);
constexpr BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MAX = static_cast<BluetoothPairingResponse_PAIRING_STATUS>(2);
constexpr int BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
BluetoothPairingResponse_PAIRING_STATUS_descriptor();
template <typename T>
const std::string& BluetoothPairingResponse_PAIRING_STATUS_Name(T value) {
  static_assert(std::is_same<T, BluetoothPairingResponse_PAIRING_STATUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PAIRING_STATUS_Name().");
  return BluetoothPairingResponse_PAIRING_STATUS_Name(static_cast<BluetoothPairingResponse_PAIRING_STATUS>(value));
}
template <>
inline const std::string& BluetoothPairingResponse_PAIRING_STATUS_Name(BluetoothPairingResponse_PAIRING_STATUS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BluetoothPairingResponse_PAIRING_STATUS_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool BluetoothPairingResponse_PAIRING_STATUS_Parse(absl::string_view name, BluetoothPairingResponse_PAIRING_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BluetoothPairingResponse_PAIRING_STATUS>(
      BluetoothPairingResponse_PAIRING_STATUS_descriptor(), name, value);
}
enum NAVMessagesStatus_STATUS : int {
  NAVMessagesStatus_STATUS_START = 1,
  NAVMessagesStatus_STATUS_STOP = 2,
};

bool NAVMessagesStatus_STATUS_IsValid(int value);
extern const uint32_t NAVMessagesStatus_STATUS_internal_data_[];
constexpr NAVMessagesStatus_STATUS NAVMessagesStatus_STATUS_STATUS_MIN = static_cast<NAVMessagesStatus_STATUS>(1);
constexpr NAVMessagesStatus_STATUS NAVMessagesStatus_STATUS_STATUS_MAX = static_cast<NAVMessagesStatus_STATUS>(2);
constexpr int NAVMessagesStatus_STATUS_STATUS_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NAVMessagesStatus_STATUS_descriptor();
template <typename T>
const std::string& NAVMessagesStatus_STATUS_Name(T value) {
  static_assert(std::is_same<T, NAVMessagesStatus_STATUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to STATUS_Name().");
  return NAVMessagesStatus_STATUS_Name(static_cast<NAVMessagesStatus_STATUS>(value));
}
template <>
inline const std::string& NAVMessagesStatus_STATUS_Name(NAVMessagesStatus_STATUS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NAVMessagesStatus_STATUS_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool NAVMessagesStatus_STATUS_Parse(absl::string_view name, NAVMessagesStatus_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NAVMessagesStatus_STATUS>(
      NAVMessagesStatus_STATUS_descriptor(), name, value);
}
enum NAVTurnMessage_TURN_SIDE : int {
  NAVTurnMessage_TURN_SIDE_TURN_LEFT = 1,
  NAVTurnMessage_TURN_SIDE_TURN_RIGHT = 2,
  NAVTurnMessage_TURN_SIDE_TURN_UNSPECIFIED = 3,
};

bool NAVTurnMessage_TURN_SIDE_IsValid(int value);
extern const uint32_t NAVTurnMessage_TURN_SIDE_internal_data_[];
constexpr NAVTurnMessage_TURN_SIDE NAVTurnMessage_TURN_SIDE_TURN_SIDE_MIN = static_cast<NAVTurnMessage_TURN_SIDE>(1);
constexpr NAVTurnMessage_TURN_SIDE NAVTurnMessage_TURN_SIDE_TURN_SIDE_MAX = static_cast<NAVTurnMessage_TURN_SIDE>(3);
constexpr int NAVTurnMessage_TURN_SIDE_TURN_SIDE_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
NAVTurnMessage_TURN_SIDE_descriptor();
template <typename T>
const std::string& NAVTurnMessage_TURN_SIDE_Name(T value) {
  static_assert(std::is_same<T, NAVTurnMessage_TURN_SIDE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TURN_SIDE_Name().");
  return NAVTurnMessage_TURN_SIDE_Name(static_cast<NAVTurnMessage_TURN_SIDE>(value));
}
template <>
inline const std::string& NAVTurnMessage_TURN_SIDE_Name(NAVTurnMessage_TURN_SIDE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NAVTurnMessage_TURN_SIDE_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool NAVTurnMessage_TURN_SIDE_Parse(absl::string_view name, NAVTurnMessage_TURN_SIDE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NAVTurnMessage_TURN_SIDE>(
      NAVTurnMessage_TURN_SIDE_descriptor(), name, value);
}
enum NAVTurnMessage_TURN_EVENT : int {
  NAVTurnMessage_TURN_EVENT_TURN_UNKNOWN = 0,
  NAVTurnMessage_TURN_EVENT_TURN_DEPART = 1,
  NAVTurnMessage_TURN_EVENT_TURN_NAME_CHANGE = 2,
  NAVTurnMessage_TURN_EVENT_TURN_SLIGHT_TURN = 3,
  NAVTurnMessage_TURN_EVENT_TURN_TURN = 4,
  NAVTurnMessage_TURN_EVENT_TURN_SHARP_TURN = 5,
  NAVTurnMessage_TURN_EVENT_TURN_U_TURN = 6,
  NAVTurnMessage_TURN_EVENT_TURN_ON_RAMP = 7,
  NAVTurnMessage_TURN_EVENT_TURN_OFF_RAMP = 8,
  NAVTurnMessage_TURN_EVENT_TURN_FORK = 9,
  NAVTurnMessage_TURN_EVENT_TURN_MERGE = 10,
  NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER = 11,
  NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_EXIT = 12,
  NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER_AND_EXIT = 13,
  NAVTurnMessage_TURN_EVENT_TURN_STRAIGHT = 14,
  NAVTurnMessage_TURN_EVENT_TURN_FERRY_BOAT = 16,
  NAVTurnMessage_TURN_EVENT_TURN_FERRY_TRAIN = 17,
  NAVTurnMessage_TURN_EVENT_TURN_DESTINATION = 19,
};

bool NAVTurnMessage_TURN_EVENT_IsValid(int value);
extern const uint32_t NAVTurnMessage_TURN_EVENT_internal_data_[];
constexpr NAVTurnMessage_TURN_EVENT NAVTurnMessage_TURN_EVENT_TURN_EVENT_MIN = static_cast<NAVTurnMessage_TURN_EVENT>(0);
constexpr NAVTurnMessage_TURN_EVENT NAVTurnMessage_TURN_EVENT_TURN_EVENT_MAX = static_cast<NAVTurnMessage_TURN_EVENT>(19);
constexpr int NAVTurnMessage_TURN_EVENT_TURN_EVENT_ARRAYSIZE = 19 + 1;
const ::google::protobuf::EnumDescriptor*
NAVTurnMessage_TURN_EVENT_descriptor();
template <typename T>
const std::string& NAVTurnMessage_TURN_EVENT_Name(T value) {
  static_assert(std::is_same<T, NAVTurnMessage_TURN_EVENT>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TURN_EVENT_Name().");
  return NAVTurnMessage_TURN_EVENT_Name(static_cast<NAVTurnMessage_TURN_EVENT>(value));
}
template <>
inline const std::string& NAVTurnMessage_TURN_EVENT_Name(NAVTurnMessage_TURN_EVENT value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NAVTurnMessage_TURN_EVENT_descriptor,
                                                 0, 19>(
      static_cast<int>(value));
}
inline bool NAVTurnMessage_TURN_EVENT_Parse(absl::string_view name, NAVTurnMessage_TURN_EVENT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NAVTurnMessage_TURN_EVENT>(
      NAVTurnMessage_TURN_EVENT_descriptor(), name, value);
}
enum NAVDistanceMessage_DISPLAY_DISTANCE_UNIT : int {
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_METERS = 1,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS10 = 2,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS = 3,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES10 = 4,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES = 5,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_FEET = 6,
};

bool NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_IsValid(int value);
extern const uint32_t NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_internal_data_[];
constexpr NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MIN = static_cast<NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>(1);
constexpr NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MAX = static_cast<NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>(6);
constexpr int NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor();
template <typename T>
const std::string& NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name(T value) {
  static_assert(std::is_same<T, NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DISPLAY_DISTANCE_UNIT_Name().");
  return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name(static_cast<NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>(value));
}
template <>
inline const std::string& NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name(NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor,
                                                 1, 6>(
      static_cast<int>(value));
}
inline bool NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Parse(absl::string_view name, NAVDistanceMessage_DISPLAY_DISTANCE_UNIT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>(
      NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor(), name, value);
}
enum STATUS : int {
  STATUS_OK = 0,
};

bool STATUS_IsValid(int value);
extern const uint32_t STATUS_internal_data_[];
constexpr STATUS STATUS_MIN = static_cast<STATUS>(0);
constexpr STATUS STATUS_MAX = static_cast<STATUS>(0);
constexpr int STATUS_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
STATUS_descriptor();
template <typename T>
const std::string& STATUS_Name(T value) {
  static_assert(std::is_same<T, STATUS>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to STATUS_Name().");
  return STATUS_Name(static_cast<STATUS>(value));
}
template <>
inline const std::string& STATUS_Name(STATUS value) {
  return ::google::protobuf::internal::NameOfDenseEnum<STATUS_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool STATUS_Parse(absl::string_view name, STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STATUS>(
      STATUS_descriptor(), name, value);
}
enum SENSOR_TYPE : int {
  SENSOR_TYPE_LOCATION = 1,
  SENSOR_TYPE_COMPASS = 2,
  SENSOR_TYPE_CAR_SPEED = 3,
  SENSOR_TYPE_RPM = 4,
  SENSOR_TYPE_ODOMETER = 5,
  SENSOR_TYPE_FUEL_LEVEL = 6,
  SENSOR_TYPE_PARKING_BRAKE = 7,
  SENSOR_TYPE_GEAR = 8,
  SENSOR_TYPE_DIAGNOSTICS = 9,
  SENSOR_TYPE_NIGHT_DATA = 10,
  SENSOR_TYPE_ENVIRONMENT = 11,
  SENSOR_TYPE_HVAC = 12,
  SENSOR_TYPE_DRIVING_STATUS = 13,
  SENSOR_TYPE_DEAD_RECONING = 14,
  SENSOR_TYPE_PASSENGER = 15,
  SENSOR_TYPE_DOOR = 16,
  SENSOR_TYPE_LIGHT = 17,
  SENSOR_TYPE_TIRE = 18,
  SENSOR_TYPE_ACCEL = 19,
  SENSOR_TYPE_GYRO = 20,
  SENSOR_TYPE_GPS = 21,
};

bool SENSOR_TYPE_IsValid(int value);
extern const uint32_t SENSOR_TYPE_internal_data_[];
constexpr SENSOR_TYPE SENSOR_TYPE_MIN = static_cast<SENSOR_TYPE>(1);
constexpr SENSOR_TYPE SENSOR_TYPE_MAX = static_cast<SENSOR_TYPE>(21);
constexpr int SENSOR_TYPE_ARRAYSIZE = 21 + 1;
const ::google::protobuf::EnumDescriptor*
SENSOR_TYPE_descriptor();
template <typename T>
const std::string& SENSOR_TYPE_Name(T value) {
  static_assert(std::is_same<T, SENSOR_TYPE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SENSOR_TYPE_Name().");
  return SENSOR_TYPE_Name(static_cast<SENSOR_TYPE>(value));
}
template <>
inline const std::string& SENSOR_TYPE_Name(SENSOR_TYPE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SENSOR_TYPE_descriptor,
                                                 1, 21>(
      static_cast<int>(value));
}
inline bool SENSOR_TYPE_Parse(absl::string_view name, SENSOR_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SENSOR_TYPE>(
      SENSOR_TYPE_descriptor(), name, value);
}
enum AUDIO_TYPE : int {
  AUDIO_TYPE_SPEECH = 1,
  AUDIO_TYPE_SYSTEM = 2,
  AUDIO_TYPE_MEDIA = 3,
  AUDIO_TYPE_ALARM = 4,
};

bool AUDIO_TYPE_IsValid(int value);
extern const uint32_t AUDIO_TYPE_internal_data_[];
constexpr AUDIO_TYPE AUDIO_TYPE_MIN = static_cast<AUDIO_TYPE>(1);
constexpr AUDIO_TYPE AUDIO_TYPE_MAX = static_cast<AUDIO_TYPE>(4);
constexpr int AUDIO_TYPE_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AUDIO_TYPE_descriptor();
template <typename T>
const std::string& AUDIO_TYPE_Name(T value) {
  static_assert(std::is_same<T, AUDIO_TYPE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AUDIO_TYPE_Name().");
  return AUDIO_TYPE_Name(static_cast<AUDIO_TYPE>(value));
}
template <>
inline const std::string& AUDIO_TYPE_Name(AUDIO_TYPE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AUDIO_TYPE_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool AUDIO_TYPE_Parse(absl::string_view name, AUDIO_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AUDIO_TYPE>(
      AUDIO_TYPE_descriptor(), name, value);
}
enum STREAM_TYPE : int {
  STREAM_TYPE_AUDIO = 1,
  STREAM_TYPE_VIDEO = 3,
};

bool STREAM_TYPE_IsValid(int value);
extern const uint32_t STREAM_TYPE_internal_data_[];
constexpr STREAM_TYPE STREAM_TYPE_MIN = static_cast<STREAM_TYPE>(1);
constexpr STREAM_TYPE STREAM_TYPE_MAX = static_cast<STREAM_TYPE>(3);
constexpr int STREAM_TYPE_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
STREAM_TYPE_descriptor();
template <typename T>
const std::string& STREAM_TYPE_Name(T value) {
  static_assert(std::is_same<T, STREAM_TYPE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to STREAM_TYPE_Name().");
  return STREAM_TYPE_Name(static_cast<STREAM_TYPE>(value));
}
template <>
inline const std::string& STREAM_TYPE_Name(STREAM_TYPE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<STREAM_TYPE_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool STREAM_TYPE_Parse(absl::string_view name, STREAM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STREAM_TYPE>(
      STREAM_TYPE_descriptor(), name, value);
}
enum BluetoothPairingMethod : int {
  BLUETOOTH_PARING_METHOD_1 = 1,
  BLUETOOTH_PARING_METHOD_A2DP = 2,
  BLUETOOTH_PARING_METHOD_3 = 3,
  BLUETOOTH_PARING_METHOD_HFP = 4,
};

bool BluetoothPairingMethod_IsValid(int value);
extern const uint32_t BluetoothPairingMethod_internal_data_[];
constexpr BluetoothPairingMethod BluetoothPairingMethod_MIN = static_cast<BluetoothPairingMethod>(1);
constexpr BluetoothPairingMethod BluetoothPairingMethod_MAX = static_cast<BluetoothPairingMethod>(4);
constexpr int BluetoothPairingMethod_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
BluetoothPairingMethod_descriptor();
template <typename T>
const std::string& BluetoothPairingMethod_Name(T value) {
  static_assert(std::is_same<T, BluetoothPairingMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BluetoothPairingMethod_Name().");
  return BluetoothPairingMethod_Name(static_cast<BluetoothPairingMethod>(value));
}
template <>
inline const std::string& BluetoothPairingMethod_Name(BluetoothPairingMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BluetoothPairingMethod_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool BluetoothPairingMethod_Parse(absl::string_view name, BluetoothPairingMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BluetoothPairingMethod>(
      BluetoothPairingMethod_descriptor(), name, value);
}
enum VIDEO_FOCUS_MODE : int {
  VIDEO_FOCUS_MODE_FOCUSED = 1,
  VIDEO_FOCUS_MODE_UNFOCUSED = 2,
};

bool VIDEO_FOCUS_MODE_IsValid(int value);
extern const uint32_t VIDEO_FOCUS_MODE_internal_data_[];
constexpr VIDEO_FOCUS_MODE VIDEO_FOCUS_MODE_MIN = static_cast<VIDEO_FOCUS_MODE>(1);
constexpr VIDEO_FOCUS_MODE VIDEO_FOCUS_MODE_MAX = static_cast<VIDEO_FOCUS_MODE>(2);
constexpr int VIDEO_FOCUS_MODE_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VIDEO_FOCUS_MODE_descriptor();
template <typename T>
const std::string& VIDEO_FOCUS_MODE_Name(T value) {
  static_assert(std::is_same<T, VIDEO_FOCUS_MODE>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VIDEO_FOCUS_MODE_Name().");
  return VIDEO_FOCUS_MODE_Name(static_cast<VIDEO_FOCUS_MODE>(value));
}
template <>
inline const std::string& VIDEO_FOCUS_MODE_Name(VIDEO_FOCUS_MODE value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VIDEO_FOCUS_MODE_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool VIDEO_FOCUS_MODE_Parse(absl::string_view name, VIDEO_FOCUS_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VIDEO_FOCUS_MODE>(
      VIDEO_FOCUS_MODE_descriptor(), name, value);
}
enum VIDEO_FOCUS_REASON : int {
  VIDEO_FOCUS_REASON_1 = 1,
  VIDEO_FOCUS_REASON_2 = 2,
};

bool VIDEO_FOCUS_REASON_IsValid(int value);
extern const uint32_t VIDEO_FOCUS_REASON_internal_data_[];
constexpr VIDEO_FOCUS_REASON VIDEO_FOCUS_REASON_MIN = static_cast<VIDEO_FOCUS_REASON>(1);
constexpr VIDEO_FOCUS_REASON VIDEO_FOCUS_REASON_MAX = static_cast<VIDEO_FOCUS_REASON>(2);
constexpr int VIDEO_FOCUS_REASON_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VIDEO_FOCUS_REASON_descriptor();
template <typename T>
const std::string& VIDEO_FOCUS_REASON_Name(T value) {
  static_assert(std::is_same<T, VIDEO_FOCUS_REASON>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VIDEO_FOCUS_REASON_Name().");
  return VIDEO_FOCUS_REASON_Name(static_cast<VIDEO_FOCUS_REASON>(value));
}
template <>
inline const std::string& VIDEO_FOCUS_REASON_Name(VIDEO_FOCUS_REASON value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VIDEO_FOCUS_REASON_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool VIDEO_FOCUS_REASON_Parse(absl::string_view name, VIDEO_FOCUS_REASON* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VIDEO_FOCUS_REASON>(
      VIDEO_FOCUS_REASON_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VoiceSessionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.VoiceSessionRequest) */ {
 public:
  inline VoiceSessionRequest() : VoiceSessionRequest(nullptr) {}
  ~VoiceSessionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VoiceSessionRequest(::google::protobuf::internal::ConstantInitialized);

  inline VoiceSessionRequest(const VoiceSessionRequest& from)
      : VoiceSessionRequest(nullptr, from) {}
  VoiceSessionRequest(VoiceSessionRequest&& from) noexcept
    : VoiceSessionRequest() {
    *this = ::std::move(from);
  }

  inline VoiceSessionRequest& operator=(const VoiceSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceSessionRequest& operator=(VoiceSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoiceSessionRequest* internal_default_instance() {
    return reinterpret_cast<const VoiceSessionRequest*>(
               &_VoiceSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(VoiceSessionRequest& a, VoiceSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoiceSessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoiceSessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VoiceSessionRequest& from) {
    VoiceSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VoiceSessionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.VoiceSessionRequest";
  }
  protected:
  explicit VoiceSessionRequest(::google::protobuf::Arena* arena);
  VoiceSessionRequest(::google::protobuf::Arena* arena, const VoiceSessionRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VOICE_STATUS = VoiceSessionRequest_VOICE_STATUS;
  static constexpr VOICE_STATUS VOICE_STATUS_START = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_START;
  static constexpr VOICE_STATUS VOICE_STATUS_STOP = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_STOP;
  static inline bool VOICE_STATUS_IsValid(int value) {
    return VoiceSessionRequest_VOICE_STATUS_IsValid(value);
  }
  static constexpr VOICE_STATUS VOICE_STATUS_MIN = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MIN;
  static constexpr VOICE_STATUS VOICE_STATUS_MAX = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MAX;
  static constexpr int VOICE_STATUS_ARRAYSIZE = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VOICE_STATUS_descriptor() {
    return VoiceSessionRequest_VOICE_STATUS_descriptor();
  }
  template <typename T>
  static inline const std::string& VOICE_STATUS_Name(T value) {
    return VoiceSessionRequest_VOICE_STATUS_Name(value);
  }
  static inline bool VOICE_STATUS_Parse(absl::string_view name, VOICE_STATUS* value) {
    return VoiceSessionRequest_VOICE_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVoiceStatusFieldNumber = 1,
  };
  // optional .HU.VoiceSessionRequest.VOICE_STATUS voice_status = 1;
  bool has_voice_status() const;
  void clear_voice_status() ;
  ::HU::VoiceSessionRequest_VOICE_STATUS voice_status() const;
  void set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value);

  private:
  ::HU::VoiceSessionRequest_VOICE_STATUS _internal_voice_status() const;
  void _internal_set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.VoiceSessionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int voice_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class VideoFocusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.VideoFocusRequest) */ {
 public:
  inline VideoFocusRequest() : VideoFocusRequest(nullptr) {}
  ~VideoFocusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoFocusRequest(::google::protobuf::internal::ConstantInitialized);

  inline VideoFocusRequest(const VideoFocusRequest& from)
      : VideoFocusRequest(nullptr, from) {}
  VideoFocusRequest(VideoFocusRequest&& from) noexcept
    : VideoFocusRequest() {
    *this = ::std::move(from);
  }

  inline VideoFocusRequest& operator=(const VideoFocusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFocusRequest& operator=(VideoFocusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoFocusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoFocusRequest* internal_default_instance() {
    return reinterpret_cast<const VideoFocusRequest*>(
               &_VideoFocusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(VideoFocusRequest& a, VideoFocusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFocusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFocusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoFocusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoFocusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VideoFocusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VideoFocusRequest& from) {
    VideoFocusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VideoFocusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.VideoFocusRequest";
  }
  protected:
  explicit VideoFocusRequest(::google::protobuf::Arena* arena);
  VideoFocusRequest(::google::protobuf::Arena* arena, const VideoFocusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDispIndexFieldNumber = 1,
    kModeFieldNumber = 2,
    kReasonFieldNumber = 3,
  };
  // optional int32 disp_index = 1;
  bool has_disp_index() const;
  void clear_disp_index() ;
  ::int32_t disp_index() const;
  void set_disp_index(::int32_t value);

  private:
  ::int32_t _internal_disp_index() const;
  void _internal_set_disp_index(::int32_t value);

  public:
  // optional .HU.VIDEO_FOCUS_MODE mode = 2;
  bool has_mode() const;
  void clear_mode() ;
  ::HU::VIDEO_FOCUS_MODE mode() const;
  void set_mode(::HU::VIDEO_FOCUS_MODE value);

  private:
  ::HU::VIDEO_FOCUS_MODE _internal_mode() const;
  void _internal_set_mode(::HU::VIDEO_FOCUS_MODE value);

  public:
  // optional .HU.VIDEO_FOCUS_REASON reason = 3;
  bool has_reason() const;
  void clear_reason() ;
  ::HU::VIDEO_FOCUS_REASON reason() const;
  void set_reason(::HU::VIDEO_FOCUS_REASON value);

  private:
  ::HU::VIDEO_FOCUS_REASON _internal_reason() const;
  void _internal_set_reason(::HU::VIDEO_FOCUS_REASON value);

  public:
  // @@protoc_insertion_point(class_scope:HU.VideoFocusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t disp_index_;
    int mode_;
    int reason_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class VideoFocus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.VideoFocus) */ {
 public:
  inline VideoFocus() : VideoFocus(nullptr) {}
  ~VideoFocus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoFocus(::google::protobuf::internal::ConstantInitialized);

  inline VideoFocus(const VideoFocus& from)
      : VideoFocus(nullptr, from) {}
  VideoFocus(VideoFocus&& from) noexcept
    : VideoFocus() {
    *this = ::std::move(from);
  }

  inline VideoFocus& operator=(const VideoFocus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFocus& operator=(VideoFocus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoFocus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoFocus* internal_default_instance() {
    return reinterpret_cast<const VideoFocus*>(
               &_VideoFocus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(VideoFocus& a, VideoFocus& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFocus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFocus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoFocus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoFocus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VideoFocus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VideoFocus& from) {
    VideoFocus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VideoFocus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.VideoFocus";
  }
  protected:
  explicit VideoFocus(::google::protobuf::Arena* arena);
  VideoFocus(::google::protobuf::Arena* arena, const VideoFocus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnrequestedFieldNumber = 2,
    kModeFieldNumber = 1,
  };
  // optional bool unrequested = 2;
  bool has_unrequested() const;
  void clear_unrequested() ;
  bool unrequested() const;
  void set_unrequested(bool value);

  private:
  bool _internal_unrequested() const;
  void _internal_set_unrequested(bool value);

  public:
  // optional .HU.VIDEO_FOCUS_MODE mode = 1;
  bool has_mode() const;
  void clear_mode() ;
  ::HU::VIDEO_FOCUS_MODE mode() const;
  void set_mode(::HU::VIDEO_FOCUS_MODE value);

  private:
  ::HU::VIDEO_FOCUS_MODE _internal_mode() const;
  void _internal_set_mode(::HU::VIDEO_FOCUS_MODE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.VideoFocus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool unrequested_;
    int mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class TouchInfo_Location final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.TouchInfo.Location) */ {
 public:
  inline TouchInfo_Location() : TouchInfo_Location(nullptr) {}
  ~TouchInfo_Location() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TouchInfo_Location(::google::protobuf::internal::ConstantInitialized);

  inline TouchInfo_Location(const TouchInfo_Location& from)
      : TouchInfo_Location(nullptr, from) {}
  TouchInfo_Location(TouchInfo_Location&& from) noexcept
    : TouchInfo_Location() {
    *this = ::std::move(from);
  }

  inline TouchInfo_Location& operator=(const TouchInfo_Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchInfo_Location& operator=(TouchInfo_Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TouchInfo_Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const TouchInfo_Location* internal_default_instance() {
    return reinterpret_cast<const TouchInfo_Location*>(
               &_TouchInfo_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TouchInfo_Location& a, TouchInfo_Location& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchInfo_Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchInfo_Location* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TouchInfo_Location* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TouchInfo_Location>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TouchInfo_Location& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TouchInfo_Location& from) {
    TouchInfo_Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TouchInfo_Location* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.TouchInfo.Location";
  }
  protected:
  explicit TouchInfo_Location(::google::protobuf::Arena* arena);
  TouchInfo_Location(::google::protobuf::Arena* arena, const TouchInfo_Location& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kPointerIdFieldNumber = 3,
  };
  // required uint32 x = 1;
  bool has_x() const;
  void clear_x() ;
  ::uint32_t x() const;
  void set_x(::uint32_t value);

  private:
  ::uint32_t _internal_x() const;
  void _internal_set_x(::uint32_t value);

  public:
  // required uint32 y = 2;
  bool has_y() const;
  void clear_y() ;
  ::uint32_t y() const;
  void set_y(::uint32_t value);

  private:
  ::uint32_t _internal_y() const;
  void _internal_set_y(::uint32_t value);

  public:
  // required uint32 pointer_id = 3;
  bool has_pointer_id() const;
  void clear_pointer_id() ;
  ::uint32_t pointer_id() const;
  void set_pointer_id(::uint32_t value);

  private:
  ::uint32_t _internal_pointer_id() const;
  void _internal_set_pointer_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.TouchInfo.Location)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t x_;
    ::uint32_t y_;
    ::uint32_t pointer_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class StopGenericNotifications final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:HU.StopGenericNotifications) */ {
 public:
  inline StopGenericNotifications() : StopGenericNotifications(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopGenericNotifications(::google::protobuf::internal::ConstantInitialized);

  inline StopGenericNotifications(const StopGenericNotifications& from)
      : StopGenericNotifications(nullptr, from) {}
  StopGenericNotifications(StopGenericNotifications&& from) noexcept
    : StopGenericNotifications() {
    *this = ::std::move(from);
  }

  inline StopGenericNotifications& operator=(const StopGenericNotifications& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopGenericNotifications& operator=(StopGenericNotifications&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopGenericNotifications& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopGenericNotifications* internal_default_instance() {
    return reinterpret_cast<const StopGenericNotifications*>(
               &_StopGenericNotifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(StopGenericNotifications& a, StopGenericNotifications& b) {
    a.Swap(&b);
  }
  inline void Swap(StopGenericNotifications* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopGenericNotifications* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopGenericNotifications* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopGenericNotifications>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopGenericNotifications& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopGenericNotifications& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.StopGenericNotifications";
  }
  protected:
  explicit StopGenericNotifications(::google::protobuf::Arena* arena);
  StopGenericNotifications(::google::protobuf::Arena* arena, const StopGenericNotifications& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.StopGenericNotifications)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class StartGenericNotifications final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:HU.StartGenericNotifications) */ {
 public:
  inline StartGenericNotifications() : StartGenericNotifications(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartGenericNotifications(::google::protobuf::internal::ConstantInitialized);

  inline StartGenericNotifications(const StartGenericNotifications& from)
      : StartGenericNotifications(nullptr, from) {}
  StartGenericNotifications(StartGenericNotifications&& from) noexcept
    : StartGenericNotifications() {
    *this = ::std::move(from);
  }

  inline StartGenericNotifications& operator=(const StartGenericNotifications& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGenericNotifications& operator=(StartGenericNotifications&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartGenericNotifications& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartGenericNotifications* internal_default_instance() {
    return reinterpret_cast<const StartGenericNotifications*>(
               &_StartGenericNotifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(StartGenericNotifications& a, StartGenericNotifications& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGenericNotifications* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGenericNotifications* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartGenericNotifications* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartGenericNotifications>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartGenericNotifications& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartGenericNotifications& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.StartGenericNotifications";
  }
  protected:
  explicit StartGenericNotifications(::google::protobuf::Arena* arena);
  StartGenericNotifications(::google::protobuf::Arena* arena, const StartGenericNotifications& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.StartGenericNotifications)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ShutdownResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:HU.ShutdownResponse) */ {
 public:
  inline ShutdownResponse() : ShutdownResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShutdownResponse(::google::protobuf::internal::ConstantInitialized);

  inline ShutdownResponse(const ShutdownResponse& from)
      : ShutdownResponse(nullptr, from) {}
  ShutdownResponse(ShutdownResponse&& from) noexcept
    : ShutdownResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownResponse& operator=(const ShutdownResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownResponse& operator=(ShutdownResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownResponse*>(
               &_ShutdownResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ShutdownResponse& a, ShutdownResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShutdownResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShutdownResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ShutdownResponse";
  }
  protected:
  explicit ShutdownResponse(::google::protobuf::Arena* arena);
  ShutdownResponse(::google::protobuf::Arena* arena, const ShutdownResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.ShutdownResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ShutdownRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ShutdownRequest) */ {
 public:
  inline ShutdownRequest() : ShutdownRequest(nullptr) {}
  ~ShutdownRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShutdownRequest(::google::protobuf::internal::ConstantInitialized);

  inline ShutdownRequest(const ShutdownRequest& from)
      : ShutdownRequest(nullptr, from) {}
  ShutdownRequest(ShutdownRequest&& from) noexcept
    : ShutdownRequest() {
    *this = ::std::move(from);
  }

  inline ShutdownRequest& operator=(const ShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownRequest& operator=(ShutdownRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownRequest*>(
               &_ShutdownRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ShutdownRequest& a, ShutdownRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShutdownRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShutdownRequest& from) {
    ShutdownRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShutdownRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ShutdownRequest";
  }
  protected:
  explicit ShutdownRequest(::google::protobuf::Arena* arena);
  ShutdownRequest(::google::protobuf::Arena* arena, const ShutdownRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using REASON = ShutdownRequest_REASON;
  static constexpr REASON REASON_QUIT = ShutdownRequest_REASON_REASON_QUIT;
  static inline bool REASON_IsValid(int value) {
    return ShutdownRequest_REASON_IsValid(value);
  }
  static constexpr REASON REASON_MIN = ShutdownRequest_REASON_REASON_MIN;
  static constexpr REASON REASON_MAX = ShutdownRequest_REASON_REASON_MAX;
  static constexpr int REASON_ARRAYSIZE = ShutdownRequest_REASON_REASON_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* REASON_descriptor() {
    return ShutdownRequest_REASON_descriptor();
  }
  template <typename T>
  static inline const std::string& REASON_Name(T value) {
    return ShutdownRequest_REASON_Name(value);
  }
  static inline bool REASON_Parse(absl::string_view name, REASON* value) {
    return ShutdownRequest_REASON_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // optional .HU.ShutdownRequest.REASON reason = 1;
  bool has_reason() const;
  void clear_reason() ;
  ::HU::ShutdownRequest_REASON reason() const;
  void set_reason(::HU::ShutdownRequest_REASON value);

  private:
  ::HU::ShutdownRequest_REASON _internal_reason() const;
  void _internal_set_reason(::HU::ShutdownRequest_REASON value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ShutdownRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int reason_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ServiceDiscoveryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ServiceDiscoveryRequest) */ {
 public:
  inline ServiceDiscoveryRequest() : ServiceDiscoveryRequest(nullptr) {}
  ~ServiceDiscoveryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceDiscoveryRequest(::google::protobuf::internal::ConstantInitialized);

  inline ServiceDiscoveryRequest(const ServiceDiscoveryRequest& from)
      : ServiceDiscoveryRequest(nullptr, from) {}
  ServiceDiscoveryRequest(ServiceDiscoveryRequest&& from) noexcept
    : ServiceDiscoveryRequest() {
    *this = ::std::move(from);
  }

  inline ServiceDiscoveryRequest& operator=(const ServiceDiscoveryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceDiscoveryRequest& operator=(ServiceDiscoveryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceDiscoveryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceDiscoveryRequest* internal_default_instance() {
    return reinterpret_cast<const ServiceDiscoveryRequest*>(
               &_ServiceDiscoveryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ServiceDiscoveryRequest& a, ServiceDiscoveryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceDiscoveryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceDiscoveryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceDiscoveryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceDiscoveryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServiceDiscoveryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ServiceDiscoveryRequest& from) {
    ServiceDiscoveryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServiceDiscoveryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ServiceDiscoveryRequest";
  }
  protected:
  explicit ServiceDiscoveryRequest(::google::protobuf::Arena* arena);
  ServiceDiscoveryRequest(::google::protobuf::Arena* arena, const ServiceDiscoveryRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneNameFieldNumber = 4,
  };
  // optional string phone_name = 4;
  bool has_phone_name() const;
  void clear_phone_name() ;
  const std::string& phone_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_name(Arg_&& arg, Args_... args);
  std::string* mutable_phone_name();
  PROTOBUF_NODISCARD std::string* release_phone_name();
  void set_allocated_phone_name(std::string* value);

  private:
  const std::string& _internal_phone_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_name(
      const std::string& value);
  std::string* _internal_mutable_phone_name();

  public:
  // @@protoc_insertion_point(class_scope:HU.ServiceDiscoveryRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phone_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorStartResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorStartResponse) */ {
 public:
  inline SensorStartResponse() : SensorStartResponse(nullptr) {}
  ~SensorStartResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorStartResponse(::google::protobuf::internal::ConstantInitialized);

  inline SensorStartResponse(const SensorStartResponse& from)
      : SensorStartResponse(nullptr, from) {}
  SensorStartResponse(SensorStartResponse&& from) noexcept
    : SensorStartResponse() {
    *this = ::std::move(from);
  }

  inline SensorStartResponse& operator=(const SensorStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStartResponse& operator=(SensorStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStartResponse* internal_default_instance() {
    return reinterpret_cast<const SensorStartResponse*>(
               &_SensorStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SensorStartResponse& a, SensorStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStartResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorStartResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorStartResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorStartResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorStartResponse& from) {
    SensorStartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorStartResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorStartResponse";
  }
  protected:
  explicit SensorStartResponse(::google::protobuf::Arena* arena);
  SensorStartResponse(::google::protobuf::Arena* arena, const SensorStartResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  void clear_status() ;
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);

  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorStartResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorStartRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorStartRequest) */ {
 public:
  inline SensorStartRequest() : SensorStartRequest(nullptr) {}
  ~SensorStartRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorStartRequest(::google::protobuf::internal::ConstantInitialized);

  inline SensorStartRequest(const SensorStartRequest& from)
      : SensorStartRequest(nullptr, from) {}
  SensorStartRequest(SensorStartRequest&& from) noexcept
    : SensorStartRequest() {
    *this = ::std::move(from);
  }

  inline SensorStartRequest& operator=(const SensorStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStartRequest& operator=(SensorStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStartRequest* internal_default_instance() {
    return reinterpret_cast<const SensorStartRequest*>(
               &_SensorStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(SensorStartRequest& a, SensorStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStartRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorStartRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorStartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorStartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorStartRequest& from) {
    SensorStartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorStartRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorStartRequest";
  }
  protected:
  explicit SensorStartRequest(::google::protobuf::Arena* arena);
  SensorStartRequest(::google::protobuf::Arena* arena, const SensorStartRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshIntervalFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional int64 refresh_interval = 2;
  bool has_refresh_interval() const;
  void clear_refresh_interval() ;
  ::int64_t refresh_interval() const;
  void set_refresh_interval(::int64_t value);

  private:
  ::int64_t _internal_refresh_interval() const;
  void _internal_set_refresh_interval(::int64_t value);

  public:
  // required .HU.SENSOR_TYPE type = 1;
  bool has_type() const;
  void clear_type() ;
  ::HU::SENSOR_TYPE type() const;
  void set_type(::HU::SENSOR_TYPE value);

  private:
  ::HU::SENSOR_TYPE _internal_type() const;
  void _internal_set_type(::HU::SENSOR_TYPE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorStartRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t refresh_interval_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_SpeedData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.SpeedData) */ {
 public:
  inline SensorEvent_SpeedData() : SensorEvent_SpeedData(nullptr) {}
  ~SensorEvent_SpeedData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_SpeedData(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_SpeedData(const SensorEvent_SpeedData& from)
      : SensorEvent_SpeedData(nullptr, from) {}
  SensorEvent_SpeedData(SensorEvent_SpeedData&& from) noexcept
    : SensorEvent_SpeedData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_SpeedData& operator=(const SensorEvent_SpeedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_SpeedData& operator=(SensorEvent_SpeedData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_SpeedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_SpeedData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_SpeedData*>(
               &_SensorEvent_SpeedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SensorEvent_SpeedData& a, SensorEvent_SpeedData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_SpeedData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_SpeedData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_SpeedData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_SpeedData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_SpeedData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_SpeedData& from) {
    SensorEvent_SpeedData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_SpeedData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.SpeedData";
  }
  protected:
  explicit SensorEvent_SpeedData(::google::protobuf::Arena* arena);
  SensorEvent_SpeedData(::google::protobuf::Arena* arena, const SensorEvent_SpeedData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedE6FieldNumber = 1,
    kCruiseEngagedFieldNumber = 2,
    kCruiseSetSpeedFieldNumber = 3,
  };
  // optional int32 speed_e6 = 1;
  bool has_speed_e6() const;
  void clear_speed_e6() ;
  ::int32_t speed_e6() const;
  void set_speed_e6(::int32_t value);

  private:
  ::int32_t _internal_speed_e6() const;
  void _internal_set_speed_e6(::int32_t value);

  public:
  // optional bool cruise_engaged = 2;
  bool has_cruise_engaged() const;
  void clear_cruise_engaged() ;
  bool cruise_engaged() const;
  void set_cruise_engaged(bool value);

  private:
  bool _internal_cruise_engaged() const;
  void _internal_set_cruise_engaged(bool value);

  public:
  // optional bool cruise_set_speed = 3;
  bool has_cruise_set_speed() const;
  void clear_cruise_set_speed() ;
  bool cruise_set_speed() const;
  void set_cruise_set_speed(bool value);

  private:
  bool _internal_cruise_set_speed() const;
  void _internal_set_cruise_set_speed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.SpeedData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t speed_e6_;
    bool cruise_engaged_;
    bool cruise_set_speed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_RPM final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.RPM) */ {
 public:
  inline SensorEvent_RPM() : SensorEvent_RPM(nullptr) {}
  ~SensorEvent_RPM() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_RPM(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_RPM(const SensorEvent_RPM& from)
      : SensorEvent_RPM(nullptr, from) {}
  SensorEvent_RPM(SensorEvent_RPM&& from) noexcept
    : SensorEvent_RPM() {
    *this = ::std::move(from);
  }

  inline SensorEvent_RPM& operator=(const SensorEvent_RPM& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_RPM& operator=(SensorEvent_RPM&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_RPM& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_RPM* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_RPM*>(
               &_SensorEvent_RPM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SensorEvent_RPM& a, SensorEvent_RPM& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_RPM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_RPM* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_RPM* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_RPM>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_RPM& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_RPM& from) {
    SensorEvent_RPM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_RPM* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.RPM";
  }
  protected:
  explicit SensorEvent_RPM(::google::protobuf::Arena* arena);
  SensorEvent_RPM(::google::protobuf::Arena* arena, const SensorEvent_RPM& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpmFieldNumber = 1,
  };
  // required int32 rpm = 1;
  bool has_rpm() const;
  void clear_rpm() ;
  ::int32_t rpm() const;
  void set_rpm(::int32_t value);

  private:
  ::int32_t _internal_rpm() const;
  void _internal_set_rpm(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.RPM)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t rpm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Passenger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Passenger) */ {
 public:
  inline SensorEvent_Passenger() : SensorEvent_Passenger(nullptr) {}
  ~SensorEvent_Passenger() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Passenger(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Passenger(const SensorEvent_Passenger& from)
      : SensorEvent_Passenger(nullptr, from) {}
  SensorEvent_Passenger(SensorEvent_Passenger&& from) noexcept
    : SensorEvent_Passenger() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Passenger& operator=(const SensorEvent_Passenger& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Passenger& operator=(SensorEvent_Passenger&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Passenger& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Passenger* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Passenger*>(
               &_SensorEvent_Passenger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SensorEvent_Passenger& a, SensorEvent_Passenger& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Passenger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Passenger* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Passenger* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Passenger>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Passenger& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Passenger& from) {
    SensorEvent_Passenger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Passenger* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Passenger";
  }
  protected:
  explicit SensorEvent_Passenger(::google::protobuf::Arena* arena);
  SensorEvent_Passenger(::google::protobuf::Arena* arena, const SensorEvent_Passenger& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassengerPresentFieldNumber = 1,
  };
  // optional bool passenger_present = 1;
  bool has_passenger_present() const;
  void clear_passenger_present() ;
  bool passenger_present() const;
  void set_passenger_present(bool value);

  private:
  bool _internal_passenger_present() const;
  void _internal_set_passenger_present(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Passenger)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool passenger_present_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_ParkingBreak final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.ParkingBreak) */ {
 public:
  inline SensorEvent_ParkingBreak() : SensorEvent_ParkingBreak(nullptr) {}
  ~SensorEvent_ParkingBreak() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_ParkingBreak(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_ParkingBreak(const SensorEvent_ParkingBreak& from)
      : SensorEvent_ParkingBreak(nullptr, from) {}
  SensorEvent_ParkingBreak(SensorEvent_ParkingBreak&& from) noexcept
    : SensorEvent_ParkingBreak() {
    *this = ::std::move(from);
  }

  inline SensorEvent_ParkingBreak& operator=(const SensorEvent_ParkingBreak& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_ParkingBreak& operator=(SensorEvent_ParkingBreak&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_ParkingBreak& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_ParkingBreak* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_ParkingBreak*>(
               &_SensorEvent_ParkingBreak_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SensorEvent_ParkingBreak& a, SensorEvent_ParkingBreak& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_ParkingBreak* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_ParkingBreak* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_ParkingBreak* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_ParkingBreak>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_ParkingBreak& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_ParkingBreak& from) {
    SensorEvent_ParkingBreak::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_ParkingBreak* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.ParkingBreak";
  }
  protected:
  explicit SensorEvent_ParkingBreak(::google::protobuf::Arena* arena);
  SensorEvent_ParkingBreak(::google::protobuf::Arena* arena, const SensorEvent_ParkingBreak& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingBreakeFieldNumber = 1,
  };
  // optional bool parking_breake = 1;
  bool has_parking_breake() const;
  void clear_parking_breake() ;
  bool parking_breake() const;
  void set_parking_breake(bool value);

  private:
  bool _internal_parking_breake() const;
  void _internal_set_parking_breake(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.ParkingBreak)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool parking_breake_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_OdometerData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.OdometerData) */ {
 public:
  inline SensorEvent_OdometerData() : SensorEvent_OdometerData(nullptr) {}
  ~SensorEvent_OdometerData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_OdometerData(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_OdometerData(const SensorEvent_OdometerData& from)
      : SensorEvent_OdometerData(nullptr, from) {}
  SensorEvent_OdometerData(SensorEvent_OdometerData&& from) noexcept
    : SensorEvent_OdometerData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_OdometerData& operator=(const SensorEvent_OdometerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_OdometerData& operator=(SensorEvent_OdometerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_OdometerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_OdometerData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_OdometerData*>(
               &_SensorEvent_OdometerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SensorEvent_OdometerData& a, SensorEvent_OdometerData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_OdometerData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_OdometerData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_OdometerData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_OdometerData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_OdometerData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_OdometerData& from) {
    SensorEvent_OdometerData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_OdometerData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.OdometerData";
  }
  protected:
  explicit SensorEvent_OdometerData(::google::protobuf::Arena* arena);
  SensorEvent_OdometerData(::google::protobuf::Arena* arena, const SensorEvent_OdometerData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKmsElFieldNumber = 1,
    kTripKmsElFieldNumber = 2,
  };
  // optional int32 kms_el = 1;
  bool has_kms_el() const;
  void clear_kms_el() ;
  ::int32_t kms_el() const;
  void set_kms_el(::int32_t value);

  private:
  ::int32_t _internal_kms_el() const;
  void _internal_set_kms_el(::int32_t value);

  public:
  // optional int32 trip_kms_el = 2;
  bool has_trip_kms_el() const;
  void clear_trip_kms_el() ;
  ::int32_t trip_kms_el() const;
  void set_trip_kms_el(::int32_t value);

  private:
  ::int32_t _internal_trip_kms_el() const;
  void _internal_set_trip_kms_el(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.OdometerData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t kms_el_;
    ::int32_t trip_kms_el_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_NightMode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.NightMode) */ {
 public:
  inline SensorEvent_NightMode() : SensorEvent_NightMode(nullptr) {}
  ~SensorEvent_NightMode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_NightMode(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_NightMode(const SensorEvent_NightMode& from)
      : SensorEvent_NightMode(nullptr, from) {}
  SensorEvent_NightMode(SensorEvent_NightMode&& from) noexcept
    : SensorEvent_NightMode() {
    *this = ::std::move(from);
  }

  inline SensorEvent_NightMode& operator=(const SensorEvent_NightMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_NightMode& operator=(SensorEvent_NightMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_NightMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_NightMode* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_NightMode*>(
               &_SensorEvent_NightMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SensorEvent_NightMode& a, SensorEvent_NightMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_NightMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_NightMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_NightMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_NightMode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_NightMode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_NightMode& from) {
    SensorEvent_NightMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_NightMode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.NightMode";
  }
  protected:
  explicit SensorEvent_NightMode(::google::protobuf::Arena* arena);
  SensorEvent_NightMode(::google::protobuf::Arena* arena, const SensorEvent_NightMode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsNightFieldNumber = 1,
  };
  // required bool is_night = 1;
  bool has_is_night() const;
  void clear_is_night() ;
  bool is_night() const;
  void set_is_night(bool value);

  private:
  bool _internal_is_night() const;
  void _internal_set_is_night(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.NightMode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool is_night_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_LocationData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.LocationData) */ {
 public:
  inline SensorEvent_LocationData() : SensorEvent_LocationData(nullptr) {}
  ~SensorEvent_LocationData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_LocationData(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_LocationData(const SensorEvent_LocationData& from)
      : SensorEvent_LocationData(nullptr, from) {}
  SensorEvent_LocationData(SensorEvent_LocationData&& from) noexcept
    : SensorEvent_LocationData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_LocationData& operator=(const SensorEvent_LocationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_LocationData& operator=(SensorEvent_LocationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_LocationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_LocationData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_LocationData*>(
               &_SensorEvent_LocationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SensorEvent_LocationData& a, SensorEvent_LocationData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_LocationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_LocationData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_LocationData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_LocationData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_LocationData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_LocationData& from) {
    SensorEvent_LocationData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_LocationData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.LocationData";
  }
  protected:
  explicit SensorEvent_LocationData(::google::protobuf::Arena* arena);
  SensorEvent_LocationData(::google::protobuf::Arena* arena, const SensorEvent_LocationData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kLongitudeFieldNumber = 3,
    kAccuracyFieldNumber = 4,
    kAltitudeFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kBearingFieldNumber = 7,
  };
  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional int32 latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  ::int32_t latitude() const;
  void set_latitude(::int32_t value);

  private:
  ::int32_t _internal_latitude() const;
  void _internal_set_latitude(::int32_t value);

  public:
  // optional int32 longitude = 3;
  bool has_longitude() const;
  void clear_longitude() ;
  ::int32_t longitude() const;
  void set_longitude(::int32_t value);

  private:
  ::int32_t _internal_longitude() const;
  void _internal_set_longitude(::int32_t value);

  public:
  // optional uint32 accuracy = 4;
  bool has_accuracy() const;
  void clear_accuracy() ;
  ::uint32_t accuracy() const;
  void set_accuracy(::uint32_t value);

  private:
  ::uint32_t _internal_accuracy() const;
  void _internal_set_accuracy(::uint32_t value);

  public:
  // optional int32 altitude = 5;
  bool has_altitude() const;
  void clear_altitude() ;
  ::int32_t altitude() const;
  void set_altitude(::int32_t value);

  private:
  ::int32_t _internal_altitude() const;
  void _internal_set_altitude(::int32_t value);

  public:
  // optional int32 speed = 6;
  bool has_speed() const;
  void clear_speed() ;
  ::int32_t speed() const;
  void set_speed(::int32_t value);

  private:
  ::int32_t _internal_speed() const;
  void _internal_set_speed(::int32_t value);

  public:
  // optional int32 bearing = 7;
  bool has_bearing() const;
  void clear_bearing() ;
  ::int32_t bearing() const;
  void set_bearing(::int32_t value);

  private:
  ::int32_t _internal_bearing() const;
  void _internal_set_bearing(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.LocationData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t timestamp_;
    ::int32_t latitude_;
    ::int32_t longitude_;
    ::uint32_t accuracy_;
    ::int32_t altitude_;
    ::int32_t speed_;
    ::int32_t bearing_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Light final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Light) */ {
 public:
  inline SensorEvent_Light() : SensorEvent_Light(nullptr) {}
  ~SensorEvent_Light() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Light(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Light(const SensorEvent_Light& from)
      : SensorEvent_Light(nullptr, from) {}
  SensorEvent_Light(SensorEvent_Light&& from) noexcept
    : SensorEvent_Light() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Light& operator=(const SensorEvent_Light& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Light& operator=(SensorEvent_Light&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Light& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Light* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Light*>(
               &_SensorEvent_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SensorEvent_Light& a, SensorEvent_Light& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Light* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Light* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Light* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Light>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Light& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Light& from) {
    SensorEvent_Light::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Light* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Light";
  }
  protected:
  explicit SensorEvent_Light(::google::protobuf::Arena* arena);
  SensorEvent_Light(::google::protobuf::Arena* arena, const SensorEvent_Light& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using HEADLIGHT_STATE = SensorEvent_Light_HEADLIGHT_STATE;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_0 = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_0;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_1 = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_1;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_2 = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_2;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_3 = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_3;
  static inline bool HEADLIGHT_STATE_IsValid(int value) {
    return SensorEvent_Light_HEADLIGHT_STATE_IsValid(value);
  }
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_MIN = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MIN;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_MAX = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MAX;
  static constexpr int HEADLIGHT_STATE_ARRAYSIZE = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* HEADLIGHT_STATE_descriptor() {
    return SensorEvent_Light_HEADLIGHT_STATE_descriptor();
  }
  template <typename T>
  static inline const std::string& HEADLIGHT_STATE_Name(T value) {
    return SensorEvent_Light_HEADLIGHT_STATE_Name(value);
  }
  static inline bool HEADLIGHT_STATE_Parse(absl::string_view name, HEADLIGHT_STATE* value) {
    return SensorEvent_Light_HEADLIGHT_STATE_Parse(name, value);
  }

  using TURN_INDICATOR_STATE = SensorEvent_Light_TURN_INDICATOR_STATE;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_0 = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_0;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_1 = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_1;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_2 = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_2;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_3 = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_3;
  static inline bool TURN_INDICATOR_STATE_IsValid(int value) {
    return SensorEvent_Light_TURN_INDICATOR_STATE_IsValid(value);
  }
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_MIN = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MIN;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_MAX = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MAX;
  static constexpr int TURN_INDICATOR_STATE_ARRAYSIZE = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TURN_INDICATOR_STATE_descriptor() {
    return SensorEvent_Light_TURN_INDICATOR_STATE_descriptor();
  }
  template <typename T>
  static inline const std::string& TURN_INDICATOR_STATE_Name(T value) {
    return SensorEvent_Light_TURN_INDICATOR_STATE_Name(value);
  }
  static inline bool TURN_INDICATOR_STATE_Parse(absl::string_view name, TURN_INDICATOR_STATE* value) {
    return SensorEvent_Light_TURN_INDICATOR_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadlightFieldNumber = 1,
    kTurnIndicatorFieldNumber = 2,
    kHazardLightOnFieldNumber = 3,
  };
  // optional .HU.SensorEvent.Light.HEADLIGHT_STATE headlight = 1;
  bool has_headlight() const;
  void clear_headlight() ;
  ::HU::SensorEvent_Light_HEADLIGHT_STATE headlight() const;
  void set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value);

  private:
  ::HU::SensorEvent_Light_HEADLIGHT_STATE _internal_headlight() const;
  void _internal_set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value);

  public:
  // optional .HU.SensorEvent.Light.TURN_INDICATOR_STATE turn_indicator = 2;
  bool has_turn_indicator() const;
  void clear_turn_indicator() ;
  ::HU::SensorEvent_Light_TURN_INDICATOR_STATE turn_indicator() const;
  void set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value);

  private:
  ::HU::SensorEvent_Light_TURN_INDICATOR_STATE _internal_turn_indicator() const;
  void _internal_set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value);

  public:
  // optional bool hazard_light_on = 3;
  bool has_hazard_light_on() const;
  void clear_hazard_light_on() ;
  bool hazard_light_on() const;
  void set_hazard_light_on(bool value);

  private:
  bool _internal_hazard_light_on() const;
  void _internal_set_hazard_light_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Light)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int headlight_;
    int turn_indicator_;
    bool hazard_light_on_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_HVAC final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.HVAC) */ {
 public:
  inline SensorEvent_HVAC() : SensorEvent_HVAC(nullptr) {}
  ~SensorEvent_HVAC() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_HVAC(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_HVAC(const SensorEvent_HVAC& from)
      : SensorEvent_HVAC(nullptr, from) {}
  SensorEvent_HVAC(SensorEvent_HVAC&& from) noexcept
    : SensorEvent_HVAC() {
    *this = ::std::move(from);
  }

  inline SensorEvent_HVAC& operator=(const SensorEvent_HVAC& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_HVAC& operator=(SensorEvent_HVAC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_HVAC& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_HVAC* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_HVAC*>(
               &_SensorEvent_HVAC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SensorEvent_HVAC& a, SensorEvent_HVAC& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_HVAC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_HVAC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_HVAC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_HVAC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_HVAC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_HVAC& from) {
    SensorEvent_HVAC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_HVAC* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.HVAC";
  }
  protected:
  explicit SensorEvent_HVAC(::google::protobuf::Arena* arena);
  SensorEvent_HVAC(::google::protobuf::Arena* arena, const SensorEvent_HVAC& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTemperatureE3FieldNumber = 1,
    kCurrentTemperatureE3FieldNumber = 2,
  };
  // optional int32 target_temperature_e3 = 1;
  bool has_target_temperature_e3() const;
  void clear_target_temperature_e3() ;
  ::int32_t target_temperature_e3() const;
  void set_target_temperature_e3(::int32_t value);

  private:
  ::int32_t _internal_target_temperature_e3() const;
  void _internal_set_target_temperature_e3(::int32_t value);

  public:
  // optional int32 current_temperature_e3 = 2;
  bool has_current_temperature_e3() const;
  void clear_current_temperature_e3() ;
  ::int32_t current_temperature_e3() const;
  void set_current_temperature_e3(::int32_t value);

  private:
  ::int32_t _internal_current_temperature_e3() const;
  void _internal_set_current_temperature_e3(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.HVAC)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t target_temperature_e3_;
    ::int32_t current_temperature_e3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Gyro final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Gyro) */ {
 public:
  inline SensorEvent_Gyro() : SensorEvent_Gyro(nullptr) {}
  ~SensorEvent_Gyro() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Gyro(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Gyro(const SensorEvent_Gyro& from)
      : SensorEvent_Gyro(nullptr, from) {}
  SensorEvent_Gyro(SensorEvent_Gyro&& from) noexcept
    : SensorEvent_Gyro() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Gyro& operator=(const SensorEvent_Gyro& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Gyro& operator=(SensorEvent_Gyro&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Gyro& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Gyro* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Gyro*>(
               &_SensorEvent_Gyro_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SensorEvent_Gyro& a, SensorEvent_Gyro& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Gyro* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Gyro* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Gyro* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Gyro>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Gyro& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Gyro& from) {
    SensorEvent_Gyro::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Gyro* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Gyro";
  }
  protected:
  explicit SensorEvent_Gyro(::google::protobuf::Arena* arena);
  SensorEvent_Gyro(::google::protobuf::Arena* arena, const SensorEvent_Gyro& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotationSpeedXE3FieldNumber = 1,
    kRotationSpeedYE3FieldNumber = 2,
    kRotationSpeedZE3FieldNumber = 3,
  };
  // optional int32 rotation_speed_x_e3 = 1;
  bool has_rotation_speed_x_e3() const;
  void clear_rotation_speed_x_e3() ;
  ::int32_t rotation_speed_x_e3() const;
  void set_rotation_speed_x_e3(::int32_t value);

  private:
  ::int32_t _internal_rotation_speed_x_e3() const;
  void _internal_set_rotation_speed_x_e3(::int32_t value);

  public:
  // optional int32 rotation_speed_y_e3 = 2;
  bool has_rotation_speed_y_e3() const;
  void clear_rotation_speed_y_e3() ;
  ::int32_t rotation_speed_y_e3() const;
  void set_rotation_speed_y_e3(::int32_t value);

  private:
  ::int32_t _internal_rotation_speed_y_e3() const;
  void _internal_set_rotation_speed_y_e3(::int32_t value);

  public:
  // optional int32 rotation_speed_z_e3 = 3;
  bool has_rotation_speed_z_e3() const;
  void clear_rotation_speed_z_e3() ;
  ::int32_t rotation_speed_z_e3() const;
  void set_rotation_speed_z_e3(::int32_t value);

  private:
  ::int32_t _internal_rotation_speed_z_e3() const;
  void _internal_set_rotation_speed_z_e3(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Gyro)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t rotation_speed_x_e3_;
    ::int32_t rotation_speed_y_e3_;
    ::int32_t rotation_speed_z_e3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_GearData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.GearData) */ {
 public:
  inline SensorEvent_GearData() : SensorEvent_GearData(nullptr) {}
  ~SensorEvent_GearData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_GearData(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_GearData(const SensorEvent_GearData& from)
      : SensorEvent_GearData(nullptr, from) {}
  SensorEvent_GearData(SensorEvent_GearData&& from) noexcept
    : SensorEvent_GearData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_GearData& operator=(const SensorEvent_GearData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_GearData& operator=(SensorEvent_GearData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_GearData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_GearData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_GearData*>(
               &_SensorEvent_GearData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SensorEvent_GearData& a, SensorEvent_GearData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_GearData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_GearData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_GearData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_GearData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_GearData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_GearData& from) {
    SensorEvent_GearData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_GearData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.GearData";
  }
  protected:
  explicit SensorEvent_GearData(::google::protobuf::Arena* arena);
  SensorEvent_GearData(::google::protobuf::Arena* arena, const SensorEvent_GearData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using GEAR = SensorEvent_GearData_GEAR;
  static constexpr GEAR GEAR_DRIVE = SensorEvent_GearData_GEAR_GEAR_DRIVE;
  static constexpr GEAR GEAR_EIGHTH = SensorEvent_GearData_GEAR_GEAR_EIGHTH;
  static constexpr GEAR GEAR_FIFTH = SensorEvent_GearData_GEAR_GEAR_FIFTH;
  static constexpr GEAR GEAR_FIRST = SensorEvent_GearData_GEAR_GEAR_FIRST;
  static constexpr GEAR GEAR_FOURTH = SensorEvent_GearData_GEAR_GEAR_FOURTH;
  static constexpr GEAR GEAR_NEUTRAL = SensorEvent_GearData_GEAR_GEAR_NEUTRAL;
  static constexpr GEAR GEAR_NINTH = SensorEvent_GearData_GEAR_GEAR_NINTH;
  static constexpr GEAR GEAR_PARK = SensorEvent_GearData_GEAR_GEAR_PARK;
  static constexpr GEAR GEAR_REVERSE = SensorEvent_GearData_GEAR_GEAR_REVERSE;
  static constexpr GEAR GEAR_SECOND = SensorEvent_GearData_GEAR_GEAR_SECOND;
  static constexpr GEAR GEAR_SEVENTH = SensorEvent_GearData_GEAR_GEAR_SEVENTH;
  static constexpr GEAR GEAR_SIXTH = SensorEvent_GearData_GEAR_GEAR_SIXTH;
  static constexpr GEAR GEAR_TENTH = SensorEvent_GearData_GEAR_GEAR_TENTH;
  static constexpr GEAR GEAR_THIRD = SensorEvent_GearData_GEAR_GEAR_THIRD;
  static inline bool GEAR_IsValid(int value) {
    return SensorEvent_GearData_GEAR_IsValid(value);
  }
  static constexpr GEAR GEAR_MIN = SensorEvent_GearData_GEAR_GEAR_MIN;
  static constexpr GEAR GEAR_MAX = SensorEvent_GearData_GEAR_GEAR_MAX;
  static constexpr int GEAR_ARRAYSIZE = SensorEvent_GearData_GEAR_GEAR_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GEAR_descriptor() {
    return SensorEvent_GearData_GEAR_descriptor();
  }
  template <typename T>
  static inline const std::string& GEAR_Name(T value) {
    return SensorEvent_GearData_GEAR_Name(value);
  }
  static inline bool GEAR_Parse(absl::string_view name, GEAR* value) {
    return SensorEvent_GearData_GEAR_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGearFieldNumber = 1,
  };
  // required .HU.SensorEvent.GearData.GEAR gear = 1;
  bool has_gear() const;
  void clear_gear() ;
  ::HU::SensorEvent_GearData_GEAR gear() const;
  void set_gear(::HU::SensorEvent_GearData_GEAR value);

  private:
  ::HU::SensorEvent_GearData_GEAR _internal_gear() const;
  void _internal_set_gear(::HU::SensorEvent_GearData_GEAR value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.GearData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int gear_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_FuelLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.FuelLevel) */ {
 public:
  inline SensorEvent_FuelLevel() : SensorEvent_FuelLevel(nullptr) {}
  ~SensorEvent_FuelLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_FuelLevel(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_FuelLevel(const SensorEvent_FuelLevel& from)
      : SensorEvent_FuelLevel(nullptr, from) {}
  SensorEvent_FuelLevel(SensorEvent_FuelLevel&& from) noexcept
    : SensorEvent_FuelLevel() {
    *this = ::std::move(from);
  }

  inline SensorEvent_FuelLevel& operator=(const SensorEvent_FuelLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_FuelLevel& operator=(SensorEvent_FuelLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_FuelLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_FuelLevel* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_FuelLevel*>(
               &_SensorEvent_FuelLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SensorEvent_FuelLevel& a, SensorEvent_FuelLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_FuelLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_FuelLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_FuelLevel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_FuelLevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_FuelLevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_FuelLevel& from) {
    SensorEvent_FuelLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_FuelLevel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.FuelLevel";
  }
  protected:
  explicit SensorEvent_FuelLevel(::google::protobuf::Arena* arena);
  SensorEvent_FuelLevel(::google::protobuf::Arena* arena, const SensorEvent_FuelLevel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuelLevelFieldNumber = 1,
    kRangeFieldNumber = 2,
    kLowFuelFieldNumber = 3,
  };
  // required int32 fuel_level = 1;
  bool has_fuel_level() const;
  void clear_fuel_level() ;
  ::int32_t fuel_level() const;
  void set_fuel_level(::int32_t value);

  private:
  ::int32_t _internal_fuel_level() const;
  void _internal_set_fuel_level(::int32_t value);

  public:
  // optional int32 range = 2;
  bool has_range() const;
  void clear_range() ;
  ::int32_t range() const;
  void set_range(::int32_t value);

  private:
  ::int32_t _internal_range() const;
  void _internal_set_range(::int32_t value);

  public:
  // optional bool low_fuel = 3;
  bool has_low_fuel() const;
  void clear_low_fuel() ;
  bool low_fuel() const;
  void set_low_fuel(bool value);

  private:
  bool _internal_low_fuel() const;
  void _internal_set_low_fuel(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.FuelLevel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t fuel_level_;
    ::int32_t range_;
    bool low_fuel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Environment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Environment) */ {
 public:
  inline SensorEvent_Environment() : SensorEvent_Environment(nullptr) {}
  ~SensorEvent_Environment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Environment(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Environment(const SensorEvent_Environment& from)
      : SensorEvent_Environment(nullptr, from) {}
  SensorEvent_Environment(SensorEvent_Environment&& from) noexcept
    : SensorEvent_Environment() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Environment& operator=(const SensorEvent_Environment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Environment& operator=(SensorEvent_Environment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Environment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Environment* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Environment*>(
               &_SensorEvent_Environment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SensorEvent_Environment& a, SensorEvent_Environment& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Environment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Environment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Environment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Environment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Environment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Environment& from) {
    SensorEvent_Environment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Environment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Environment";
  }
  protected:
  explicit SensorEvent_Environment(::google::protobuf::Arena* arena);
  SensorEvent_Environment(::google::protobuf::Arena* arena, const SensorEvent_Environment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureE3FieldNumber = 1,
    kPressureE3FieldNumber = 2,
    kRainFieldNumber = 3,
  };
  // optional int32 temperature_e3 = 1;
  bool has_temperature_e3() const;
  void clear_temperature_e3() ;
  ::int32_t temperature_e3() const;
  void set_temperature_e3(::int32_t value);

  private:
  ::int32_t _internal_temperature_e3() const;
  void _internal_set_temperature_e3(::int32_t value);

  public:
  // optional int32 pressure_e3 = 2;
  bool has_pressure_e3() const;
  void clear_pressure_e3() ;
  ::int32_t pressure_e3() const;
  void set_pressure_e3(::int32_t value);

  private:
  ::int32_t _internal_pressure_e3() const;
  void _internal_set_pressure_e3(::int32_t value);

  public:
  // optional int32 rain = 3;
  bool has_rain() const;
  void clear_rain() ;
  ::int32_t rain() const;
  void set_rain(::int32_t value);

  private:
  ::int32_t _internal_rain() const;
  void _internal_set_rain(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Environment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t temperature_e3_;
    ::int32_t pressure_e3_;
    ::int32_t rain_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_DrivingStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.DrivingStatus) */ {
 public:
  inline SensorEvent_DrivingStatus() : SensorEvent_DrivingStatus(nullptr) {}
  ~SensorEvent_DrivingStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_DrivingStatus(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_DrivingStatus(const SensorEvent_DrivingStatus& from)
      : SensorEvent_DrivingStatus(nullptr, from) {}
  SensorEvent_DrivingStatus(SensorEvent_DrivingStatus&& from) noexcept
    : SensorEvent_DrivingStatus() {
    *this = ::std::move(from);
  }

  inline SensorEvent_DrivingStatus& operator=(const SensorEvent_DrivingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_DrivingStatus& operator=(SensorEvent_DrivingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_DrivingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_DrivingStatus* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_DrivingStatus*>(
               &_SensorEvent_DrivingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SensorEvent_DrivingStatus& a, SensorEvent_DrivingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_DrivingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_DrivingStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_DrivingStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_DrivingStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_DrivingStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_DrivingStatus& from) {
    SensorEvent_DrivingStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_DrivingStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.DrivingStatus";
  }
  protected:
  explicit SensorEvent_DrivingStatus(::google::protobuf::Arena* arena);
  SensorEvent_DrivingStatus(::google::protobuf::Arena* arena, const SensorEvent_DrivingStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using STATUS = SensorEvent_DrivingStatus_STATUS;
  static constexpr STATUS DRIVE_STATUS_FULLY_RESTRICTED = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_FULLY_RESTRICTED;
  static constexpr STATUS DRIVE_STATUS_LIMIT_MESSAGE_LEN = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_LIMIT_MESSAGE_LEN;
  static constexpr STATUS DRIVE_STATUS_NO_CONFIG = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_CONFIG;
  static constexpr STATUS DRIVE_STATUS_NO_KEYBOARD_INPUT = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_KEYBOARD_INPUT;
  static constexpr STATUS DRIVE_STATUS_NO_VIDEO = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VIDEO;
  static constexpr STATUS DRIVE_STATUS_NO_VOICE_INPUT = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VOICE_INPUT;
  static constexpr STATUS DRIVE_STATUS_UNRESTRICTED = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_UNRESTRICTED;
  static inline bool STATUS_IsValid(int value) {
    return SensorEvent_DrivingStatus_STATUS_IsValid(value);
  }
  static constexpr STATUS STATUS_MIN = SensorEvent_DrivingStatus_STATUS_STATUS_MIN;
  static constexpr STATUS STATUS_MAX = SensorEvent_DrivingStatus_STATUS_STATUS_MAX;
  static constexpr int STATUS_ARRAYSIZE = SensorEvent_DrivingStatus_STATUS_STATUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* STATUS_descriptor() {
    return SensorEvent_DrivingStatus_STATUS_descriptor();
  }
  template <typename T>
  static inline const std::string& STATUS_Name(T value) {
    return SensorEvent_DrivingStatus_STATUS_Name(value);
  }
  static inline bool STATUS_Parse(absl::string_view name, STATUS* value) {
    return SensorEvent_DrivingStatus_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required int32 status = 1;
  bool has_status() const;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.DrivingStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Door final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Door) */ {
 public:
  inline SensorEvent_Door() : SensorEvent_Door(nullptr) {}
  ~SensorEvent_Door() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Door(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Door(const SensorEvent_Door& from)
      : SensorEvent_Door(nullptr, from) {}
  SensorEvent_Door(SensorEvent_Door&& from) noexcept
    : SensorEvent_Door() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Door& operator=(const SensorEvent_Door& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Door& operator=(SensorEvent_Door&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Door& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Door* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Door*>(
               &_SensorEvent_Door_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SensorEvent_Door& a, SensorEvent_Door& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Door* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Door* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Door* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Door>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Door& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Door& from) {
    SensorEvent_Door::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Door* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Door";
  }
  protected:
  explicit SensorEvent_Door(::google::protobuf::Arena* arena);
  SensorEvent_Door(::google::protobuf::Arena* arena, const SensorEvent_Door& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDoorOpenFieldNumber = 3,
    kHoodOpenFieldNumber = 1,
    kBootOpenFieldNumber = 2,
  };
  // repeated bool door_open = 3;
  int door_open_size() const;
  private:
  int _internal_door_open_size() const;

  public:
  void clear_door_open() ;
  bool door_open(int index) const;
  void set_door_open(int index, bool value);
  void add_door_open(bool value);
  const ::google::protobuf::RepeatedField<bool>& door_open() const;
  ::google::protobuf::RepeatedField<bool>* mutable_door_open();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_door_open() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_door_open();

  public:
  // optional bool hood_open = 1;
  bool has_hood_open() const;
  void clear_hood_open() ;
  bool hood_open() const;
  void set_hood_open(bool value);

  private:
  bool _internal_hood_open() const;
  void _internal_set_hood_open(bool value);

  public:
  // optional bool boot_open = 2;
  bool has_boot_open() const;
  void clear_boot_open() ;
  bool boot_open() const;
  void set_boot_open(bool value);

  private:
  bool _internal_boot_open() const;
  void _internal_set_boot_open(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Door)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<bool> door_open_;
    bool hood_open_;
    bool boot_open_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Diagnostics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Diagnostics) */ {
 public:
  inline SensorEvent_Diagnostics() : SensorEvent_Diagnostics(nullptr) {}
  ~SensorEvent_Diagnostics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Diagnostics(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Diagnostics(const SensorEvent_Diagnostics& from)
      : SensorEvent_Diagnostics(nullptr, from) {}
  SensorEvent_Diagnostics(SensorEvent_Diagnostics&& from) noexcept
    : SensorEvent_Diagnostics() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Diagnostics& operator=(const SensorEvent_Diagnostics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Diagnostics& operator=(SensorEvent_Diagnostics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Diagnostics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Diagnostics* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Diagnostics*>(
               &_SensorEvent_Diagnostics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SensorEvent_Diagnostics& a, SensorEvent_Diagnostics& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Diagnostics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Diagnostics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Diagnostics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Diagnostics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Diagnostics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Diagnostics& from) {
    SensorEvent_Diagnostics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Diagnostics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Diagnostics";
  }
  protected:
  explicit SensorEvent_Diagnostics(::google::protobuf::Arena* arena);
  SensorEvent_Diagnostics(::google::protobuf::Arena* arena, const SensorEvent_Diagnostics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticsByteFieldNumber = 1,
  };
  // optional bytes diagnostics_byte = 1;
  bool has_diagnostics_byte() const;
  void clear_diagnostics_byte() ;
  const std::string& diagnostics_byte() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_diagnostics_byte(Arg_&& arg, Args_... args);
  std::string* mutable_diagnostics_byte();
  PROTOBUF_NODISCARD std::string* release_diagnostics_byte();
  void set_allocated_diagnostics_byte(std::string* value);

  private:
  const std::string& _internal_diagnostics_byte() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_diagnostics_byte(
      const std::string& value);
  std::string* _internal_mutable_diagnostics_byte();

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Diagnostics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr diagnostics_byte_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_DeadReckoning final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.DeadReckoning) */ {
 public:
  inline SensorEvent_DeadReckoning() : SensorEvent_DeadReckoning(nullptr) {}
  ~SensorEvent_DeadReckoning() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_DeadReckoning(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_DeadReckoning(const SensorEvent_DeadReckoning& from)
      : SensorEvent_DeadReckoning(nullptr, from) {}
  SensorEvent_DeadReckoning(SensorEvent_DeadReckoning&& from) noexcept
    : SensorEvent_DeadReckoning() {
    *this = ::std::move(from);
  }

  inline SensorEvent_DeadReckoning& operator=(const SensorEvent_DeadReckoning& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_DeadReckoning& operator=(SensorEvent_DeadReckoning&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_DeadReckoning& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_DeadReckoning* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_DeadReckoning*>(
               &_SensorEvent_DeadReckoning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SensorEvent_DeadReckoning& a, SensorEvent_DeadReckoning& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_DeadReckoning* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_DeadReckoning* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_DeadReckoning* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_DeadReckoning>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_DeadReckoning& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_DeadReckoning& from) {
    SensorEvent_DeadReckoning::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_DeadReckoning* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.DeadReckoning";
  }
  protected:
  explicit SensorEvent_DeadReckoning(::google::protobuf::Arena* arena);
  SensorEvent_DeadReckoning(::google::protobuf::Arena* arena, const SensorEvent_DeadReckoning& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteeringAngelFieldNumber = 1,
    kWheelSpeedFieldNumber = 2,
  };
  // optional int32 steering_angel = 1;
  bool has_steering_angel() const;
  void clear_steering_angel() ;
  ::int32_t steering_angel() const;
  void set_steering_angel(::int32_t value);

  private:
  ::int32_t _internal_steering_angel() const;
  void _internal_set_steering_angel(::int32_t value);

  public:
  // optional int32 wheel_speed = 2;
  bool has_wheel_speed() const;
  void clear_wheel_speed() ;
  ::int32_t wheel_speed() const;
  void set_wheel_speed(::int32_t value);

  private:
  ::int32_t _internal_wheel_speed() const;
  void _internal_set_wheel_speed(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.DeadReckoning)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t steering_angel_;
    ::int32_t wheel_speed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_CompassData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.CompassData) */ {
 public:
  inline SensorEvent_CompassData() : SensorEvent_CompassData(nullptr) {}
  ~SensorEvent_CompassData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_CompassData(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_CompassData(const SensorEvent_CompassData& from)
      : SensorEvent_CompassData(nullptr, from) {}
  SensorEvent_CompassData(SensorEvent_CompassData&& from) noexcept
    : SensorEvent_CompassData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_CompassData& operator=(const SensorEvent_CompassData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_CompassData& operator=(SensorEvent_CompassData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_CompassData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_CompassData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_CompassData*>(
               &_SensorEvent_CompassData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SensorEvent_CompassData& a, SensorEvent_CompassData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_CompassData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_CompassData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_CompassData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_CompassData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_CompassData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_CompassData& from) {
    SensorEvent_CompassData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_CompassData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.CompassData";
  }
  protected:
  explicit SensorEvent_CompassData(::google::protobuf::Arena* arena);
  SensorEvent_CompassData(::google::protobuf::Arena* arena, const SensorEvent_CompassData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBearingE6FieldNumber = 1,
    kPitchE6FieldNumber = 2,
    kRollE6FieldNumber = 3,
  };
  // optional int32 bearing_e6 = 1;
  bool has_bearing_e6() const;
  void clear_bearing_e6() ;
  ::int32_t bearing_e6() const;
  void set_bearing_e6(::int32_t value);

  private:
  ::int32_t _internal_bearing_e6() const;
  void _internal_set_bearing_e6(::int32_t value);

  public:
  // optional int32 pitch_e6 = 2;
  bool has_pitch_e6() const;
  void clear_pitch_e6() ;
  ::int32_t pitch_e6() const;
  void set_pitch_e6(::int32_t value);

  private:
  ::int32_t _internal_pitch_e6() const;
  void _internal_set_pitch_e6(::int32_t value);

  public:
  // optional int32 roll_e6 = 3;
  bool has_roll_e6() const;
  void clear_roll_e6() ;
  ::int32_t roll_e6() const;
  void set_roll_e6(::int32_t value);

  private:
  ::int32_t _internal_roll_e6() const;
  void _internal_set_roll_e6(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.CompassData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t bearing_e6_;
    ::int32_t pitch_e6_;
    ::int32_t roll_e6_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent_Accel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Accel) */ {
 public:
  inline SensorEvent_Accel() : SensorEvent_Accel(nullptr) {}
  ~SensorEvent_Accel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent_Accel(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent_Accel(const SensorEvent_Accel& from)
      : SensorEvent_Accel(nullptr, from) {}
  SensorEvent_Accel(SensorEvent_Accel&& from) noexcept
    : SensorEvent_Accel() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Accel& operator=(const SensorEvent_Accel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Accel& operator=(SensorEvent_Accel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent_Accel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent_Accel* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Accel*>(
               &_SensorEvent_Accel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SensorEvent_Accel& a, SensorEvent_Accel& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Accel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Accel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent_Accel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent_Accel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent_Accel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent_Accel& from) {
    SensorEvent_Accel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent_Accel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent.Accel";
  }
  protected:
  explicit SensorEvent_Accel(::google::protobuf::Arena* arena);
  SensorEvent_Accel(::google::protobuf::Arena* arena, const SensorEvent_Accel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerationXE3FieldNumber = 1,
    kAccelerationYE3FieldNumber = 2,
    kAccelerationZE3FieldNumber = 3,
  };
  // optional int32 acceleration_x_e3 = 1;
  bool has_acceleration_x_e3() const;
  void clear_acceleration_x_e3() ;
  ::int32_t acceleration_x_e3() const;
  void set_acceleration_x_e3(::int32_t value);

  private:
  ::int32_t _internal_acceleration_x_e3() const;
  void _internal_set_acceleration_x_e3(::int32_t value);

  public:
  // optional int32 acceleration_y_e3 = 2;
  bool has_acceleration_y_e3() const;
  void clear_acceleration_y_e3() ;
  ::int32_t acceleration_y_e3() const;
  void set_acceleration_y_e3(::int32_t value);

  private:
  ::int32_t _internal_acceleration_y_e3() const;
  void _internal_set_acceleration_y_e3(::int32_t value);

  public:
  // optional int32 acceleration_z_e3 = 3;
  bool has_acceleration_z_e3() const;
  void clear_acceleration_z_e3() ;
  ::int32_t acceleration_z_e3() const;
  void set_acceleration_z_e3(::int32_t value);

  private:
  ::int32_t _internal_acceleration_z_e3() const;
  void _internal_set_acceleration_z_e3(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Accel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t acceleration_x_e3_;
    ::int32_t acceleration_y_e3_;
    ::int32_t acceleration_z_e3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class RelativeInputEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.RelativeInputEvent) */ {
 public:
  inline RelativeInputEvent() : RelativeInputEvent(nullptr) {}
  ~RelativeInputEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelativeInputEvent(::google::protobuf::internal::ConstantInitialized);

  inline RelativeInputEvent(const RelativeInputEvent& from)
      : RelativeInputEvent(nullptr, from) {}
  RelativeInputEvent(RelativeInputEvent&& from) noexcept
    : RelativeInputEvent() {
    *this = ::std::move(from);
  }

  inline RelativeInputEvent& operator=(const RelativeInputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelativeInputEvent& operator=(RelativeInputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelativeInputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelativeInputEvent* internal_default_instance() {
    return reinterpret_cast<const RelativeInputEvent*>(
               &_RelativeInputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RelativeInputEvent& a, RelativeInputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RelativeInputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelativeInputEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelativeInputEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelativeInputEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelativeInputEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RelativeInputEvent& from) {
    RelativeInputEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RelativeInputEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.RelativeInputEvent";
  }
  protected:
  explicit RelativeInputEvent(::google::protobuf::Arena* arena);
  RelativeInputEvent(::google::protobuf::Arena* arena, const RelativeInputEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodeFieldNumber = 1,
    kDeltaFieldNumber = 2,
  };
  // optional uint32 scan_code = 1;
  bool has_scan_code() const;
  void clear_scan_code() ;
  ::uint32_t scan_code() const;
  void set_scan_code(::uint32_t value);

  private:
  ::uint32_t _internal_scan_code() const;
  void _internal_set_scan_code(::uint32_t value);

  public:
  // optional int32 delta = 2;
  bool has_delta() const;
  void clear_delta() ;
  ::int32_t delta() const;
  void set_delta(::int32_t value);

  private:
  ::int32_t _internal_delta() const;
  void _internal_set_delta(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.RelativeInputEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t scan_code_;
    ::int32_t delta_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class PingResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  ~PingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingResponse(::google::protobuf::internal::ConstantInitialized);

  inline PingResponse(const PingResponse& from)
      : PingResponse(nullptr, from) {}
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PingResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PingResponse& from) {
    PingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PingResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.PingResponse";
  }
  protected:
  explicit PingResponse(::google::protobuf::Arena* arena);
  PingResponse(::google::protobuf::Arena* arena, const PingResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // required int64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.PingResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class PingRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingRequest(::google::protobuf::internal::ConstantInitialized);

  inline PingRequest(const PingRequest& from)
      : PingRequest(nullptr, from) {}
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PingRequest& from) {
    PingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PingRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.PingRequest";
  }
  protected:
  explicit PingRequest(::google::protobuf::Arena* arena);
  PingRequest(::google::protobuf::Arena* arena, const PingRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // required int64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.PingRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class PhoneStatusInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.PhoneStatusInput) */ {
 public:
  inline PhoneStatusInput() : PhoneStatusInput(nullptr) {}
  ~PhoneStatusInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PhoneStatusInput(::google::protobuf::internal::ConstantInitialized);

  inline PhoneStatusInput(const PhoneStatusInput& from)
      : PhoneStatusInput(nullptr, from) {}
  PhoneStatusInput(PhoneStatusInput&& from) noexcept
    : PhoneStatusInput() {
    *this = ::std::move(from);
  }

  inline PhoneStatusInput& operator=(const PhoneStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneStatusInput& operator=(PhoneStatusInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhoneStatusInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhoneStatusInput* internal_default_instance() {
    return reinterpret_cast<const PhoneStatusInput*>(
               &_PhoneStatusInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(PhoneStatusInput& a, PhoneStatusInput& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneStatusInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneStatusInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhoneStatusInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhoneStatusInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PhoneStatusInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PhoneStatusInput& from) {
    PhoneStatusInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PhoneStatusInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.PhoneStatusInput";
  }
  protected:
  explicit PhoneStatusInput(::google::protobuf::Arena* arena);
  PhoneStatusInput(::google::protobuf::Arena* arena, const PhoneStatusInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerNumberFieldNumber = 1,
    kCallerIdFieldNumber = 2,
  };
  // optional string caller_number = 1;
  bool has_caller_number() const;
  void clear_caller_number() ;
  const std::string& caller_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_caller_number(Arg_&& arg, Args_... args);
  std::string* mutable_caller_number();
  PROTOBUF_NODISCARD std::string* release_caller_number();
  void set_allocated_caller_number(std::string* value);

  private:
  const std::string& _internal_caller_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_number(
      const std::string& value);
  std::string* _internal_mutable_caller_number();

  public:
  // optional string caller_id = 2;
  bool has_caller_id() const;
  void clear_caller_id() ;
  const std::string& caller_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_caller_id(Arg_&& arg, Args_... args);
  std::string* mutable_caller_id();
  PROTOBUF_NODISCARD std::string* release_caller_id();
  void set_allocated_caller_id(std::string* value);

  private:
  const std::string& _internal_caller_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_id(
      const std::string& value);
  std::string* _internal_mutable_caller_id();

  public:
  // @@protoc_insertion_point(class_scope:HU.PhoneStatusInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr caller_number_;
    ::google::protobuf::internal::ArenaStringPtr caller_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class PhoneStatus_Call final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.PhoneStatus.Call) */ {
 public:
  inline PhoneStatus_Call() : PhoneStatus_Call(nullptr) {}
  ~PhoneStatus_Call() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PhoneStatus_Call(::google::protobuf::internal::ConstantInitialized);

  inline PhoneStatus_Call(const PhoneStatus_Call& from)
      : PhoneStatus_Call(nullptr, from) {}
  PhoneStatus_Call(PhoneStatus_Call&& from) noexcept
    : PhoneStatus_Call() {
    *this = ::std::move(from);
  }

  inline PhoneStatus_Call& operator=(const PhoneStatus_Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneStatus_Call& operator=(PhoneStatus_Call&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhoneStatus_Call& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhoneStatus_Call* internal_default_instance() {
    return reinterpret_cast<const PhoneStatus_Call*>(
               &_PhoneStatus_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(PhoneStatus_Call& a, PhoneStatus_Call& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneStatus_Call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneStatus_Call* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhoneStatus_Call* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhoneStatus_Call>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PhoneStatus_Call& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PhoneStatus_Call& from) {
    PhoneStatus_Call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PhoneStatus_Call* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.PhoneStatus.Call";
  }
  protected:
  explicit PhoneStatus_Call(::google::protobuf::Arena* arena);
  PhoneStatus_Call(::google::protobuf::Arena* arena, const PhoneStatus_Call& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneNumberFieldNumber = 3,
    kCallerIdFieldNumber = 4,
    kPhoneNumberTypeFieldNumber = 5,
    kThumbnailFieldNumber = 6,
    kCallTimeFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // optional string phone_number = 3;
  bool has_phone_number() const;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // optional string caller_id = 4;
  bool has_caller_id() const;
  void clear_caller_id() ;
  const std::string& caller_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_caller_id(Arg_&& arg, Args_... args);
  std::string* mutable_caller_id();
  PROTOBUF_NODISCARD std::string* release_caller_id();
  void set_allocated_caller_id(std::string* value);

  private:
  const std::string& _internal_caller_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_id(
      const std::string& value);
  std::string* _internal_mutable_caller_id();

  public:
  // optional string phone_number_type = 5;
  bool has_phone_number_type() const;
  void clear_phone_number_type() ;
  const std::string& phone_number_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number_type(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number_type();
  PROTOBUF_NODISCARD std::string* release_phone_number_type();
  void set_allocated_phone_number_type(std::string* value);

  private:
  const std::string& _internal_phone_number_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number_type(
      const std::string& value);
  std::string* _internal_mutable_phone_number_type();

  public:
  // optional bytes thumbnail = 6;
  bool has_thumbnail() const;
  void clear_thumbnail() ;
  const std::string& thumbnail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_thumbnail(Arg_&& arg, Args_... args);
  std::string* mutable_thumbnail();
  PROTOBUF_NODISCARD std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* value);

  private:
  const std::string& _internal_thumbnail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail(
      const std::string& value);
  std::string* _internal_mutable_thumbnail();

  public:
  // optional uint32 call_time = 2;
  bool has_call_time() const;
  void clear_call_time() ;
  ::uint32_t call_time() const;
  void set_call_time(::uint32_t value);

  private:
  ::uint32_t _internal_call_time() const;
  void _internal_set_call_time(::uint32_t value);

  public:
  // optional .HU.PhoneStatus.PHONE_STATE state = 1;
  bool has_state() const;
  void clear_state() ;
  ::HU::PhoneStatus_PHONE_STATE state() const;
  void set_state(::HU::PhoneStatus_PHONE_STATE value);

  private:
  ::HU::PhoneStatus_PHONE_STATE _internal_state() const;
  void _internal_set_state(::HU::PhoneStatus_PHONE_STATE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.PhoneStatus.Call)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr caller_id_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_type_;
    ::google::protobuf::internal::ArenaStringPtr thumbnail_;
    ::uint32_t call_time_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class NavigationFocusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.NavigationFocusResponse) */ {
 public:
  inline NavigationFocusResponse() : NavigationFocusResponse(nullptr) {}
  ~NavigationFocusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NavigationFocusResponse(::google::protobuf::internal::ConstantInitialized);

  inline NavigationFocusResponse(const NavigationFocusResponse& from)
      : NavigationFocusResponse(nullptr, from) {}
  NavigationFocusResponse(NavigationFocusResponse&& from) noexcept
    : NavigationFocusResponse() {
    *this = ::std::move(from);
  }

  inline NavigationFocusResponse& operator=(const NavigationFocusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFocusResponse& operator=(NavigationFocusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationFocusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationFocusResponse* internal_default_instance() {
    return reinterpret_cast<const NavigationFocusResponse*>(
               &_NavigationFocusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(NavigationFocusResponse& a, NavigationFocusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFocusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFocusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationFocusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationFocusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NavigationFocusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NavigationFocusResponse& from) {
    NavigationFocusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NavigationFocusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.NavigationFocusResponse";
  }
  protected:
  explicit NavigationFocusResponse(::google::protobuf::Arena* arena);
  NavigationFocusResponse(::google::protobuf::Arena* arena, const NavigationFocusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // optional uint32 focus_type = 1;
  bool has_focus_type() const;
  void clear_focus_type() ;
  ::uint32_t focus_type() const;
  void set_focus_type(::uint32_t value);

  private:
  ::uint32_t _internal_focus_type() const;
  void _internal_set_focus_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.NavigationFocusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t focus_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class NavigationFocusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.NavigationFocusRequest) */ {
 public:
  inline NavigationFocusRequest() : NavigationFocusRequest(nullptr) {}
  ~NavigationFocusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NavigationFocusRequest(::google::protobuf::internal::ConstantInitialized);

  inline NavigationFocusRequest(const NavigationFocusRequest& from)
      : NavigationFocusRequest(nullptr, from) {}
  NavigationFocusRequest(NavigationFocusRequest&& from) noexcept
    : NavigationFocusRequest() {
    *this = ::std::move(from);
  }

  inline NavigationFocusRequest& operator=(const NavigationFocusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFocusRequest& operator=(NavigationFocusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationFocusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationFocusRequest* internal_default_instance() {
    return reinterpret_cast<const NavigationFocusRequest*>(
               &_NavigationFocusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(NavigationFocusRequest& a, NavigationFocusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFocusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFocusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationFocusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationFocusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NavigationFocusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NavigationFocusRequest& from) {
    NavigationFocusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NavigationFocusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.NavigationFocusRequest";
  }
  protected:
  explicit NavigationFocusRequest(::google::protobuf::Arena* arena);
  NavigationFocusRequest(::google::protobuf::Arena* arena, const NavigationFocusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // optional uint32 focus_type = 1;
  bool has_focus_type() const;
  void clear_focus_type() ;
  ::uint32_t focus_type() const;
  void set_focus_type(::uint32_t value);

  private:
  ::uint32_t _internal_focus_type() const;
  void _internal_set_focus_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.NavigationFocusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t focus_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class NAVTurnMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.NAVTurnMessage) */ {
 public:
  inline NAVTurnMessage() : NAVTurnMessage(nullptr) {}
  ~NAVTurnMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NAVTurnMessage(::google::protobuf::internal::ConstantInitialized);

  inline NAVTurnMessage(const NAVTurnMessage& from)
      : NAVTurnMessage(nullptr, from) {}
  NAVTurnMessage(NAVTurnMessage&& from) noexcept
    : NAVTurnMessage() {
    *this = ::std::move(from);
  }

  inline NAVTurnMessage& operator=(const NAVTurnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NAVTurnMessage& operator=(NAVTurnMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NAVTurnMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const NAVTurnMessage* internal_default_instance() {
    return reinterpret_cast<const NAVTurnMessage*>(
               &_NAVTurnMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(NAVTurnMessage& a, NAVTurnMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NAVTurnMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NAVTurnMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NAVTurnMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NAVTurnMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NAVTurnMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NAVTurnMessage& from) {
    NAVTurnMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NAVTurnMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.NAVTurnMessage";
  }
  protected:
  explicit NAVTurnMessage(::google::protobuf::Arena* arena);
  NAVTurnMessage(::google::protobuf::Arena* arena, const NAVTurnMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TURN_SIDE = NAVTurnMessage_TURN_SIDE;
  static constexpr TURN_SIDE TURN_LEFT = NAVTurnMessage_TURN_SIDE_TURN_LEFT;
  static constexpr TURN_SIDE TURN_RIGHT = NAVTurnMessage_TURN_SIDE_TURN_RIGHT;
  static constexpr TURN_SIDE TURN_UNSPECIFIED = NAVTurnMessage_TURN_SIDE_TURN_UNSPECIFIED;
  static inline bool TURN_SIDE_IsValid(int value) {
    return NAVTurnMessage_TURN_SIDE_IsValid(value);
  }
  static constexpr TURN_SIDE TURN_SIDE_MIN = NAVTurnMessage_TURN_SIDE_TURN_SIDE_MIN;
  static constexpr TURN_SIDE TURN_SIDE_MAX = NAVTurnMessage_TURN_SIDE_TURN_SIDE_MAX;
  static constexpr int TURN_SIDE_ARRAYSIZE = NAVTurnMessage_TURN_SIDE_TURN_SIDE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TURN_SIDE_descriptor() {
    return NAVTurnMessage_TURN_SIDE_descriptor();
  }
  template <typename T>
  static inline const std::string& TURN_SIDE_Name(T value) {
    return NAVTurnMessage_TURN_SIDE_Name(value);
  }
  static inline bool TURN_SIDE_Parse(absl::string_view name, TURN_SIDE* value) {
    return NAVTurnMessage_TURN_SIDE_Parse(name, value);
  }

  using TURN_EVENT = NAVTurnMessage_TURN_EVENT;
  static constexpr TURN_EVENT TURN_UNKNOWN = NAVTurnMessage_TURN_EVENT_TURN_UNKNOWN;
  static constexpr TURN_EVENT TURN_DEPART = NAVTurnMessage_TURN_EVENT_TURN_DEPART;
  static constexpr TURN_EVENT TURN_NAME_CHANGE = NAVTurnMessage_TURN_EVENT_TURN_NAME_CHANGE;
  static constexpr TURN_EVENT TURN_SLIGHT_TURN = NAVTurnMessage_TURN_EVENT_TURN_SLIGHT_TURN;
  static constexpr TURN_EVENT TURN_TURN = NAVTurnMessage_TURN_EVENT_TURN_TURN;
  static constexpr TURN_EVENT TURN_SHARP_TURN = NAVTurnMessage_TURN_EVENT_TURN_SHARP_TURN;
  static constexpr TURN_EVENT TURN_U_TURN = NAVTurnMessage_TURN_EVENT_TURN_U_TURN;
  static constexpr TURN_EVENT TURN_ON_RAMP = NAVTurnMessage_TURN_EVENT_TURN_ON_RAMP;
  static constexpr TURN_EVENT TURN_OFF_RAMP = NAVTurnMessage_TURN_EVENT_TURN_OFF_RAMP;
  static constexpr TURN_EVENT TURN_FORK = NAVTurnMessage_TURN_EVENT_TURN_FORK;
  static constexpr TURN_EVENT TURN_MERGE = NAVTurnMessage_TURN_EVENT_TURN_MERGE;
  static constexpr TURN_EVENT TURN_ROUNDABOUT_ENTER = NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER;
  static constexpr TURN_EVENT TURN_ROUNDABOUT_EXIT = NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_EXIT;
  static constexpr TURN_EVENT TURN_ROUNDABOUT_ENTER_AND_EXIT = NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER_AND_EXIT;
  static constexpr TURN_EVENT TURN_STRAIGHT = NAVTurnMessage_TURN_EVENT_TURN_STRAIGHT;
  static constexpr TURN_EVENT TURN_FERRY_BOAT = NAVTurnMessage_TURN_EVENT_TURN_FERRY_BOAT;
  static constexpr TURN_EVENT TURN_FERRY_TRAIN = NAVTurnMessage_TURN_EVENT_TURN_FERRY_TRAIN;
  static constexpr TURN_EVENT TURN_DESTINATION = NAVTurnMessage_TURN_EVENT_TURN_DESTINATION;
  static inline bool TURN_EVENT_IsValid(int value) {
    return NAVTurnMessage_TURN_EVENT_IsValid(value);
  }
  static constexpr TURN_EVENT TURN_EVENT_MIN = NAVTurnMessage_TURN_EVENT_TURN_EVENT_MIN;
  static constexpr TURN_EVENT TURN_EVENT_MAX = NAVTurnMessage_TURN_EVENT_TURN_EVENT_MAX;
  static constexpr int TURN_EVENT_ARRAYSIZE = NAVTurnMessage_TURN_EVENT_TURN_EVENT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TURN_EVENT_descriptor() {
    return NAVTurnMessage_TURN_EVENT_descriptor();
  }
  template <typename T>
  static inline const std::string& TURN_EVENT_Name(T value) {
    return NAVTurnMessage_TURN_EVENT_Name(value);
  }
  static inline bool TURN_EVENT_Parse(absl::string_view name, TURN_EVENT* value) {
    return NAVTurnMessage_TURN_EVENT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEventNameFieldNumber = 1,
    kImageFieldNumber = 4,
    kTurnEventFieldNumber = 3,
    kTurnNumberFieldNumber = 5,
    kTurnAngleFieldNumber = 6,
    kTurnSideFieldNumber = 2,
  };
  // optional string event_name = 1;
  bool has_event_name() const;
  void clear_event_name() ;
  const std::string& event_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_name(Arg_&& arg, Args_... args);
  std::string* mutable_event_name();
  PROTOBUF_NODISCARD std::string* release_event_name();
  void set_allocated_event_name(std::string* value);

  private:
  const std::string& _internal_event_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(
      const std::string& value);
  std::string* _internal_mutable_event_name();

  public:
  // optional bytes image = 4;
  bool has_image() const;
  void clear_image() ;
  const std::string& image() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_image(Arg_&& arg, Args_... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* value);

  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(
      const std::string& value);
  std::string* _internal_mutable_image();

  public:
  // optional .HU.NAVTurnMessage.TURN_EVENT turn_event = 3;
  bool has_turn_event() const;
  void clear_turn_event() ;
  ::HU::NAVTurnMessage_TURN_EVENT turn_event() const;
  void set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value);

  private:
  ::HU::NAVTurnMessage_TURN_EVENT _internal_turn_event() const;
  void _internal_set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value);

  public:
  // optional int32 turn_number = 5;
  bool has_turn_number() const;
  void clear_turn_number() ;
  ::int32_t turn_number() const;
  void set_turn_number(::int32_t value);

  private:
  ::int32_t _internal_turn_number() const;
  void _internal_set_turn_number(::int32_t value);

  public:
  // optional int32 turn_angle = 6;
  bool has_turn_angle() const;
  void clear_turn_angle() ;
  ::int32_t turn_angle() const;
  void set_turn_angle(::int32_t value);

  private:
  ::int32_t _internal_turn_angle() const;
  void _internal_set_turn_angle(::int32_t value);

  public:
  // optional .HU.NAVTurnMessage.TURN_SIDE turn_side = 2;
  bool has_turn_side() const;
  void clear_turn_side() ;
  ::HU::NAVTurnMessage_TURN_SIDE turn_side() const;
  void set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value);

  private:
  ::HU::NAVTurnMessage_TURN_SIDE _internal_turn_side() const;
  void _internal_set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.NAVTurnMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr event_name_;
    ::google::protobuf::internal::ArenaStringPtr image_;
    int turn_event_;
    ::int32_t turn_number_;
    ::int32_t turn_angle_;
    int turn_side_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class NAVMessagesStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.NAVMessagesStatus) */ {
 public:
  inline NAVMessagesStatus() : NAVMessagesStatus(nullptr) {}
  ~NAVMessagesStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NAVMessagesStatus(::google::protobuf::internal::ConstantInitialized);

  inline NAVMessagesStatus(const NAVMessagesStatus& from)
      : NAVMessagesStatus(nullptr, from) {}
  NAVMessagesStatus(NAVMessagesStatus&& from) noexcept
    : NAVMessagesStatus() {
    *this = ::std::move(from);
  }

  inline NAVMessagesStatus& operator=(const NAVMessagesStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NAVMessagesStatus& operator=(NAVMessagesStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NAVMessagesStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NAVMessagesStatus* internal_default_instance() {
    return reinterpret_cast<const NAVMessagesStatus*>(
               &_NAVMessagesStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(NAVMessagesStatus& a, NAVMessagesStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NAVMessagesStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NAVMessagesStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NAVMessagesStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NAVMessagesStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NAVMessagesStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NAVMessagesStatus& from) {
    NAVMessagesStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NAVMessagesStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.NAVMessagesStatus";
  }
  protected:
  explicit NAVMessagesStatus(::google::protobuf::Arena* arena);
  NAVMessagesStatus(::google::protobuf::Arena* arena, const NAVMessagesStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using STATUS = NAVMessagesStatus_STATUS;
  static constexpr STATUS START = NAVMessagesStatus_STATUS_START;
  static constexpr STATUS STOP = NAVMessagesStatus_STATUS_STOP;
  static inline bool STATUS_IsValid(int value) {
    return NAVMessagesStatus_STATUS_IsValid(value);
  }
  static constexpr STATUS STATUS_MIN = NAVMessagesStatus_STATUS_STATUS_MIN;
  static constexpr STATUS STATUS_MAX = NAVMessagesStatus_STATUS_STATUS_MAX;
  static constexpr int STATUS_ARRAYSIZE = NAVMessagesStatus_STATUS_STATUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* STATUS_descriptor() {
    return NAVMessagesStatus_STATUS_descriptor();
  }
  template <typename T>
  static inline const std::string& STATUS_Name(T value) {
    return NAVMessagesStatus_STATUS_Name(value);
  }
  static inline bool STATUS_Parse(absl::string_view name, STATUS* value) {
    return NAVMessagesStatus_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .HU.NAVMessagesStatus.STATUS status = 1;
  bool has_status() const;
  void clear_status() ;
  ::HU::NAVMessagesStatus_STATUS status() const;
  void set_status(::HU::NAVMessagesStatus_STATUS value);

  private:
  ::HU::NAVMessagesStatus_STATUS _internal_status() const;
  void _internal_set_status(::HU::NAVMessagesStatus_STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.NAVMessagesStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class NAVDistanceMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.NAVDistanceMessage) */ {
 public:
  inline NAVDistanceMessage() : NAVDistanceMessage(nullptr) {}
  ~NAVDistanceMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NAVDistanceMessage(::google::protobuf::internal::ConstantInitialized);

  inline NAVDistanceMessage(const NAVDistanceMessage& from)
      : NAVDistanceMessage(nullptr, from) {}
  NAVDistanceMessage(NAVDistanceMessage&& from) noexcept
    : NAVDistanceMessage() {
    *this = ::std::move(from);
  }

  inline NAVDistanceMessage& operator=(const NAVDistanceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NAVDistanceMessage& operator=(NAVDistanceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NAVDistanceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const NAVDistanceMessage* internal_default_instance() {
    return reinterpret_cast<const NAVDistanceMessage*>(
               &_NAVDistanceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(NAVDistanceMessage& a, NAVDistanceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NAVDistanceMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NAVDistanceMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NAVDistanceMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NAVDistanceMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NAVDistanceMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NAVDistanceMessage& from) {
    NAVDistanceMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NAVDistanceMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.NAVDistanceMessage";
  }
  protected:
  explicit NAVDistanceMessage(::google::protobuf::Arena* arena);
  NAVDistanceMessage(::google::protobuf::Arena* arena, const NAVDistanceMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DISPLAY_DISTANCE_UNIT = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT;
  static constexpr DISPLAY_DISTANCE_UNIT METERS = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_METERS;
  static constexpr DISPLAY_DISTANCE_UNIT KILOMETERS10 = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS10;
  static constexpr DISPLAY_DISTANCE_UNIT KILOMETERS = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS;
  static constexpr DISPLAY_DISTANCE_UNIT MILES10 = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES10;
  static constexpr DISPLAY_DISTANCE_UNIT MILES = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES;
  static constexpr DISPLAY_DISTANCE_UNIT FEET = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_FEET;
  static inline bool DISPLAY_DISTANCE_UNIT_IsValid(int value) {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_IsValid(value);
  }
  static constexpr DISPLAY_DISTANCE_UNIT DISPLAY_DISTANCE_UNIT_MIN = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MIN;
  static constexpr DISPLAY_DISTANCE_UNIT DISPLAY_DISTANCE_UNIT_MAX = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MAX;
  static constexpr int DISPLAY_DISTANCE_UNIT_ARRAYSIZE = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DISPLAY_DISTANCE_UNIT_descriptor() {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor();
  }
  template <typename T>
  static inline const std::string& DISPLAY_DISTANCE_UNIT_Name(T value) {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name(value);
  }
  static inline bool DISPLAY_DISTANCE_UNIT_Parse(absl::string_view name, DISPLAY_DISTANCE_UNIT* value) {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
    kTimeUntilFieldNumber = 2,
    kDisplayDistanceFieldNumber = 3,
    kDisplayDistanceUnitFieldNumber = 4,
  };
  // optional int32 distance = 1;
  bool has_distance() const;
  void clear_distance() ;
  ::int32_t distance() const;
  void set_distance(::int32_t value);

  private:
  ::int32_t _internal_distance() const;
  void _internal_set_distance(::int32_t value);

  public:
  // optional int32 time_until = 2;
  bool has_time_until() const;
  void clear_time_until() ;
  ::int32_t time_until() const;
  void set_time_until(::int32_t value);

  private:
  ::int32_t _internal_time_until() const;
  void _internal_set_time_until(::int32_t value);

  public:
  // optional uint64 display_distance = 3;
  bool has_display_distance() const;
  void clear_display_distance() ;
  ::uint64_t display_distance() const;
  void set_display_distance(::uint64_t value);

  private:
  ::uint64_t _internal_display_distance() const;
  void _internal_set_display_distance(::uint64_t value);

  public:
  // optional .HU.NAVDistanceMessage.DISPLAY_DISTANCE_UNIT display_distance_unit = 4;
  bool has_display_distance_unit() const;
  void clear_display_distance_unit() ;
  ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT display_distance_unit() const;
  void set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value);

  private:
  ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT _internal_display_distance_unit() const;
  void _internal_set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value);

  public:
  // @@protoc_insertion_point(class_scope:HU.NAVDistanceMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t distance_;
    ::int32_t time_until_;
    ::uint64_t display_distance_;
    int display_distance_unit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MicResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.MicResponse) */ {
 public:
  inline MicResponse() : MicResponse(nullptr) {}
  ~MicResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MicResponse(::google::protobuf::internal::ConstantInitialized);

  inline MicResponse(const MicResponse& from)
      : MicResponse(nullptr, from) {}
  MicResponse(MicResponse&& from) noexcept
    : MicResponse() {
    *this = ::std::move(from);
  }

  inline MicResponse& operator=(const MicResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MicResponse& operator=(MicResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MicResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MicResponse* internal_default_instance() {
    return reinterpret_cast<const MicResponse*>(
               &_MicResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(MicResponse& a, MicResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MicResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MicResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MicResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MicResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MicResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MicResponse& from) {
    MicResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MicResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MicResponse";
  }
  protected:
  explicit MicResponse(::google::protobuf::Arena* arena);
  MicResponse(::google::protobuf::Arena* arena, const MicResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required int32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::int32_t session() const;
  void set_session(::int32_t value);

  private:
  ::int32_t _internal_session() const;
  void _internal_set_session(::int32_t value);

  public:
  // required uint32 value = 2;
  bool has_value() const;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.MicResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t session_;
    ::uint32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MicRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.MicRequest) */ {
 public:
  inline MicRequest() : MicRequest(nullptr) {}
  ~MicRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MicRequest(::google::protobuf::internal::ConstantInitialized);

  inline MicRequest(const MicRequest& from)
      : MicRequest(nullptr, from) {}
  MicRequest(MicRequest&& from) noexcept
    : MicRequest() {
    *this = ::std::move(from);
  }

  inline MicRequest& operator=(const MicRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MicRequest& operator=(MicRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MicRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MicRequest* internal_default_instance() {
    return reinterpret_cast<const MicRequest*>(
               &_MicRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(MicRequest& a, MicRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MicRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MicRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MicRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MicRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MicRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MicRequest& from) {
    MicRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MicRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MicRequest";
  }
  protected:
  explicit MicRequest(::google::protobuf::Arena* arena);
  MicRequest(::google::protobuf::Arena* arena, const MicRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 1,
    kAncFieldNumber = 2,
    kEcFieldNumber = 3,
    kMaxUnackedFieldNumber = 4,
  };
  // required bool open = 1;
  bool has_open() const;
  void clear_open() ;
  bool open() const;
  void set_open(bool value);

  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);

  public:
  // optional bool anc = 2;
  bool has_anc() const;
  void clear_anc() ;
  bool anc() const;
  void set_anc(bool value);

  private:
  bool _internal_anc() const;
  void _internal_set_anc(bool value);

  public:
  // optional bool ec = 3;
  bool has_ec() const;
  void clear_ec() ;
  bool ec() const;
  void set_ec(bool value);

  private:
  bool _internal_ec() const;
  void _internal_set_ec(bool value);

  public:
  // optional int32 max_unacked = 4;
  bool has_max_unacked() const;
  void clear_max_unacked() ;
  ::int32_t max_unacked() const;
  void set_max_unacked(::int32_t value);

  private:
  ::int32_t _internal_max_unacked() const;
  void _internal_set_max_unacked(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.MicRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool open_;
    bool anc_;
    bool ec_;
    ::int32_t max_unacked_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MediaStopRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:HU.MediaStopRequest) */ {
 public:
  inline MediaStopRequest() : MediaStopRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaStopRequest(::google::protobuf::internal::ConstantInitialized);

  inline MediaStopRequest(const MediaStopRequest& from)
      : MediaStopRequest(nullptr, from) {}
  MediaStopRequest(MediaStopRequest&& from) noexcept
    : MediaStopRequest() {
    *this = ::std::move(from);
  }

  inline MediaStopRequest& operator=(const MediaStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStopRequest& operator=(MediaStopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaStopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaStopRequest* internal_default_instance() {
    return reinterpret_cast<const MediaStopRequest*>(
               &_MediaStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(MediaStopRequest& a, MediaStopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStopRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaStopRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaStopRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MediaStopRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MediaStopRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MediaStopRequest";
  }
  protected:
  explicit MediaStopRequest(::google::protobuf::Arena* arena);
  MediaStopRequest(::google::protobuf::Arena* arena, const MediaStopRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.MediaStopRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MediaStartRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.MediaStartRequest) */ {
 public:
  inline MediaStartRequest() : MediaStartRequest(nullptr) {}
  ~MediaStartRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaStartRequest(::google::protobuf::internal::ConstantInitialized);

  inline MediaStartRequest(const MediaStartRequest& from)
      : MediaStartRequest(nullptr, from) {}
  MediaStartRequest(MediaStartRequest&& from) noexcept
    : MediaStartRequest() {
    *this = ::std::move(from);
  }

  inline MediaStartRequest& operator=(const MediaStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStartRequest& operator=(MediaStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaStartRequest* internal_default_instance() {
    return reinterpret_cast<const MediaStartRequest*>(
               &_MediaStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(MediaStartRequest& a, MediaStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStartRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaStartRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaStartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaStartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaStartRequest& from) {
    MediaStartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaStartRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MediaStartRequest";
  }
  protected:
  explicit MediaStartRequest(::google::protobuf::Arena* arena);
  MediaStartRequest(::google::protobuf::Arena* arena, const MediaStartRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // required int32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::int32_t session() const;
  void set_session(::int32_t value);

  private:
  ::int32_t _internal_session() const;
  void _internal_set_session(::int32_t value);

  public:
  // optional uint32 config = 2;
  bool has_config() const;
  void clear_config() ;
  ::uint32_t config() const;
  void set_config(::uint32_t value);

  private:
  ::uint32_t _internal_config() const;
  void _internal_set_config(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.MediaStartRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t session_;
    ::uint32_t config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MediaSetupResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.MediaSetupResponse) */ {
 public:
  inline MediaSetupResponse() : MediaSetupResponse(nullptr) {}
  ~MediaSetupResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaSetupResponse(::google::protobuf::internal::ConstantInitialized);

  inline MediaSetupResponse(const MediaSetupResponse& from)
      : MediaSetupResponse(nullptr, from) {}
  MediaSetupResponse(MediaSetupResponse&& from) noexcept
    : MediaSetupResponse() {
    *this = ::std::move(from);
  }

  inline MediaSetupResponse& operator=(const MediaSetupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaSetupResponse& operator=(MediaSetupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaSetupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaSetupResponse* internal_default_instance() {
    return reinterpret_cast<const MediaSetupResponse*>(
               &_MediaSetupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(MediaSetupResponse& a, MediaSetupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaSetupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaSetupResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaSetupResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaSetupResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaSetupResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaSetupResponse& from) {
    MediaSetupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaSetupResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MediaSetupResponse";
  }
  protected:
  explicit MediaSetupResponse(::google::protobuf::Arena* arena);
  MediaSetupResponse(::google::protobuf::Arena* arena, const MediaSetupResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MEDIA_STATUS = MediaSetupResponse_MEDIA_STATUS;
  static constexpr MEDIA_STATUS MEDIA_STATUS_1 = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_1;
  static constexpr MEDIA_STATUS MEDIA_STATUS_2 = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_2;
  static inline bool MEDIA_STATUS_IsValid(int value) {
    return MediaSetupResponse_MEDIA_STATUS_IsValid(value);
  }
  static constexpr MEDIA_STATUS MEDIA_STATUS_MIN = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MIN;
  static constexpr MEDIA_STATUS MEDIA_STATUS_MAX = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MAX;
  static constexpr int MEDIA_STATUS_ARRAYSIZE = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MEDIA_STATUS_descriptor() {
    return MediaSetupResponse_MEDIA_STATUS_descriptor();
  }
  template <typename T>
  static inline const std::string& MEDIA_STATUS_Name(T value) {
    return MediaSetupResponse_MEDIA_STATUS_Name(value);
  }
  static inline bool MEDIA_STATUS_Parse(absl::string_view name, MEDIA_STATUS* value) {
    return MediaSetupResponse_MEDIA_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 3,
    kMaxUnackedFieldNumber = 2,
    kMediaStatusFieldNumber = 1,
  };
  // repeated uint32 configs = 3;
  int configs_size() const;
  private:
  int _internal_configs_size() const;

  public:
  void clear_configs() ;
  ::uint32_t configs(int index) const;
  void set_configs(int index, ::uint32_t value);
  void add_configs(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& configs() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_configs();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_configs() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_configs();

  public:
  // required uint32 max_unacked = 2;
  bool has_max_unacked() const;
  void clear_max_unacked() ;
  ::uint32_t max_unacked() const;
  void set_max_unacked(::uint32_t value);

  private:
  ::uint32_t _internal_max_unacked() const;
  void _internal_set_max_unacked(::uint32_t value);

  public:
  // required .HU.MediaSetupResponse.MEDIA_STATUS media_status = 1;
  bool has_media_status() const;
  void clear_media_status() ;
  ::HU::MediaSetupResponse_MEDIA_STATUS media_status() const;
  void set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value);

  private:
  ::HU::MediaSetupResponse_MEDIA_STATUS _internal_media_status() const;
  void _internal_set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.MediaSetupResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> configs_;
    ::uint32_t max_unacked_;
    int media_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MediaSetupRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.MediaSetupRequest) */ {
 public:
  inline MediaSetupRequest() : MediaSetupRequest(nullptr) {}
  ~MediaSetupRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaSetupRequest(::google::protobuf::internal::ConstantInitialized);

  inline MediaSetupRequest(const MediaSetupRequest& from)
      : MediaSetupRequest(nullptr, from) {}
  MediaSetupRequest(MediaSetupRequest&& from) noexcept
    : MediaSetupRequest() {
    *this = ::std::move(from);
  }

  inline MediaSetupRequest& operator=(const MediaSetupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaSetupRequest& operator=(MediaSetupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaSetupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaSetupRequest* internal_default_instance() {
    return reinterpret_cast<const MediaSetupRequest*>(
               &_MediaSetupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(MediaSetupRequest& a, MediaSetupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaSetupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaSetupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaSetupRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaSetupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaSetupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaSetupRequest& from) {
    MediaSetupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaSetupRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MediaSetupRequest";
  }
  protected:
  explicit MediaSetupRequest(::google::protobuf::Arena* arena);
  MediaSetupRequest(::google::protobuf::Arena* arena, const MediaSetupRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.MediaSetupRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class MediaAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.MediaAck) */ {
 public:
  inline MediaAck() : MediaAck(nullptr) {}
  ~MediaAck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaAck(::google::protobuf::internal::ConstantInitialized);

  inline MediaAck(const MediaAck& from)
      : MediaAck(nullptr, from) {}
  MediaAck(MediaAck&& from) noexcept
    : MediaAck() {
    *this = ::std::move(from);
  }

  inline MediaAck& operator=(const MediaAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaAck& operator=(MediaAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaAck* internal_default_instance() {
    return reinterpret_cast<const MediaAck*>(
               &_MediaAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(MediaAck& a, MediaAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaAck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaAck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaAck& from) {
    MediaAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaAck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.MediaAck";
  }
  protected:
  explicit MediaAck(::google::protobuf::Arena* arena);
  MediaAck(::google::protobuf::Arena* arena, const MediaAck& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required int32 session = 1;
  bool has_session() const;
  void clear_session() ;
  ::int32_t session() const;
  void set_session(::int32_t value);

  private:
  ::int32_t _internal_session() const;
  void _internal_set_session(::int32_t value);

  public:
  // required uint32 value = 2;
  bool has_value() const;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.MediaAck)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t session_;
    ::uint32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class GenericNotificationResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.GenericNotificationResponse) */ {
 public:
  inline GenericNotificationResponse() : GenericNotificationResponse(nullptr) {}
  ~GenericNotificationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericNotificationResponse(::google::protobuf::internal::ConstantInitialized);

  inline GenericNotificationResponse(const GenericNotificationResponse& from)
      : GenericNotificationResponse(nullptr, from) {}
  GenericNotificationResponse(GenericNotificationResponse&& from) noexcept
    : GenericNotificationResponse() {
    *this = ::std::move(from);
  }

  inline GenericNotificationResponse& operator=(const GenericNotificationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericNotificationResponse& operator=(GenericNotificationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericNotificationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericNotificationResponse* internal_default_instance() {
    return reinterpret_cast<const GenericNotificationResponse*>(
               &_GenericNotificationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(GenericNotificationResponse& a, GenericNotificationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericNotificationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericNotificationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericNotificationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericNotificationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericNotificationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericNotificationResponse& from) {
    GenericNotificationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericNotificationResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.GenericNotificationResponse";
  }
  protected:
  explicit GenericNotificationResponse(::google::protobuf::Arena* arena);
  GenericNotificationResponse(::google::protobuf::Arena* arena, const GenericNotificationResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHandledFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required bool handled = 2;
  bool has_handled() const;
  void clear_handled() ;
  bool handled() const;
  void set_handled(bool value);

  private:
  bool _internal_handled() const;
  void _internal_set_handled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.GenericNotificationResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    bool handled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class GenericNotificationRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.GenericNotificationRequest) */ {
 public:
  inline GenericNotificationRequest() : GenericNotificationRequest(nullptr) {}
  ~GenericNotificationRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericNotificationRequest(::google::protobuf::internal::ConstantInitialized);

  inline GenericNotificationRequest(const GenericNotificationRequest& from)
      : GenericNotificationRequest(nullptr, from) {}
  GenericNotificationRequest(GenericNotificationRequest&& from) noexcept
    : GenericNotificationRequest() {
    *this = ::std::move(from);
  }

  inline GenericNotificationRequest& operator=(const GenericNotificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericNotificationRequest& operator=(GenericNotificationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericNotificationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericNotificationRequest* internal_default_instance() {
    return reinterpret_cast<const GenericNotificationRequest*>(
               &_GenericNotificationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(GenericNotificationRequest& a, GenericNotificationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericNotificationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericNotificationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericNotificationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericNotificationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericNotificationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericNotificationRequest& from) {
    GenericNotificationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericNotificationRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.GenericNotificationRequest";
  }
  protected:
  explicit GenericNotificationRequest(::google::protobuf::Arena* arena);
  GenericNotificationRequest(::google::protobuf::Arena* arena, const GenericNotificationRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kIconFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string text = 2;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional string icon = 3;
  bool has_icon() const;
  void clear_icon() ;
  const std::string& icon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_icon(Arg_&& arg, Args_... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* value);

  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(
      const std::string& value);
  std::string* _internal_mutable_icon();

  public:
  // @@protoc_insertion_point(class_scope:HU.GenericNotificationRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr icon_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelOpenResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelOpenResponse) */ {
 public:
  inline ChannelOpenResponse() : ChannelOpenResponse(nullptr) {}
  ~ChannelOpenResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelOpenResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChannelOpenResponse(const ChannelOpenResponse& from)
      : ChannelOpenResponse(nullptr, from) {}
  ChannelOpenResponse(ChannelOpenResponse&& from) noexcept
    : ChannelOpenResponse() {
    *this = ::std::move(from);
  }

  inline ChannelOpenResponse& operator=(const ChannelOpenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelOpenResponse& operator=(ChannelOpenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelOpenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelOpenResponse* internal_default_instance() {
    return reinterpret_cast<const ChannelOpenResponse*>(
               &_ChannelOpenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ChannelOpenResponse& a, ChannelOpenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelOpenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelOpenResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelOpenResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelOpenResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelOpenResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelOpenResponse& from) {
    ChannelOpenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelOpenResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelOpenResponse";
  }
  protected:
  explicit ChannelOpenResponse(::google::protobuf::Arena* arena);
  ChannelOpenResponse(::google::protobuf::Arena* arena, const ChannelOpenResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  void clear_status() ;
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);

  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelOpenResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelOpenRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelOpenRequest) */ {
 public:
  inline ChannelOpenRequest() : ChannelOpenRequest(nullptr) {}
  ~ChannelOpenRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelOpenRequest(::google::protobuf::internal::ConstantInitialized);

  inline ChannelOpenRequest(const ChannelOpenRequest& from)
      : ChannelOpenRequest(nullptr, from) {}
  ChannelOpenRequest(ChannelOpenRequest&& from) noexcept
    : ChannelOpenRequest() {
    *this = ::std::move(from);
  }

  inline ChannelOpenRequest& operator=(const ChannelOpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelOpenRequest& operator=(ChannelOpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelOpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelOpenRequest* internal_default_instance() {
    return reinterpret_cast<const ChannelOpenRequest*>(
               &_ChannelOpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ChannelOpenRequest& a, ChannelOpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelOpenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelOpenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelOpenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelOpenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelOpenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelOpenRequest& from) {
    ChannelOpenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelOpenRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelOpenRequest";
  }
  protected:
  explicit ChannelOpenRequest(::google::protobuf::Arena* arena);
  ChannelOpenRequest(::google::protobuf::Arena* arena, const ChannelOpenRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional int32 priority = 1;
  bool has_priority() const;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // optional int32 id = 2;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelOpenRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t priority_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_VendorExtensionService final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.VendorExtensionService) */ {
 public:
  inline ChannelDescriptor_VendorExtensionService() : ChannelDescriptor_VendorExtensionService(nullptr) {}
  ~ChannelDescriptor_VendorExtensionService() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_VendorExtensionService(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_VendorExtensionService(const ChannelDescriptor_VendorExtensionService& from)
      : ChannelDescriptor_VendorExtensionService(nullptr, from) {}
  ChannelDescriptor_VendorExtensionService(ChannelDescriptor_VendorExtensionService&& from) noexcept
    : ChannelDescriptor_VendorExtensionService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_VendorExtensionService& operator=(const ChannelDescriptor_VendorExtensionService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_VendorExtensionService& operator=(ChannelDescriptor_VendorExtensionService&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_VendorExtensionService& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_VendorExtensionService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_VendorExtensionService*>(
               &_ChannelDescriptor_VendorExtensionService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ChannelDescriptor_VendorExtensionService& a, ChannelDescriptor_VendorExtensionService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_VendorExtensionService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_VendorExtensionService* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_VendorExtensionService* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_VendorExtensionService>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_VendorExtensionService& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_VendorExtensionService& from) {
    ChannelDescriptor_VendorExtensionService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_VendorExtensionService* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.VendorExtensionService";
  }
  protected:
  explicit ChannelDescriptor_VendorExtensionService(::google::protobuf::Arena* arena);
  ChannelDescriptor_VendorExtensionService(::google::protobuf::Arena* arena, const ChannelDescriptor_VendorExtensionService& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageWhiteListFieldNumber = 2,
    kNameFieldNumber = 1,
    kDataFieldNumber = 3,
  };
  // repeated string package_white_list = 2;
  int package_white_list_size() const;
  private:
  int _internal_package_white_list_size() const;

  public:
  void clear_package_white_list() ;
  const std::string& package_white_list(int index) const;
  std::string* mutable_package_white_list(int index);
  void set_package_white_list(int index, const std::string& value);
  void set_package_white_list(int index, std::string&& value);
  void set_package_white_list(int index, const char* value);
  void set_package_white_list(int index, const char* value, std::size_t size);
  void set_package_white_list(int index, absl::string_view value);
  std::string* add_package_white_list();
  void add_package_white_list(const std::string& value);
  void add_package_white_list(std::string&& value);
  void add_package_white_list(const char* value);
  void add_package_white_list(const char* value, std::size_t size);
  void add_package_white_list(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& package_white_list() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_package_white_list();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_package_white_list() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_package_white_list();

  public:
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional bytes data = 3;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.VendorExtensionService)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> package_white_list_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_SensorChannel_Sensor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.SensorChannel.Sensor) */ {
 public:
  inline ChannelDescriptor_SensorChannel_Sensor() : ChannelDescriptor_SensorChannel_Sensor(nullptr) {}
  ~ChannelDescriptor_SensorChannel_Sensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_SensorChannel_Sensor(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_SensorChannel_Sensor(const ChannelDescriptor_SensorChannel_Sensor& from)
      : ChannelDescriptor_SensorChannel_Sensor(nullptr, from) {}
  ChannelDescriptor_SensorChannel_Sensor(ChannelDescriptor_SensorChannel_Sensor&& from) noexcept
    : ChannelDescriptor_SensorChannel_Sensor() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_SensorChannel_Sensor& operator=(const ChannelDescriptor_SensorChannel_Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_SensorChannel_Sensor& operator=(ChannelDescriptor_SensorChannel_Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_SensorChannel_Sensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_SensorChannel_Sensor* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_SensorChannel_Sensor*>(
               &_ChannelDescriptor_SensorChannel_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ChannelDescriptor_SensorChannel_Sensor& a, ChannelDescriptor_SensorChannel_Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_SensorChannel_Sensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_SensorChannel_Sensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_SensorChannel_Sensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_SensorChannel_Sensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_SensorChannel_Sensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_SensorChannel_Sensor& from) {
    ChannelDescriptor_SensorChannel_Sensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_SensorChannel_Sensor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.SensorChannel.Sensor";
  }
  protected:
  explicit ChannelDescriptor_SensorChannel_Sensor(::google::protobuf::Arena* arena);
  ChannelDescriptor_SensorChannel_Sensor(::google::protobuf::Arena* arena, const ChannelDescriptor_SensorChannel_Sensor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .HU.SENSOR_TYPE type = 1;
  bool has_type() const;
  void clear_type() ;
  ::HU::SENSOR_TYPE type() const;
  void set_type(::HU::SENSOR_TYPE value);

  private:
  ::HU::SENSOR_TYPE _internal_type() const;
  void _internal_set_type(::HU::SENSOR_TYPE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.SensorChannel.Sensor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_PhoneStatusService final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.PhoneStatusService) */ {
 public:
  inline ChannelDescriptor_PhoneStatusService() : ChannelDescriptor_PhoneStatusService(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_PhoneStatusService(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_PhoneStatusService(const ChannelDescriptor_PhoneStatusService& from)
      : ChannelDescriptor_PhoneStatusService(nullptr, from) {}
  ChannelDescriptor_PhoneStatusService(ChannelDescriptor_PhoneStatusService&& from) noexcept
    : ChannelDescriptor_PhoneStatusService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_PhoneStatusService& operator=(const ChannelDescriptor_PhoneStatusService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_PhoneStatusService& operator=(ChannelDescriptor_PhoneStatusService&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_PhoneStatusService& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_PhoneStatusService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_PhoneStatusService*>(
               &_ChannelDescriptor_PhoneStatusService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ChannelDescriptor_PhoneStatusService& a, ChannelDescriptor_PhoneStatusService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_PhoneStatusService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_PhoneStatusService* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_PhoneStatusService* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_PhoneStatusService>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChannelDescriptor_PhoneStatusService& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChannelDescriptor_PhoneStatusService& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.PhoneStatusService";
  }
  protected:
  explicit ChannelDescriptor_PhoneStatusService(::google::protobuf::Arena* arena);
  ChannelDescriptor_PhoneStatusService(::google::protobuf::Arena* arena, const ChannelDescriptor_PhoneStatusService& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.PhoneStatusService)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_OutputStreamChannel_VideoConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig) */ {
 public:
  inline ChannelDescriptor_OutputStreamChannel_VideoConfig() : ChannelDescriptor_OutputStreamChannel_VideoConfig(nullptr) {}
  ~ChannelDescriptor_OutputStreamChannel_VideoConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_OutputStreamChannel_VideoConfig(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_OutputStreamChannel_VideoConfig(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from)
      : ChannelDescriptor_OutputStreamChannel_VideoConfig(nullptr, from) {}
  ChannelDescriptor_OutputStreamChannel_VideoConfig(ChannelDescriptor_OutputStreamChannel_VideoConfig&& from) noexcept
    : ChannelDescriptor_OutputStreamChannel_VideoConfig() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_OutputStreamChannel_VideoConfig& operator=(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_OutputStreamChannel_VideoConfig& operator=(ChannelDescriptor_OutputStreamChannel_VideoConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_OutputStreamChannel_VideoConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_OutputStreamChannel_VideoConfig* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_OutputStreamChannel_VideoConfig*>(
               &_ChannelDescriptor_OutputStreamChannel_VideoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ChannelDescriptor_OutputStreamChannel_VideoConfig& a, ChannelDescriptor_OutputStreamChannel_VideoConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_OutputStreamChannel_VideoConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_OutputStreamChannel_VideoConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_OutputStreamChannel_VideoConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_OutputStreamChannel_VideoConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_OutputStreamChannel_VideoConfig& from) {
    ChannelDescriptor_OutputStreamChannel_VideoConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_OutputStreamChannel_VideoConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.OutputStreamChannel.VideoConfig";
  }
  protected:
  explicit ChannelDescriptor_OutputStreamChannel_VideoConfig(::google::protobuf::Arena* arena);
  ChannelDescriptor_OutputStreamChannel_VideoConfig(::google::protobuf::Arena* arena, const ChannelDescriptor_OutputStreamChannel_VideoConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VIDEO_RESOLUTION = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_800x480 = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_800x480;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_1280x720 = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1280x720;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_1920x1080 = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1920x1080;
  static inline bool VIDEO_RESOLUTION_IsValid(int value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_IsValid(value);
  }
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_MIN = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MIN;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_MAX = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MAX;
  static constexpr int VIDEO_RESOLUTION_ARRAYSIZE = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VIDEO_RESOLUTION_descriptor() {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor();
  }
  template <typename T>
  static inline const std::string& VIDEO_RESOLUTION_Name(T value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name(value);
  }
  static inline bool VIDEO_RESOLUTION_Parse(absl::string_view name, VIDEO_RESOLUTION* value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Parse(name, value);
  }

  using VIDEO_FPS = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS;
  static constexpr VIDEO_FPS VIDEO_FPS_30 = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_30;
  static constexpr VIDEO_FPS VIDEO_FPS_60 = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_60;
  static inline bool VIDEO_FPS_IsValid(int value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_IsValid(value);
  }
  static constexpr VIDEO_FPS VIDEO_FPS_MIN = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MIN;
  static constexpr VIDEO_FPS VIDEO_FPS_MAX = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MAX;
  static constexpr int VIDEO_FPS_ARRAYSIZE = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VIDEO_FPS_descriptor() {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor();
  }
  template <typename T>
  static inline const std::string& VIDEO_FPS_Name(T value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name(value);
  }
  static inline bool VIDEO_FPS_Parse(absl::string_view name, VIDEO_FPS* value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMarginWidthFieldNumber = 3,
    kMarginHeightFieldNumber = 4,
    kDpiFieldNumber = 5,
    kAdditionalDepthFieldNumber = 6,
    kResolutionFieldNumber = 1,
    kFrameRateFieldNumber = 2,
  };
  // required uint32 margin_width = 3;
  bool has_margin_width() const;
  void clear_margin_width() ;
  ::uint32_t margin_width() const;
  void set_margin_width(::uint32_t value);

  private:
  ::uint32_t _internal_margin_width() const;
  void _internal_set_margin_width(::uint32_t value);

  public:
  // required uint32 margin_height = 4;
  bool has_margin_height() const;
  void clear_margin_height() ;
  ::uint32_t margin_height() const;
  void set_margin_height(::uint32_t value);

  private:
  ::uint32_t _internal_margin_height() const;
  void _internal_set_margin_height(::uint32_t value);

  public:
  // required uint32 dpi = 5;
  bool has_dpi() const;
  void clear_dpi() ;
  ::uint32_t dpi() const;
  void set_dpi(::uint32_t value);

  private:
  ::uint32_t _internal_dpi() const;
  void _internal_set_dpi(::uint32_t value);

  public:
  // optional uint32 additional_depth = 6;
  bool has_additional_depth() const;
  void clear_additional_depth() ;
  ::uint32_t additional_depth() const;
  void set_additional_depth(::uint32_t value);

  private:
  ::uint32_t _internal_additional_depth() const;
  void _internal_set_additional_depth(::uint32_t value);

  public:
  // required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_RESOLUTION resolution = 1;
  bool has_resolution() const;
  void clear_resolution() ;
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION resolution() const;
  void set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value);

  private:
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION _internal_resolution() const;
  void _internal_set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value);

  public:
  // required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_FPS frame_rate = 2;
  bool has_frame_rate() const;
  void clear_frame_rate() ;
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS frame_rate() const;
  void set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value);

  private:
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS _internal_frame_rate() const;
  void _internal_set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t margin_width_;
    ::uint32_t margin_height_;
    ::uint32_t dpi_;
    ::uint32_t additional_depth_;
    int resolution_;
    int frame_rate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_NavigationStatusService_ImageOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.NavigationStatusService.ImageOptions) */ {
 public:
  inline ChannelDescriptor_NavigationStatusService_ImageOptions() : ChannelDescriptor_NavigationStatusService_ImageOptions(nullptr) {}
  ~ChannelDescriptor_NavigationStatusService_ImageOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_NavigationStatusService_ImageOptions(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_NavigationStatusService_ImageOptions(const ChannelDescriptor_NavigationStatusService_ImageOptions& from)
      : ChannelDescriptor_NavigationStatusService_ImageOptions(nullptr, from) {}
  ChannelDescriptor_NavigationStatusService_ImageOptions(ChannelDescriptor_NavigationStatusService_ImageOptions&& from) noexcept
    : ChannelDescriptor_NavigationStatusService_ImageOptions() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_NavigationStatusService_ImageOptions& operator=(const ChannelDescriptor_NavigationStatusService_ImageOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_NavigationStatusService_ImageOptions& operator=(ChannelDescriptor_NavigationStatusService_ImageOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_NavigationStatusService_ImageOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_NavigationStatusService_ImageOptions* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_NavigationStatusService_ImageOptions*>(
               &_ChannelDescriptor_NavigationStatusService_ImageOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ChannelDescriptor_NavigationStatusService_ImageOptions& a, ChannelDescriptor_NavigationStatusService_ImageOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_NavigationStatusService_ImageOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_NavigationStatusService_ImageOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_NavigationStatusService_ImageOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_NavigationStatusService_ImageOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_NavigationStatusService_ImageOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_NavigationStatusService_ImageOptions& from) {
    ChannelDescriptor_NavigationStatusService_ImageOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_NavigationStatusService_ImageOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.NavigationStatusService.ImageOptions";
  }
  protected:
  explicit ChannelDescriptor_NavigationStatusService_ImageOptions(::google::protobuf::Arena* arena);
  ChannelDescriptor_NavigationStatusService_ImageOptions(::google::protobuf::Arena* arena, const ChannelDescriptor_NavigationStatusService_ImageOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kColourDepthBitsFieldNumber = 3,
  };
  // required int32 width = 1;
  bool has_width() const;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // required int32 height = 2;
  bool has_height() const;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // required int32 colour_depth_bits = 3;
  bool has_colour_depth_bits() const;
  void clear_colour_depth_bits() ;
  ::int32_t colour_depth_bits() const;
  void set_colour_depth_bits(::int32_t value);

  private:
  ::int32_t _internal_colour_depth_bits() const;
  void _internal_set_colour_depth_bits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.NavigationStatusService.ImageOptions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t width_;
    ::int32_t height_;
    ::int32_t colour_depth_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_InputEventChannel_TouchScreenConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig) */ {
 public:
  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig() : ChannelDescriptor_InputEventChannel_TouchScreenConfig(nullptr) {}
  ~ChannelDescriptor_InputEventChannel_TouchScreenConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_InputEventChannel_TouchScreenConfig(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from)
      : ChannelDescriptor_InputEventChannel_TouchScreenConfig(nullptr, from) {}
  ChannelDescriptor_InputEventChannel_TouchScreenConfig(ChannelDescriptor_InputEventChannel_TouchScreenConfig&& from) noexcept
    : ChannelDescriptor_InputEventChannel_TouchScreenConfig() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig& operator=(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig& operator=(ChannelDescriptor_InputEventChannel_TouchScreenConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_InputEventChannel_TouchScreenConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_InputEventChannel_TouchScreenConfig* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(
               &_ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ChannelDescriptor_InputEventChannel_TouchScreenConfig& a, ChannelDescriptor_InputEventChannel_TouchScreenConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_InputEventChannel_TouchScreenConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_InputEventChannel_TouchScreenConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_InputEventChannel_TouchScreenConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_InputEventChannel_TouchScreenConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from) {
    ChannelDescriptor_InputEventChannel_TouchScreenConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_InputEventChannel_TouchScreenConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig";
  }
  protected:
  explicit ChannelDescriptor_InputEventChannel_TouchScreenConfig(::google::protobuf::Arena* arena);
  ChannelDescriptor_InputEventChannel_TouchScreenConfig(::google::protobuf::Arena* arena, const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // required uint32 width = 1;
  bool has_width() const;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // required uint32 height = 2;
  bool has_height() const;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t width_;
    ::uint32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_GenericNotificationService final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.GenericNotificationService) */ {
 public:
  inline ChannelDescriptor_GenericNotificationService() : ChannelDescriptor_GenericNotificationService(nullptr) {}
  ~ChannelDescriptor_GenericNotificationService() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_GenericNotificationService(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_GenericNotificationService(const ChannelDescriptor_GenericNotificationService& from)
      : ChannelDescriptor_GenericNotificationService(nullptr, from) {}
  ChannelDescriptor_GenericNotificationService(ChannelDescriptor_GenericNotificationService&& from) noexcept
    : ChannelDescriptor_GenericNotificationService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_GenericNotificationService& operator=(const ChannelDescriptor_GenericNotificationService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_GenericNotificationService& operator=(ChannelDescriptor_GenericNotificationService&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_GenericNotificationService& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_GenericNotificationService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_GenericNotificationService*>(
               &_ChannelDescriptor_GenericNotificationService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ChannelDescriptor_GenericNotificationService& a, ChannelDescriptor_GenericNotificationService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_GenericNotificationService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_GenericNotificationService* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_GenericNotificationService* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_GenericNotificationService>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_GenericNotificationService& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_GenericNotificationService& from) {
    ChannelDescriptor_GenericNotificationService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_GenericNotificationService* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.GenericNotificationService";
  }
  protected:
  explicit ChannelDescriptor_GenericNotificationService(::google::protobuf::Arena* arena);
  ChannelDescriptor_GenericNotificationService(::google::protobuf::Arena* arena, const ChannelDescriptor_GenericNotificationService& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.GenericNotificationService)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_BluetoothService final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.BluetoothService) */ {
 public:
  inline ChannelDescriptor_BluetoothService() : ChannelDescriptor_BluetoothService(nullptr) {}
  ~ChannelDescriptor_BluetoothService() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_BluetoothService(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_BluetoothService(const ChannelDescriptor_BluetoothService& from)
      : ChannelDescriptor_BluetoothService(nullptr, from) {}
  ChannelDescriptor_BluetoothService(ChannelDescriptor_BluetoothService&& from) noexcept
    : ChannelDescriptor_BluetoothService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_BluetoothService& operator=(const ChannelDescriptor_BluetoothService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_BluetoothService& operator=(ChannelDescriptor_BluetoothService&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_BluetoothService& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_BluetoothService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_BluetoothService*>(
               &_ChannelDescriptor_BluetoothService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ChannelDescriptor_BluetoothService& a, ChannelDescriptor_BluetoothService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_BluetoothService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_BluetoothService* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_BluetoothService* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_BluetoothService>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_BluetoothService& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_BluetoothService& from) {
    ChannelDescriptor_BluetoothService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_BluetoothService* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.BluetoothService";
  }
  protected:
  explicit ChannelDescriptor_BluetoothService(::google::protobuf::Arena* arena);
  ChannelDescriptor_BluetoothService(::google::protobuf::Arena* arena, const ChannelDescriptor_BluetoothService& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedPairingMethodsFieldNumber = 2,
    kCarAddressFieldNumber = 1,
  };
  // repeated .HU.BluetoothPairingMethod supported_pairing_methods = 2;
  int supported_pairing_methods_size() const;
  private:
  int _internal_supported_pairing_methods_size() const;

  public:
  void clear_supported_pairing_methods() ;
  public:
  ::HU::BluetoothPairingMethod supported_pairing_methods(int index) const;
  void set_supported_pairing_methods(int index, ::HU::BluetoothPairingMethod value);
  void add_supported_pairing_methods(::HU::BluetoothPairingMethod value);
  const ::google::protobuf::RepeatedField<int>& supported_pairing_methods() const;
  ::google::protobuf::RepeatedField<int>* mutable_supported_pairing_methods();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_supported_pairing_methods() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_supported_pairing_methods();

  public:
  // required string car_address = 1;
  bool has_car_address() const;
  void clear_car_address() ;
  const std::string& car_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_car_address(Arg_&& arg, Args_... args);
  std::string* mutable_car_address();
  PROTOBUF_NODISCARD std::string* release_car_address();
  void set_allocated_car_address(std::string* value);

  private:
  const std::string& _internal_car_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car_address(
      const std::string& value);
  std::string* _internal_mutable_car_address();

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.BluetoothService)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> supported_pairing_methods_;
    ::google::protobuf::internal::ArenaStringPtr car_address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ButtonInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ButtonInfo) */ {
 public:
  inline ButtonInfo() : ButtonInfo(nullptr) {}
  ~ButtonInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ButtonInfo(::google::protobuf::internal::ConstantInitialized);

  inline ButtonInfo(const ButtonInfo& from)
      : ButtonInfo(nullptr, from) {}
  ButtonInfo(ButtonInfo&& from) noexcept
    : ButtonInfo() {
    *this = ::std::move(from);
  }

  inline ButtonInfo& operator=(const ButtonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonInfo& operator=(ButtonInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ButtonInfo* internal_default_instance() {
    return reinterpret_cast<const ButtonInfo*>(
               &_ButtonInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ButtonInfo& a, ButtonInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ButtonInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ButtonInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ButtonInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ButtonInfo& from) {
    ButtonInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ButtonInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ButtonInfo";
  }
  protected:
  explicit ButtonInfo(::google::protobuf::Arena* arena);
  ButtonInfo(::google::protobuf::Arena* arena, const ButtonInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodeFieldNumber = 1,
    kMetaFieldNumber = 3,
    kIsPressedFieldNumber = 2,
    kLongPressFieldNumber = 4,
  };
  // required uint32 scan_code = 1;
  bool has_scan_code() const;
  void clear_scan_code() ;
  ::uint32_t scan_code() const;
  void set_scan_code(::uint32_t value);

  private:
  ::uint32_t _internal_scan_code() const;
  void _internal_set_scan_code(::uint32_t value);

  public:
  // required uint32 meta = 3;
  bool has_meta() const;
  void clear_meta() ;
  ::uint32_t meta() const;
  void set_meta(::uint32_t value);

  private:
  ::uint32_t _internal_meta() const;
  void _internal_set_meta(::uint32_t value);

  public:
  // required bool is_pressed = 2;
  bool has_is_pressed() const;
  void clear_is_pressed() ;
  bool is_pressed() const;
  void set_is_pressed(bool value);

  private:
  bool _internal_is_pressed() const;
  void _internal_set_is_pressed(bool value);

  public:
  // required bool long_press = 4;
  bool has_long_press() const;
  void clear_long_press() ;
  bool long_press() const;
  void set_long_press(bool value);

  private:
  bool _internal_long_press() const;
  void _internal_set_long_press(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ButtonInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t scan_code_;
    ::uint32_t meta_;
    bool is_pressed_;
    bool long_press_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class BluetoothPairingResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.BluetoothPairingResponse) */ {
 public:
  inline BluetoothPairingResponse() : BluetoothPairingResponse(nullptr) {}
  ~BluetoothPairingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BluetoothPairingResponse(::google::protobuf::internal::ConstantInitialized);

  inline BluetoothPairingResponse(const BluetoothPairingResponse& from)
      : BluetoothPairingResponse(nullptr, from) {}
  BluetoothPairingResponse(BluetoothPairingResponse&& from) noexcept
    : BluetoothPairingResponse() {
    *this = ::std::move(from);
  }

  inline BluetoothPairingResponse& operator=(const BluetoothPairingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothPairingResponse& operator=(BluetoothPairingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BluetoothPairingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothPairingResponse* internal_default_instance() {
    return reinterpret_cast<const BluetoothPairingResponse*>(
               &_BluetoothPairingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(BluetoothPairingResponse& a, BluetoothPairingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothPairingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothPairingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothPairingResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BluetoothPairingResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BluetoothPairingResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BluetoothPairingResponse& from) {
    BluetoothPairingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BluetoothPairingResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.BluetoothPairingResponse";
  }
  protected:
  explicit BluetoothPairingResponse(::google::protobuf::Arena* arena);
  BluetoothPairingResponse(::google::protobuf::Arena* arena, const BluetoothPairingResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using PAIRING_STATUS = BluetoothPairingResponse_PAIRING_STATUS;
  static constexpr PAIRING_STATUS PAIRING_STATUS_1 = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_1;
  static constexpr PAIRING_STATUS PAIRING_STATUS_2 = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_2;
  static inline bool PAIRING_STATUS_IsValid(int value) {
    return BluetoothPairingResponse_PAIRING_STATUS_IsValid(value);
  }
  static constexpr PAIRING_STATUS PAIRING_STATUS_MIN = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MIN;
  static constexpr PAIRING_STATUS PAIRING_STATUS_MAX = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MAX;
  static constexpr int PAIRING_STATUS_ARRAYSIZE = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PAIRING_STATUS_descriptor() {
    return BluetoothPairingResponse_PAIRING_STATUS_descriptor();
  }
  template <typename T>
  static inline const std::string& PAIRING_STATUS_Name(T value) {
    return BluetoothPairingResponse_PAIRING_STATUS_Name(value);
  }
  static inline bool PAIRING_STATUS_Parse(absl::string_view name, PAIRING_STATUS* value) {
    return BluetoothPairingResponse_PAIRING_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAlreadyPairedFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional bool already_paired = 1;
  bool has_already_paired() const;
  void clear_already_paired() ;
  bool already_paired() const;
  void set_already_paired(bool value);

  private:
  bool _internal_already_paired() const;
  void _internal_set_already_paired(bool value);

  public:
  // optional .HU.BluetoothPairingResponse.PAIRING_STATUS status = 2;
  bool has_status() const;
  void clear_status() ;
  ::HU::BluetoothPairingResponse_PAIRING_STATUS status() const;
  void set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value);

  private:
  ::HU::BluetoothPairingResponse_PAIRING_STATUS _internal_status() const;
  void _internal_set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.BluetoothPairingResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool already_paired_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class BluetoothPairingRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.BluetoothPairingRequest) */ {
 public:
  inline BluetoothPairingRequest() : BluetoothPairingRequest(nullptr) {}
  ~BluetoothPairingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BluetoothPairingRequest(::google::protobuf::internal::ConstantInitialized);

  inline BluetoothPairingRequest(const BluetoothPairingRequest& from)
      : BluetoothPairingRequest(nullptr, from) {}
  BluetoothPairingRequest(BluetoothPairingRequest&& from) noexcept
    : BluetoothPairingRequest() {
    *this = ::std::move(from);
  }

  inline BluetoothPairingRequest& operator=(const BluetoothPairingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothPairingRequest& operator=(BluetoothPairingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BluetoothPairingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothPairingRequest* internal_default_instance() {
    return reinterpret_cast<const BluetoothPairingRequest*>(
               &_BluetoothPairingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(BluetoothPairingRequest& a, BluetoothPairingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothPairingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothPairingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothPairingRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BluetoothPairingRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BluetoothPairingRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BluetoothPairingRequest& from) {
    BluetoothPairingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BluetoothPairingRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.BluetoothPairingRequest";
  }
  protected:
  explicit BluetoothPairingRequest(::google::protobuf::Arena* arena);
  BluetoothPairingRequest(::google::protobuf::Arena* arena, const BluetoothPairingRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneAddressFieldNumber = 1,
    kPairingMethodFieldNumber = 2,
  };
  // required string phone_address = 1;
  bool has_phone_address() const;
  void clear_phone_address() ;
  const std::string& phone_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_address(Arg_&& arg, Args_... args);
  std::string* mutable_phone_address();
  PROTOBUF_NODISCARD std::string* release_phone_address();
  void set_allocated_phone_address(std::string* value);

  private:
  const std::string& _internal_phone_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_address(
      const std::string& value);
  std::string* _internal_mutable_phone_address();

  public:
  // optional .HU.BluetoothPairingMethod pairing_method = 2;
  bool has_pairing_method() const;
  void clear_pairing_method() ;
  ::HU::BluetoothPairingMethod pairing_method() const;
  void set_pairing_method(::HU::BluetoothPairingMethod value);

  private:
  ::HU::BluetoothPairingMethod _internal_pairing_method() const;
  void _internal_set_pairing_method(::HU::BluetoothPairingMethod value);

  public:
  // @@protoc_insertion_point(class_scope:HU.BluetoothPairingRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phone_address_;
    int pairing_method_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class BluetoothAuthData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.BluetoothAuthData) */ {
 public:
  inline BluetoothAuthData() : BluetoothAuthData(nullptr) {}
  ~BluetoothAuthData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BluetoothAuthData(::google::protobuf::internal::ConstantInitialized);

  inline BluetoothAuthData(const BluetoothAuthData& from)
      : BluetoothAuthData(nullptr, from) {}
  BluetoothAuthData(BluetoothAuthData&& from) noexcept
    : BluetoothAuthData() {
    *this = ::std::move(from);
  }

  inline BluetoothAuthData& operator=(const BluetoothAuthData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothAuthData& operator=(BluetoothAuthData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BluetoothAuthData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothAuthData* internal_default_instance() {
    return reinterpret_cast<const BluetoothAuthData*>(
               &_BluetoothAuthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(BluetoothAuthData& a, BluetoothAuthData& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothAuthData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothAuthData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothAuthData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BluetoothAuthData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BluetoothAuthData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BluetoothAuthData& from) {
    BluetoothAuthData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BluetoothAuthData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.BluetoothAuthData";
  }
  protected:
  explicit BluetoothAuthData(::google::protobuf::Arena* arena);
  BluetoothAuthData(::google::protobuf::Arena* arena, const BluetoothAuthData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional string data = 1;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:HU.BluetoothAuthData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class BindingResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.BindingResponse) */ {
 public:
  inline BindingResponse() : BindingResponse(nullptr) {}
  ~BindingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BindingResponse(::google::protobuf::internal::ConstantInitialized);

  inline BindingResponse(const BindingResponse& from)
      : BindingResponse(nullptr, from) {}
  BindingResponse(BindingResponse&& from) noexcept
    : BindingResponse() {
    *this = ::std::move(from);
  }

  inline BindingResponse& operator=(const BindingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingResponse& operator=(BindingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindingResponse* internal_default_instance() {
    return reinterpret_cast<const BindingResponse*>(
               &_BindingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BindingResponse& a, BindingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindingResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BindingResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BindingResponse& from) {
    BindingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BindingResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.BindingResponse";
  }
  protected:
  explicit BindingResponse(::google::protobuf::Arena* arena);
  BindingResponse(::google::protobuf::Arena* arena, const BindingResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  void clear_status() ;
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);

  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.BindingResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class BindingRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.BindingRequest) */ {
 public:
  inline BindingRequest() : BindingRequest(nullptr) {}
  ~BindingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BindingRequest(::google::protobuf::internal::ConstantInitialized);

  inline BindingRequest(const BindingRequest& from)
      : BindingRequest(nullptr, from) {}
  BindingRequest(BindingRequest&& from) noexcept
    : BindingRequest() {
    *this = ::std::move(from);
  }

  inline BindingRequest& operator=(const BindingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingRequest& operator=(BindingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindingRequest* internal_default_instance() {
    return reinterpret_cast<const BindingRequest*>(
               &_BindingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BindingRequest& a, BindingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindingRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BindingRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BindingRequest& from) {
    BindingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BindingRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.BindingRequest";
  }
  protected:
  explicit BindingRequest(::google::protobuf::Arena* arena);
  BindingRequest(::google::protobuf::Arena* arena, const BindingRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodesFieldNumber = 1,
  };
  // repeated int32 scan_codes = 1;
  int scan_codes_size() const;
  private:
  int _internal_scan_codes_size() const;

  public:
  void clear_scan_codes() ;
  ::int32_t scan_codes(int index) const;
  void set_scan_codes(int index, ::int32_t value);
  void add_scan_codes(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& scan_codes() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_scan_codes();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_scan_codes() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_scan_codes();

  public:
  // @@protoc_insertion_point(class_scope:HU.BindingRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> scan_codes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class AuthCompleteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.AuthCompleteResponse) */ {
 public:
  inline AuthCompleteResponse() : AuthCompleteResponse(nullptr) {}
  ~AuthCompleteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthCompleteResponse(::google::protobuf::internal::ConstantInitialized);

  inline AuthCompleteResponse(const AuthCompleteResponse& from)
      : AuthCompleteResponse(nullptr, from) {}
  AuthCompleteResponse(AuthCompleteResponse&& from) noexcept
    : AuthCompleteResponse() {
    *this = ::std::move(from);
  }

  inline AuthCompleteResponse& operator=(const AuthCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthCompleteResponse& operator=(AuthCompleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthCompleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthCompleteResponse* internal_default_instance() {
    return reinterpret_cast<const AuthCompleteResponse*>(
               &_AuthCompleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(AuthCompleteResponse& a, AuthCompleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthCompleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthCompleteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthCompleteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthCompleteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthCompleteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AuthCompleteResponse& from) {
    AuthCompleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AuthCompleteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.AuthCompleteResponse";
  }
  protected:
  explicit AuthCompleteResponse(::google::protobuf::Arena* arena);
  AuthCompleteResponse(::google::protobuf::Arena* arena, const AuthCompleteResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  void clear_status() ;
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);

  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.AuthCompleteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class AudioFocusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.AudioFocusResponse) */ {
 public:
  inline AudioFocusResponse() : AudioFocusResponse(nullptr) {}
  ~AudioFocusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioFocusResponse(::google::protobuf::internal::ConstantInitialized);

  inline AudioFocusResponse(const AudioFocusResponse& from)
      : AudioFocusResponse(nullptr, from) {}
  AudioFocusResponse(AudioFocusResponse&& from) noexcept
    : AudioFocusResponse() {
    *this = ::std::move(from);
  }

  inline AudioFocusResponse& operator=(const AudioFocusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFocusResponse& operator=(AudioFocusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioFocusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioFocusResponse* internal_default_instance() {
    return reinterpret_cast<const AudioFocusResponse*>(
               &_AudioFocusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(AudioFocusResponse& a, AudioFocusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFocusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFocusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioFocusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioFocusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AudioFocusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AudioFocusResponse& from) {
    AudioFocusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioFocusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.AudioFocusResponse";
  }
  protected:
  explicit AudioFocusResponse(::google::protobuf::Arena* arena);
  AudioFocusResponse(::google::protobuf::Arena* arena, const AudioFocusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AUDIO_FOCUS_STATE = AudioFocusResponse_AUDIO_FOCUS_STATE;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN_TRANSIENT = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_LOSS = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_LOSS_TRANSIENT = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY;
  static inline bool AUDIO_FOCUS_STATE_IsValid(int value) {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_IsValid(value);
  }
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_MIN = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MIN;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_MAX = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MAX;
  static constexpr int AUDIO_FOCUS_STATE_ARRAYSIZE = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AUDIO_FOCUS_STATE_descriptor() {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor();
  }
  template <typename T>
  static inline const std::string& AUDIO_FOCUS_STATE_Name(T value) {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_Name(value);
  }
  static inline bool AUDIO_FOCUS_STATE_Parse(absl::string_view name, AUDIO_FOCUS_STATE* value) {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // required .HU.AudioFocusResponse.AUDIO_FOCUS_STATE focus_type = 1;
  bool has_focus_type() const;
  void clear_focus_type() ;
  ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE focus_type() const;
  void set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value);

  private:
  ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE _internal_focus_type() const;
  void _internal_set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.AudioFocusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int focus_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class AudioFocusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.AudioFocusRequest) */ {
 public:
  inline AudioFocusRequest() : AudioFocusRequest(nullptr) {}
  ~AudioFocusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioFocusRequest(::google::protobuf::internal::ConstantInitialized);

  inline AudioFocusRequest(const AudioFocusRequest& from)
      : AudioFocusRequest(nullptr, from) {}
  AudioFocusRequest(AudioFocusRequest&& from) noexcept
    : AudioFocusRequest() {
    *this = ::std::move(from);
  }

  inline AudioFocusRequest& operator=(const AudioFocusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFocusRequest& operator=(AudioFocusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioFocusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioFocusRequest* internal_default_instance() {
    return reinterpret_cast<const AudioFocusRequest*>(
               &_AudioFocusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(AudioFocusRequest& a, AudioFocusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFocusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFocusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioFocusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioFocusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AudioFocusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AudioFocusRequest& from) {
    AudioFocusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioFocusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.AudioFocusRequest";
  }
  protected:
  explicit AudioFocusRequest(::google::protobuf::Arena* arena);
  AudioFocusRequest(::google::protobuf::Arena* arena, const AudioFocusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AUDIO_FOCUS = AudioFocusRequest_AUDIO_FOCUS;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_GAIN = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_GAIN_TRANSIENT = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_TRANSIENT;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_GAIN_NAVI = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_NAVI;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_RELEASE = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_RELEASE;
  static inline bool AUDIO_FOCUS_IsValid(int value) {
    return AudioFocusRequest_AUDIO_FOCUS_IsValid(value);
  }
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_MIN = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MIN;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_MAX = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MAX;
  static constexpr int AUDIO_FOCUS_ARRAYSIZE = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AUDIO_FOCUS_descriptor() {
    return AudioFocusRequest_AUDIO_FOCUS_descriptor();
  }
  template <typename T>
  static inline const std::string& AUDIO_FOCUS_Name(T value) {
    return AudioFocusRequest_AUDIO_FOCUS_Name(value);
  }
  static inline bool AUDIO_FOCUS_Parse(absl::string_view name, AUDIO_FOCUS* value) {
    return AudioFocusRequest_AUDIO_FOCUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // required .HU.AudioFocusRequest.AUDIO_FOCUS focus_type = 1;
  bool has_focus_type() const;
  void clear_focus_type() ;
  ::HU::AudioFocusRequest_AUDIO_FOCUS focus_type() const;
  void set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value);

  private:
  ::HU::AudioFocusRequest_AUDIO_FOCUS _internal_focus_type() const;
  void _internal_set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value);

  public:
  // @@protoc_insertion_point(class_scope:HU.AudioFocusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int focus_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class AudioCofig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.AudioCofig) */ {
 public:
  inline AudioCofig() : AudioCofig(nullptr) {}
  ~AudioCofig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioCofig(::google::protobuf::internal::ConstantInitialized);

  inline AudioCofig(const AudioCofig& from)
      : AudioCofig(nullptr, from) {}
  AudioCofig(AudioCofig&& from) noexcept
    : AudioCofig() {
    *this = ::std::move(from);
  }

  inline AudioCofig& operator=(const AudioCofig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioCofig& operator=(AudioCofig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioCofig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioCofig* internal_default_instance() {
    return reinterpret_cast<const AudioCofig*>(
               &_AudioCofig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AudioCofig& a, AudioCofig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioCofig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioCofig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioCofig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioCofig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AudioCofig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AudioCofig& from) {
    AudioCofig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioCofig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.AudioCofig";
  }
  protected:
  explicit AudioCofig(::google::protobuf::Arena* arena);
  AudioCofig(::google::protobuf::Arena* arena, const AudioCofig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateFieldNumber = 1,
    kBitDepthFieldNumber = 2,
    kChannelCountFieldNumber = 3,
  };
  // required uint32 sample_rate = 1;
  bool has_sample_rate() const;
  void clear_sample_rate() ;
  ::uint32_t sample_rate() const;
  void set_sample_rate(::uint32_t value);

  private:
  ::uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::uint32_t value);

  public:
  // required uint32 bit_depth = 2;
  bool has_bit_depth() const;
  void clear_bit_depth() ;
  ::uint32_t bit_depth() const;
  void set_bit_depth(::uint32_t value);

  private:
  ::uint32_t _internal_bit_depth() const;
  void _internal_set_bit_depth(::uint32_t value);

  public:
  // required uint32 channel_count = 3;
  bool has_channel_count() const;
  void clear_channel_count() ;
  ::uint32_t channel_count() const;
  void set_channel_count(::uint32_t value);

  private:
  ::uint32_t _internal_channel_count() const;
  void _internal_set_channel_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.AudioCofig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t sample_rate_;
    ::uint32_t bit_depth_;
    ::uint32_t channel_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class AbsoluteInputEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.AbsoluteInputEvent) */ {
 public:
  inline AbsoluteInputEvent() : AbsoluteInputEvent(nullptr) {}
  ~AbsoluteInputEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AbsoluteInputEvent(::google::protobuf::internal::ConstantInitialized);

  inline AbsoluteInputEvent(const AbsoluteInputEvent& from)
      : AbsoluteInputEvent(nullptr, from) {}
  AbsoluteInputEvent(AbsoluteInputEvent&& from) noexcept
    : AbsoluteInputEvent() {
    *this = ::std::move(from);
  }

  inline AbsoluteInputEvent& operator=(const AbsoluteInputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteInputEvent& operator=(AbsoluteInputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbsoluteInputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbsoluteInputEvent* internal_default_instance() {
    return reinterpret_cast<const AbsoluteInputEvent*>(
               &_AbsoluteInputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AbsoluteInputEvent& a, AbsoluteInputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteInputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteInputEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbsoluteInputEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbsoluteInputEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbsoluteInputEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AbsoluteInputEvent& from) {
    AbsoluteInputEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AbsoluteInputEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.AbsoluteInputEvent";
  }
  protected:
  explicit AbsoluteInputEvent(::google::protobuf::Arena* arena);
  AbsoluteInputEvent(::google::protobuf::Arena* arena, const AbsoluteInputEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional uint32 scan_code = 1;
  bool has_scan_code() const;
  void clear_scan_code() ;
  ::uint32_t scan_code() const;
  void set_scan_code(::uint32_t value);

  private:
  ::uint32_t _internal_scan_code() const;
  void _internal_set_scan_code(::uint32_t value);

  public:
  // optional int32 value = 2;
  bool has_value() const;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.AbsoluteInputEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t scan_code_;
    ::int32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class TouchInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.TouchInfo) */ {
 public:
  inline TouchInfo() : TouchInfo(nullptr) {}
  ~TouchInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TouchInfo(::google::protobuf::internal::ConstantInitialized);

  inline TouchInfo(const TouchInfo& from)
      : TouchInfo(nullptr, from) {}
  TouchInfo(TouchInfo&& from) noexcept
    : TouchInfo() {
    *this = ::std::move(from);
  }

  inline TouchInfo& operator=(const TouchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchInfo& operator=(TouchInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TouchInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TouchInfo* internal_default_instance() {
    return reinterpret_cast<const TouchInfo*>(
               &_TouchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TouchInfo& a, TouchInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TouchInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TouchInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TouchInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TouchInfo& from) {
    TouchInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TouchInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.TouchInfo";
  }
  protected:
  explicit TouchInfo(::google::protobuf::Arena* arena);
  TouchInfo(::google::protobuf::Arena* arena, const TouchInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Location = TouchInfo_Location;

  using TOUCH_ACTION = TouchInfo_TOUCH_ACTION;
  static constexpr TOUCH_ACTION TOUCH_ACTION_PRESS = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_PRESS;
  static constexpr TOUCH_ACTION TOUCH_ACTION_RELEASE = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_RELEASE;
  static constexpr TOUCH_ACTION TOUCH_ACTION_DRAG = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_DRAG;
  static inline bool TOUCH_ACTION_IsValid(int value) {
    return TouchInfo_TOUCH_ACTION_IsValid(value);
  }
  static constexpr TOUCH_ACTION TOUCH_ACTION_MIN = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MIN;
  static constexpr TOUCH_ACTION TOUCH_ACTION_MAX = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MAX;
  static constexpr int TOUCH_ACTION_ARRAYSIZE = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TOUCH_ACTION_descriptor() {
    return TouchInfo_TOUCH_ACTION_descriptor();
  }
  template <typename T>
  static inline const std::string& TOUCH_ACTION_Name(T value) {
    return TouchInfo_TOUCH_ACTION_Name(value);
  }
  static inline bool TOUCH_ACTION_Parse(absl::string_view name, TOUCH_ACTION* value) {
    return TouchInfo_TOUCH_ACTION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kActionIndexFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // repeated .HU.TouchInfo.Location location = 1;
  int location_size() const;
  private:
  int _internal_location_size() const;

  public:
  void clear_location() ;
  ::HU::TouchInfo_Location* mutable_location(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::TouchInfo_Location >*
      mutable_location();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::TouchInfo_Location>& _internal_location() const;
  ::google::protobuf::RepeatedPtrField<::HU::TouchInfo_Location>* _internal_mutable_location();
  public:
  const ::HU::TouchInfo_Location& location(int index) const;
  ::HU::TouchInfo_Location* add_location();
  const ::google::protobuf::RepeatedPtrField< ::HU::TouchInfo_Location >&
      location() const;
  // optional uint32 action_index = 2;
  bool has_action_index() const;
  void clear_action_index() ;
  ::uint32_t action_index() const;
  void set_action_index(::uint32_t value);

  private:
  ::uint32_t _internal_action_index() const;
  void _internal_set_action_index(::uint32_t value);

  public:
  // required .HU.TouchInfo.TOUCH_ACTION action = 3;
  bool has_action() const;
  void clear_action() ;
  ::HU::TouchInfo_TOUCH_ACTION action() const;
  void set_action(::HU::TouchInfo_TOUCH_ACTION value);

  private:
  ::HU::TouchInfo_TOUCH_ACTION _internal_action() const;
  void _internal_set_action(::HU::TouchInfo_TOUCH_ACTION value);

  public:
  // @@protoc_insertion_point(class_scope:HU.TouchInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::HU::TouchInfo_Location > location_;
    ::uint32_t action_index_;
    int action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class SensorEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent) */ {
 public:
  inline SensorEvent() : SensorEvent(nullptr) {}
  ~SensorEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorEvent(::google::protobuf::internal::ConstantInitialized);

  inline SensorEvent(const SensorEvent& from)
      : SensorEvent(nullptr, from) {}
  SensorEvent(SensorEvent&& from) noexcept
    : SensorEvent() {
    *this = ::std::move(from);
  }

  inline SensorEvent& operator=(const SensorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent& operator=(SensorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorEvent* internal_default_instance() {
    return reinterpret_cast<const SensorEvent*>(
               &_SensorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SensorEvent& a, SensorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorEvent& from) {
    SensorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.SensorEvent";
  }
  protected:
  explicit SensorEvent(::google::protobuf::Arena* arena);
  SensorEvent(::google::protobuf::Arena* arena, const SensorEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LocationData = SensorEvent_LocationData;
  using NightMode = SensorEvent_NightMode;
  using RPM = SensorEvent_RPM;
  using FuelLevel = SensorEvent_FuelLevel;
  using DrivingStatus = SensorEvent_DrivingStatus;
  using DeadReckoning = SensorEvent_DeadReckoning;
  using CompassData = SensorEvent_CompassData;
  using SpeedData = SensorEvent_SpeedData;
  using OdometerData = SensorEvent_OdometerData;
  using ParkingBreak = SensorEvent_ParkingBreak;
  using Passenger = SensorEvent_Passenger;
  using Diagnostics = SensorEvent_Diagnostics;
  using Environment = SensorEvent_Environment;
  using HVAC = SensorEvent_HVAC;
  using Accel = SensorEvent_Accel;
  using Gyro = SensorEvent_Gyro;
  using Door = SensorEvent_Door;
  using Light = SensorEvent_Light;
  using GearData = SensorEvent_GearData;

  // accessors -------------------------------------------------------

  enum : int {
    kLocationDataFieldNumber = 1,
    kCompassDataFieldNumber = 2,
    kSpeedDataFieldNumber = 3,
    kRpmFieldNumber = 4,
    kOdometerDataFieldNumber = 5,
    kFuelDataFieldNumber = 6,
    kParkingbrakeDataFieldNumber = 7,
    kGearDataFieldNumber = 8,
    kDiagnosticsDataFieldNumber = 9,
    kNightModeFieldNumber = 10,
    kEnviormentDataFieldNumber = 11,
    kHvacDataFieldNumber = 12,
    kDrivingStatusFieldNumber = 13,
    kDeadReckoningFieldNumber = 14,
    kPassengerDataFieldNumber = 15,
    kDoorDataFieldNumber = 16,
    kLightDataFieldNumber = 17,
    kAccelDataFieldNumber = 19,
    kGyroDataFieldNumber = 20,
  };
  // repeated .HU.SensorEvent.LocationData location_data = 1;
  int location_data_size() const;
  private:
  int _internal_location_data_size() const;

  public:
  void clear_location_data() ;
  ::HU::SensorEvent_LocationData* mutable_location_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_LocationData >*
      mutable_location_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_LocationData>& _internal_location_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_LocationData>* _internal_mutable_location_data();
  public:
  const ::HU::SensorEvent_LocationData& location_data(int index) const;
  ::HU::SensorEvent_LocationData* add_location_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_LocationData >&
      location_data() const;
  // repeated .HU.SensorEvent.CompassData compass_data = 2;
  int compass_data_size() const;
  private:
  int _internal_compass_data_size() const;

  public:
  void clear_compass_data() ;
  ::HU::SensorEvent_CompassData* mutable_compass_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_CompassData >*
      mutable_compass_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_CompassData>& _internal_compass_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_CompassData>* _internal_mutable_compass_data();
  public:
  const ::HU::SensorEvent_CompassData& compass_data(int index) const;
  ::HU::SensorEvent_CompassData* add_compass_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_CompassData >&
      compass_data() const;
  // repeated .HU.SensorEvent.SpeedData speed_data = 3;
  int speed_data_size() const;
  private:
  int _internal_speed_data_size() const;

  public:
  void clear_speed_data() ;
  ::HU::SensorEvent_SpeedData* mutable_speed_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_SpeedData >*
      mutable_speed_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_SpeedData>& _internal_speed_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_SpeedData>* _internal_mutable_speed_data();
  public:
  const ::HU::SensorEvent_SpeedData& speed_data(int index) const;
  ::HU::SensorEvent_SpeedData* add_speed_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_SpeedData >&
      speed_data() const;
  // repeated .HU.SensorEvent.RPM rpm = 4;
  int rpm_size() const;
  private:
  int _internal_rpm_size() const;

  public:
  void clear_rpm() ;
  ::HU::SensorEvent_RPM* mutable_rpm(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_RPM >*
      mutable_rpm();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_RPM>& _internal_rpm() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_RPM>* _internal_mutable_rpm();
  public:
  const ::HU::SensorEvent_RPM& rpm(int index) const;
  ::HU::SensorEvent_RPM* add_rpm();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_RPM >&
      rpm() const;
  // repeated .HU.SensorEvent.OdometerData odometer_data = 5;
  int odometer_data_size() const;
  private:
  int _internal_odometer_data_size() const;

  public:
  void clear_odometer_data() ;
  ::HU::SensorEvent_OdometerData* mutable_odometer_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_OdometerData >*
      mutable_odometer_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_OdometerData>& _internal_odometer_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_OdometerData>* _internal_mutable_odometer_data();
  public:
  const ::HU::SensorEvent_OdometerData& odometer_data(int index) const;
  ::HU::SensorEvent_OdometerData* add_odometer_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_OdometerData >&
      odometer_data() const;
  // repeated .HU.SensorEvent.FuelLevel fuel_data = 6;
  int fuel_data_size() const;
  private:
  int _internal_fuel_data_size() const;

  public:
  void clear_fuel_data() ;
  ::HU::SensorEvent_FuelLevel* mutable_fuel_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_FuelLevel >*
      mutable_fuel_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_FuelLevel>& _internal_fuel_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_FuelLevel>* _internal_mutable_fuel_data();
  public:
  const ::HU::SensorEvent_FuelLevel& fuel_data(int index) const;
  ::HU::SensorEvent_FuelLevel* add_fuel_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_FuelLevel >&
      fuel_data() const;
  // repeated .HU.SensorEvent.ParkingBreak parkingbrake_data = 7;
  int parkingbrake_data_size() const;
  private:
  int _internal_parkingbrake_data_size() const;

  public:
  void clear_parkingbrake_data() ;
  ::HU::SensorEvent_ParkingBreak* mutable_parkingbrake_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak >*
      mutable_parkingbrake_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_ParkingBreak>& _internal_parkingbrake_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_ParkingBreak>* _internal_mutable_parkingbrake_data();
  public:
  const ::HU::SensorEvent_ParkingBreak& parkingbrake_data(int index) const;
  ::HU::SensorEvent_ParkingBreak* add_parkingbrake_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak >&
      parkingbrake_data() const;
  // repeated .HU.SensorEvent.GearData gear_data = 8;
  int gear_data_size() const;
  private:
  int _internal_gear_data_size() const;

  public:
  void clear_gear_data() ;
  ::HU::SensorEvent_GearData* mutable_gear_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_GearData >*
      mutable_gear_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_GearData>& _internal_gear_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_GearData>* _internal_mutable_gear_data();
  public:
  const ::HU::SensorEvent_GearData& gear_data(int index) const;
  ::HU::SensorEvent_GearData* add_gear_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_GearData >&
      gear_data() const;
  // repeated .HU.SensorEvent.Diagnostics diagnostics_data = 9;
  int diagnostics_data_size() const;
  private:
  int _internal_diagnostics_data_size() const;

  public:
  void clear_diagnostics_data() ;
  ::HU::SensorEvent_Diagnostics* mutable_diagnostics_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Diagnostics >*
      mutable_diagnostics_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Diagnostics>& _internal_diagnostics_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Diagnostics>* _internal_mutable_diagnostics_data();
  public:
  const ::HU::SensorEvent_Diagnostics& diagnostics_data(int index) const;
  ::HU::SensorEvent_Diagnostics* add_diagnostics_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Diagnostics >&
      diagnostics_data() const;
  // repeated .HU.SensorEvent.NightMode night_mode = 10;
  int night_mode_size() const;
  private:
  int _internal_night_mode_size() const;

  public:
  void clear_night_mode() ;
  ::HU::SensorEvent_NightMode* mutable_night_mode(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_NightMode >*
      mutable_night_mode();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_NightMode>& _internal_night_mode() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_NightMode>* _internal_mutable_night_mode();
  public:
  const ::HU::SensorEvent_NightMode& night_mode(int index) const;
  ::HU::SensorEvent_NightMode* add_night_mode();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_NightMode >&
      night_mode() const;
  // repeated .HU.SensorEvent.Environment enviorment_data = 11;
  int enviorment_data_size() const;
  private:
  int _internal_enviorment_data_size() const;

  public:
  void clear_enviorment_data() ;
  ::HU::SensorEvent_Environment* mutable_enviorment_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Environment >*
      mutable_enviorment_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Environment>& _internal_enviorment_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Environment>* _internal_mutable_enviorment_data();
  public:
  const ::HU::SensorEvent_Environment& enviorment_data(int index) const;
  ::HU::SensorEvent_Environment* add_enviorment_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Environment >&
      enviorment_data() const;
  // repeated .HU.SensorEvent.HVAC hvac_data = 12;
  int hvac_data_size() const;
  private:
  int _internal_hvac_data_size() const;

  public:
  void clear_hvac_data() ;
  ::HU::SensorEvent_HVAC* mutable_hvac_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_HVAC >*
      mutable_hvac_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_HVAC>& _internal_hvac_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_HVAC>* _internal_mutable_hvac_data();
  public:
  const ::HU::SensorEvent_HVAC& hvac_data(int index) const;
  ::HU::SensorEvent_HVAC* add_hvac_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_HVAC >&
      hvac_data() const;
  // repeated .HU.SensorEvent.DrivingStatus driving_status = 13;
  int driving_status_size() const;
  private:
  int _internal_driving_status_size() const;

  public:
  void clear_driving_status() ;
  ::HU::SensorEvent_DrivingStatus* mutable_driving_status(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus >*
      mutable_driving_status();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DrivingStatus>& _internal_driving_status() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DrivingStatus>* _internal_mutable_driving_status();
  public:
  const ::HU::SensorEvent_DrivingStatus& driving_status(int index) const;
  ::HU::SensorEvent_DrivingStatus* add_driving_status();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus >&
      driving_status() const;
  // repeated .HU.SensorEvent.DeadReckoning dead_reckoning = 14;
  int dead_reckoning_size() const;
  private:
  int _internal_dead_reckoning_size() const;

  public:
  void clear_dead_reckoning() ;
  ::HU::SensorEvent_DeadReckoning* mutable_dead_reckoning(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning >*
      mutable_dead_reckoning();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DeadReckoning>& _internal_dead_reckoning() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DeadReckoning>* _internal_mutable_dead_reckoning();
  public:
  const ::HU::SensorEvent_DeadReckoning& dead_reckoning(int index) const;
  ::HU::SensorEvent_DeadReckoning* add_dead_reckoning();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning >&
      dead_reckoning() const;
  // repeated .HU.SensorEvent.Passenger passenger_data = 15;
  int passenger_data_size() const;
  private:
  int _internal_passenger_data_size() const;

  public:
  void clear_passenger_data() ;
  ::HU::SensorEvent_Passenger* mutable_passenger_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Passenger >*
      mutable_passenger_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Passenger>& _internal_passenger_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Passenger>* _internal_mutable_passenger_data();
  public:
  const ::HU::SensorEvent_Passenger& passenger_data(int index) const;
  ::HU::SensorEvent_Passenger* add_passenger_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Passenger >&
      passenger_data() const;
  // repeated .HU.SensorEvent.Door door_data = 16;
  int door_data_size() const;
  private:
  int _internal_door_data_size() const;

  public:
  void clear_door_data() ;
  ::HU::SensorEvent_Door* mutable_door_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Door >*
      mutable_door_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Door>& _internal_door_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Door>* _internal_mutable_door_data();
  public:
  const ::HU::SensorEvent_Door& door_data(int index) const;
  ::HU::SensorEvent_Door* add_door_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Door >&
      door_data() const;
  // repeated .HU.SensorEvent.Light light_data = 17;
  int light_data_size() const;
  private:
  int _internal_light_data_size() const;

  public:
  void clear_light_data() ;
  ::HU::SensorEvent_Light* mutable_light_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Light >*
      mutable_light_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Light>& _internal_light_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Light>* _internal_mutable_light_data();
  public:
  const ::HU::SensorEvent_Light& light_data(int index) const;
  ::HU::SensorEvent_Light* add_light_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Light >&
      light_data() const;
  // repeated .HU.SensorEvent.Accel accel_data = 19;
  int accel_data_size() const;
  private:
  int _internal_accel_data_size() const;

  public:
  void clear_accel_data() ;
  ::HU::SensorEvent_Accel* mutable_accel_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Accel >*
      mutable_accel_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Accel>& _internal_accel_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Accel>* _internal_mutable_accel_data();
  public:
  const ::HU::SensorEvent_Accel& accel_data(int index) const;
  ::HU::SensorEvent_Accel* add_accel_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Accel >&
      accel_data() const;
  // repeated .HU.SensorEvent.Gyro gyro_data = 20;
  int gyro_data_size() const;
  private:
  int _internal_gyro_data_size() const;

  public:
  void clear_gyro_data() ;
  ::HU::SensorEvent_Gyro* mutable_gyro_data(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Gyro >*
      mutable_gyro_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Gyro>& _internal_gyro_data() const;
  ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Gyro>* _internal_mutable_gyro_data();
  public:
  const ::HU::SensorEvent_Gyro& gyro_data(int index) const;
  ::HU::SensorEvent_Gyro* add_gyro_data();
  const ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Gyro >&
      gyro_data() const;
  // @@protoc_insertion_point(class_scope:HU.SensorEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 19,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_LocationData > location_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_CompassData > compass_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_SpeedData > speed_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_RPM > rpm_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_OdometerData > odometer_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_FuelLevel > fuel_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak > parkingbrake_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_GearData > gear_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Diagnostics > diagnostics_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_NightMode > night_mode_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Environment > enviorment_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_HVAC > hvac_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus > driving_status_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning > dead_reckoning_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Passenger > passenger_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Door > door_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Light > light_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Accel > accel_data_;
    ::google::protobuf::RepeatedPtrField< ::HU::SensorEvent_Gyro > gyro_data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class RelativeInputEventWrapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.RelativeInputEventWrapper) */ {
 public:
  inline RelativeInputEventWrapper() : RelativeInputEventWrapper(nullptr) {}
  ~RelativeInputEventWrapper() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelativeInputEventWrapper(::google::protobuf::internal::ConstantInitialized);

  inline RelativeInputEventWrapper(const RelativeInputEventWrapper& from)
      : RelativeInputEventWrapper(nullptr, from) {}
  RelativeInputEventWrapper(RelativeInputEventWrapper&& from) noexcept
    : RelativeInputEventWrapper() {
    *this = ::std::move(from);
  }

  inline RelativeInputEventWrapper& operator=(const RelativeInputEventWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelativeInputEventWrapper& operator=(RelativeInputEventWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelativeInputEventWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelativeInputEventWrapper* internal_default_instance() {
    return reinterpret_cast<const RelativeInputEventWrapper*>(
               &_RelativeInputEventWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RelativeInputEventWrapper& a, RelativeInputEventWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(RelativeInputEventWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelativeInputEventWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelativeInputEventWrapper* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelativeInputEventWrapper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelativeInputEventWrapper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RelativeInputEventWrapper& from) {
    RelativeInputEventWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RelativeInputEventWrapper* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.RelativeInputEventWrapper";
  }
  protected:
  explicit RelativeInputEventWrapper(::google::protobuf::Arena* arena);
  RelativeInputEventWrapper(::google::protobuf::Arena* arena, const RelativeInputEventWrapper& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // required .HU.RelativeInputEvent event = 1;
  bool has_event() const;
  void clear_event() ;
  const ::HU::RelativeInputEvent& event() const;
  PROTOBUF_NODISCARD ::HU::RelativeInputEvent* release_event();
  ::HU::RelativeInputEvent* mutable_event();
  void set_allocated_event(::HU::RelativeInputEvent* value);
  void unsafe_arena_set_allocated_event(::HU::RelativeInputEvent* value);
  ::HU::RelativeInputEvent* unsafe_arena_release_event();

  private:
  const ::HU::RelativeInputEvent& _internal_event() const;
  ::HU::RelativeInputEvent* _internal_mutable_event();

  public:
  // @@protoc_insertion_point(class_scope:HU.RelativeInputEventWrapper)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::HU::RelativeInputEvent* event_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class PhoneStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.PhoneStatus) */ {
 public:
  inline PhoneStatus() : PhoneStatus(nullptr) {}
  ~PhoneStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PhoneStatus(::google::protobuf::internal::ConstantInitialized);

  inline PhoneStatus(const PhoneStatus& from)
      : PhoneStatus(nullptr, from) {}
  PhoneStatus(PhoneStatus&& from) noexcept
    : PhoneStatus() {
    *this = ::std::move(from);
  }

  inline PhoneStatus& operator=(const PhoneStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneStatus& operator=(PhoneStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhoneStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhoneStatus* internal_default_instance() {
    return reinterpret_cast<const PhoneStatus*>(
               &_PhoneStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(PhoneStatus& a, PhoneStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhoneStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhoneStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PhoneStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PhoneStatus& from) {
    PhoneStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PhoneStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.PhoneStatus";
  }
  protected:
  explicit PhoneStatus(::google::protobuf::Arena* arena);
  PhoneStatus(::google::protobuf::Arena* arena, const PhoneStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Call = PhoneStatus_Call;

  using PHONE_STATE = PhoneStatus_PHONE_STATE;
  static constexpr PHONE_STATE PHONE_STATE_IN_CALL = PhoneStatus_PHONE_STATE_PHONE_STATE_IN_CALL;
  static constexpr PHONE_STATE PHONE_STATE_ON_HOLD = PhoneStatus_PHONE_STATE_PHONE_STATE_ON_HOLD;
  static constexpr PHONE_STATE PHONE_STATE_HANGINGUP = PhoneStatus_PHONE_STATE_PHONE_STATE_HANGINGUP;
  static constexpr PHONE_STATE PHONE_STATE_INCOMING = PhoneStatus_PHONE_STATE_PHONE_STATE_INCOMING;
  static constexpr PHONE_STATE PHONE_STATE_UNKNOWN_5 = PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_5;
  static constexpr PHONE_STATE PHONE_STATE_UNKNOWN_6 = PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_6;
  static inline bool PHONE_STATE_IsValid(int value) {
    return PhoneStatus_PHONE_STATE_IsValid(value);
  }
  static constexpr PHONE_STATE PHONE_STATE_MIN = PhoneStatus_PHONE_STATE_PHONE_STATE_MIN;
  static constexpr PHONE_STATE PHONE_STATE_MAX = PhoneStatus_PHONE_STATE_PHONE_STATE_MAX;
  static constexpr int PHONE_STATE_ARRAYSIZE = PhoneStatus_PHONE_STATE_PHONE_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PHONE_STATE_descriptor() {
    return PhoneStatus_PHONE_STATE_descriptor();
  }
  template <typename T>
  static inline const std::string& PHONE_STATE_Name(T value) {
    return PhoneStatus_PHONE_STATE_Name(value);
  }
  static inline bool PHONE_STATE_Parse(absl::string_view name, PHONE_STATE* value) {
    return PhoneStatus_PHONE_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCallsFieldNumber = 1,
    kSignalStrengthFieldNumber = 2,
  };
  // repeated .HU.PhoneStatus.Call calls = 1;
  int calls_size() const;
  private:
  int _internal_calls_size() const;

  public:
  void clear_calls() ;
  ::HU::PhoneStatus_Call* mutable_calls(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::PhoneStatus_Call >*
      mutable_calls();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::PhoneStatus_Call>& _internal_calls() const;
  ::google::protobuf::RepeatedPtrField<::HU::PhoneStatus_Call>* _internal_mutable_calls();
  public:
  const ::HU::PhoneStatus_Call& calls(int index) const;
  ::HU::PhoneStatus_Call* add_calls();
  const ::google::protobuf::RepeatedPtrField< ::HU::PhoneStatus_Call >&
      calls() const;
  // optional uint32 signal_strength = 2;
  bool has_signal_strength() const;
  void clear_signal_strength() ;
  ::uint32_t signal_strength() const;
  void set_signal_strength(::uint32_t value);

  private:
  ::uint32_t _internal_signal_strength() const;
  void _internal_set_signal_strength(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.PhoneStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::HU::PhoneStatus_Call > calls_;
    ::uint32_t signal_strength_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_SensorChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.SensorChannel) */ {
 public:
  inline ChannelDescriptor_SensorChannel() : ChannelDescriptor_SensorChannel(nullptr) {}
  ~ChannelDescriptor_SensorChannel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_SensorChannel(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_SensorChannel(const ChannelDescriptor_SensorChannel& from)
      : ChannelDescriptor_SensorChannel(nullptr, from) {}
  ChannelDescriptor_SensorChannel(ChannelDescriptor_SensorChannel&& from) noexcept
    : ChannelDescriptor_SensorChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_SensorChannel& operator=(const ChannelDescriptor_SensorChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_SensorChannel& operator=(ChannelDescriptor_SensorChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_SensorChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_SensorChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_SensorChannel*>(
               &_ChannelDescriptor_SensorChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ChannelDescriptor_SensorChannel& a, ChannelDescriptor_SensorChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_SensorChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_SensorChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_SensorChannel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_SensorChannel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_SensorChannel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_SensorChannel& from) {
    ChannelDescriptor_SensorChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_SensorChannel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.SensorChannel";
  }
  protected:
  explicit ChannelDescriptor_SensorChannel(::google::protobuf::Arena* arena);
  ChannelDescriptor_SensorChannel(::google::protobuf::Arena* arena, const ChannelDescriptor_SensorChannel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Sensor = ChannelDescriptor_SensorChannel_Sensor;

  // accessors -------------------------------------------------------

  enum : int {
    kSensorListFieldNumber = 1,
  };
  // repeated .HU.ChannelDescriptor.SensorChannel.Sensor sensor_list = 1;
  int sensor_list_size() const;
  private:
  int _internal_sensor_list_size() const;

  public:
  void clear_sensor_list() ;
  ::HU::ChannelDescriptor_SensorChannel_Sensor* mutable_sensor_list(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor >*
      mutable_sensor_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_SensorChannel_Sensor>& _internal_sensor_list() const;
  ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_SensorChannel_Sensor>* _internal_mutable_sensor_list();
  public:
  const ::HU::ChannelDescriptor_SensorChannel_Sensor& sensor_list(int index) const;
  ::HU::ChannelDescriptor_SensorChannel_Sensor* add_sensor_list();
  const ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor >&
      sensor_list() const;
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.SensorChannel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor > sensor_list_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_OutputStreamChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.OutputStreamChannel) */ {
 public:
  inline ChannelDescriptor_OutputStreamChannel() : ChannelDescriptor_OutputStreamChannel(nullptr) {}
  ~ChannelDescriptor_OutputStreamChannel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_OutputStreamChannel(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_OutputStreamChannel(const ChannelDescriptor_OutputStreamChannel& from)
      : ChannelDescriptor_OutputStreamChannel(nullptr, from) {}
  ChannelDescriptor_OutputStreamChannel(ChannelDescriptor_OutputStreamChannel&& from) noexcept
    : ChannelDescriptor_OutputStreamChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_OutputStreamChannel& operator=(const ChannelDescriptor_OutputStreamChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_OutputStreamChannel& operator=(ChannelDescriptor_OutputStreamChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_OutputStreamChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_OutputStreamChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_OutputStreamChannel*>(
               &_ChannelDescriptor_OutputStreamChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ChannelDescriptor_OutputStreamChannel& a, ChannelDescriptor_OutputStreamChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_OutputStreamChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_OutputStreamChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_OutputStreamChannel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_OutputStreamChannel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_OutputStreamChannel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_OutputStreamChannel& from) {
    ChannelDescriptor_OutputStreamChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_OutputStreamChannel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.OutputStreamChannel";
  }
  protected:
  explicit ChannelDescriptor_OutputStreamChannel(::google::protobuf::Arena* arena);
  ChannelDescriptor_OutputStreamChannel(::google::protobuf::Arena* arena, const ChannelDescriptor_OutputStreamChannel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VideoConfig = ChannelDescriptor_OutputStreamChannel_VideoConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigsFieldNumber = 3,
    kVideoConfigsFieldNumber = 4,
    kAvailableWhileInCallFieldNumber = 5,
    kTypeFieldNumber = 1,
    kAudioTypeFieldNumber = 2,
  };
  // repeated .HU.AudioCofig audio_configs = 3;
  int audio_configs_size() const;
  private:
  int _internal_audio_configs_size() const;

  public:
  void clear_audio_configs() ;
  ::HU::AudioCofig* mutable_audio_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::AudioCofig >*
      mutable_audio_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::AudioCofig>& _internal_audio_configs() const;
  ::google::protobuf::RepeatedPtrField<::HU::AudioCofig>* _internal_mutable_audio_configs();
  public:
  const ::HU::AudioCofig& audio_configs(int index) const;
  ::HU::AudioCofig* add_audio_configs();
  const ::google::protobuf::RepeatedPtrField< ::HU::AudioCofig >&
      audio_configs() const;
  // repeated .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig video_configs = 4;
  int video_configs_size() const;
  private:
  int _internal_video_configs_size() const;

  public:
  void clear_video_configs() ;
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* mutable_video_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig >*
      mutable_video_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>& _internal_video_configs() const;
  ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>* _internal_mutable_video_configs();
  public:
  const ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig& video_configs(int index) const;
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* add_video_configs();
  const ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig >&
      video_configs() const;
  // optional bool available_while_in_call = 5;
  bool has_available_while_in_call() const;
  void clear_available_while_in_call() ;
  bool available_while_in_call() const;
  void set_available_while_in_call(bool value);

  private:
  bool _internal_available_while_in_call() const;
  void _internal_set_available_while_in_call(bool value);

  public:
  // required .HU.STREAM_TYPE type = 1;
  bool has_type() const;
  void clear_type() ;
  ::HU::STREAM_TYPE type() const;
  void set_type(::HU::STREAM_TYPE value);

  private:
  ::HU::STREAM_TYPE _internal_type() const;
  void _internal_set_type(::HU::STREAM_TYPE value);

  public:
  // optional .HU.AUDIO_TYPE audio_type = 2;
  bool has_audio_type() const;
  void clear_audio_type() ;
  ::HU::AUDIO_TYPE audio_type() const;
  void set_audio_type(::HU::AUDIO_TYPE value);

  private:
  ::HU::AUDIO_TYPE _internal_audio_type() const;
  void _internal_set_audio_type(::HU::AUDIO_TYPE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.OutputStreamChannel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::HU::AudioCofig > audio_configs_;
    ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig > video_configs_;
    bool available_while_in_call_;
    int type_;
    int audio_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_NavigationStatusService final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.NavigationStatusService) */ {
 public:
  inline ChannelDescriptor_NavigationStatusService() : ChannelDescriptor_NavigationStatusService(nullptr) {}
  ~ChannelDescriptor_NavigationStatusService() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_NavigationStatusService(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_NavigationStatusService(const ChannelDescriptor_NavigationStatusService& from)
      : ChannelDescriptor_NavigationStatusService(nullptr, from) {}
  ChannelDescriptor_NavigationStatusService(ChannelDescriptor_NavigationStatusService&& from) noexcept
    : ChannelDescriptor_NavigationStatusService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_NavigationStatusService& operator=(const ChannelDescriptor_NavigationStatusService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_NavigationStatusService& operator=(ChannelDescriptor_NavigationStatusService&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_NavigationStatusService& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_NavigationStatusService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_NavigationStatusService*>(
               &_ChannelDescriptor_NavigationStatusService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ChannelDescriptor_NavigationStatusService& a, ChannelDescriptor_NavigationStatusService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_NavigationStatusService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_NavigationStatusService* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_NavigationStatusService* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_NavigationStatusService>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_NavigationStatusService& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_NavigationStatusService& from) {
    ChannelDescriptor_NavigationStatusService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_NavigationStatusService* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.NavigationStatusService";
  }
  protected:
  explicit ChannelDescriptor_NavigationStatusService(::google::protobuf::Arena* arena);
  ChannelDescriptor_NavigationStatusService(::google::protobuf::Arena* arena, const ChannelDescriptor_NavigationStatusService& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ImageOptions = ChannelDescriptor_NavigationStatusService_ImageOptions;

  using CLUSTER_TYPE = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE;
  static constexpr CLUSTER_TYPE CUSTOM_IMAGES_SUPPORTED = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CUSTOM_IMAGES_SUPPORTED;
  static constexpr CLUSTER_TYPE IMAGE_CODES_ONLY = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IMAGE_CODES_ONLY;
  static inline bool CLUSTER_TYPE_IsValid(int value) {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IsValid(value);
  }
  static constexpr CLUSTER_TYPE CLUSTER_TYPE_MIN = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MIN;
  static constexpr CLUSTER_TYPE CLUSTER_TYPE_MAX = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MAX;
  static constexpr int CLUSTER_TYPE_ARRAYSIZE = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CLUSTER_TYPE_descriptor() {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor();
  }
  template <typename T>
  static inline const std::string& CLUSTER_TYPE_Name(T value) {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name(value);
  }
  static inline bool CLUSTER_TYPE_Parse(absl::string_view name, CLUSTER_TYPE* value) {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImageOptionsFieldNumber = 3,
    kMinimumIntervalMsFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .HU.ChannelDescriptor.NavigationStatusService.ImageOptions image_options = 3;
  bool has_image_options() const;
  void clear_image_options() ;
  const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& image_options() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* release_image_options();
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* mutable_image_options();
  void set_allocated_image_options(::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* value);
  void unsafe_arena_set_allocated_image_options(::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* value);
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* unsafe_arena_release_image_options();

  private:
  const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& _internal_image_options() const;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* _internal_mutable_image_options();

  public:
  // required uint32 minimum_interval_ms = 1;
  bool has_minimum_interval_ms() const;
  void clear_minimum_interval_ms() ;
  ::uint32_t minimum_interval_ms() const;
  void set_minimum_interval_ms(::uint32_t value);

  private:
  ::uint32_t _internal_minimum_interval_ms() const;
  void _internal_set_minimum_interval_ms(::uint32_t value);

  public:
  // required .HU.ChannelDescriptor.NavigationStatusService.CLUSTER_TYPE type = 2;
  bool has_type() const;
  void clear_type() ;
  ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE type() const;
  void set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value);

  private:
  ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE _internal_type() const;
  void _internal_set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.NavigationStatusService)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* image_options_;
    ::uint32_t minimum_interval_ms_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_InputStreamChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.InputStreamChannel) */ {
 public:
  inline ChannelDescriptor_InputStreamChannel() : ChannelDescriptor_InputStreamChannel(nullptr) {}
  ~ChannelDescriptor_InputStreamChannel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_InputStreamChannel(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_InputStreamChannel(const ChannelDescriptor_InputStreamChannel& from)
      : ChannelDescriptor_InputStreamChannel(nullptr, from) {}
  ChannelDescriptor_InputStreamChannel(ChannelDescriptor_InputStreamChannel&& from) noexcept
    : ChannelDescriptor_InputStreamChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_InputStreamChannel& operator=(const ChannelDescriptor_InputStreamChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_InputStreamChannel& operator=(ChannelDescriptor_InputStreamChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_InputStreamChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_InputStreamChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_InputStreamChannel*>(
               &_ChannelDescriptor_InputStreamChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ChannelDescriptor_InputStreamChannel& a, ChannelDescriptor_InputStreamChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_InputStreamChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_InputStreamChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_InputStreamChannel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_InputStreamChannel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_InputStreamChannel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_InputStreamChannel& from) {
    ChannelDescriptor_InputStreamChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_InputStreamChannel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.InputStreamChannel";
  }
  protected:
  explicit ChannelDescriptor_InputStreamChannel(::google::protobuf::Arena* arena);
  ChannelDescriptor_InputStreamChannel(::google::protobuf::Arena* arena, const ChannelDescriptor_InputStreamChannel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigFieldNumber = 2,
    kAvailableWhileInCallFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // required .HU.AudioCofig audio_config = 2;
  bool has_audio_config() const;
  void clear_audio_config() ;
  const ::HU::AudioCofig& audio_config() const;
  PROTOBUF_NODISCARD ::HU::AudioCofig* release_audio_config();
  ::HU::AudioCofig* mutable_audio_config();
  void set_allocated_audio_config(::HU::AudioCofig* value);
  void unsafe_arena_set_allocated_audio_config(::HU::AudioCofig* value);
  ::HU::AudioCofig* unsafe_arena_release_audio_config();

  private:
  const ::HU::AudioCofig& _internal_audio_config() const;
  ::HU::AudioCofig* _internal_mutable_audio_config();

  public:
  // optional bool available_while_in_call = 3;
  bool has_available_while_in_call() const;
  void clear_available_while_in_call() ;
  bool available_while_in_call() const;
  void set_available_while_in_call(bool value);

  private:
  bool _internal_available_while_in_call() const;
  void _internal_set_available_while_in_call(bool value);

  public:
  // required .HU.STREAM_TYPE type = 1;
  bool has_type() const;
  void clear_type() ;
  ::HU::STREAM_TYPE type() const;
  void set_type(::HU::STREAM_TYPE value);

  private:
  ::HU::STREAM_TYPE _internal_type() const;
  void _internal_set_type(::HU::STREAM_TYPE value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.InputStreamChannel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::HU::AudioCofig* audio_config_;
    bool available_while_in_call_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor_InputEventChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.InputEventChannel) */ {
 public:
  inline ChannelDescriptor_InputEventChannel() : ChannelDescriptor_InputEventChannel(nullptr) {}
  ~ChannelDescriptor_InputEventChannel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor_InputEventChannel(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor_InputEventChannel(const ChannelDescriptor_InputEventChannel& from)
      : ChannelDescriptor_InputEventChannel(nullptr, from) {}
  ChannelDescriptor_InputEventChannel(ChannelDescriptor_InputEventChannel&& from) noexcept
    : ChannelDescriptor_InputEventChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_InputEventChannel& operator=(const ChannelDescriptor_InputEventChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_InputEventChannel& operator=(ChannelDescriptor_InputEventChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor_InputEventChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor_InputEventChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_InputEventChannel*>(
               &_ChannelDescriptor_InputEventChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ChannelDescriptor_InputEventChannel& a, ChannelDescriptor_InputEventChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_InputEventChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_InputEventChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor_InputEventChannel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor_InputEventChannel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor_InputEventChannel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor_InputEventChannel& from) {
    ChannelDescriptor_InputEventChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor_InputEventChannel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor.InputEventChannel";
  }
  protected:
  explicit ChannelDescriptor_InputEventChannel(::google::protobuf::Arena* arena);
  ChannelDescriptor_InputEventChannel(::google::protobuf::Arena* arena, const ChannelDescriptor_InputEventChannel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TouchScreenConfig = ChannelDescriptor_InputEventChannel_TouchScreenConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kKeycodesSupportedFieldNumber = 1,
    kTouchScreenConfigFieldNumber = 2,
    kTouchPadConfigFieldNumber = 3,
  };
  // repeated uint32 keycodes_supported = 1;
  int keycodes_supported_size() const;
  private:
  int _internal_keycodes_supported_size() const;

  public:
  void clear_keycodes_supported() ;
  ::uint32_t keycodes_supported(int index) const;
  void set_keycodes_supported(int index, ::uint32_t value);
  void add_keycodes_supported(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& keycodes_supported() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_keycodes_supported();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_keycodes_supported() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_keycodes_supported();

  public:
  // optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_screen_config = 2;
  bool has_touch_screen_config() const;
  void clear_touch_screen_config() ;
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& touch_screen_config() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* release_touch_screen_config();
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* mutable_touch_screen_config();
  void set_allocated_touch_screen_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value);
  void unsafe_arena_set_allocated_touch_screen_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value);
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* unsafe_arena_release_touch_screen_config();

  private:
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& _internal_touch_screen_config() const;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* _internal_mutable_touch_screen_config();

  public:
  // optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_pad_config = 3;
  bool has_touch_pad_config() const;
  void clear_touch_pad_config() ;
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& touch_pad_config() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* release_touch_pad_config();
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* mutable_touch_pad_config();
  void set_allocated_touch_pad_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value);
  void unsafe_arena_set_allocated_touch_pad_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value);
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* unsafe_arena_release_touch_pad_config();

  private:
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& _internal_touch_pad_config() const;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* _internal_mutable_touch_pad_config();

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.InputEventChannel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> keycodes_supported_;
    ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_screen_config_;
    ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_pad_config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ButtonInfoWrapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ButtonInfoWrapper) */ {
 public:
  inline ButtonInfoWrapper() : ButtonInfoWrapper(nullptr) {}
  ~ButtonInfoWrapper() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ButtonInfoWrapper(::google::protobuf::internal::ConstantInitialized);

  inline ButtonInfoWrapper(const ButtonInfoWrapper& from)
      : ButtonInfoWrapper(nullptr, from) {}
  ButtonInfoWrapper(ButtonInfoWrapper&& from) noexcept
    : ButtonInfoWrapper() {
    *this = ::std::move(from);
  }

  inline ButtonInfoWrapper& operator=(const ButtonInfoWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonInfoWrapper& operator=(ButtonInfoWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonInfoWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const ButtonInfoWrapper* internal_default_instance() {
    return reinterpret_cast<const ButtonInfoWrapper*>(
               &_ButtonInfoWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ButtonInfoWrapper& a, ButtonInfoWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonInfoWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonInfoWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ButtonInfoWrapper* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ButtonInfoWrapper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ButtonInfoWrapper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ButtonInfoWrapper& from) {
    ButtonInfoWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ButtonInfoWrapper* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ButtonInfoWrapper";
  }
  protected:
  explicit ButtonInfoWrapper(::google::protobuf::Arena* arena);
  ButtonInfoWrapper(::google::protobuf::Arena* arena, const ButtonInfoWrapper& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kButtonFieldNumber = 1,
  };
  // repeated .HU.ButtonInfo button = 1;
  int button_size() const;
  private:
  int _internal_button_size() const;

  public:
  void clear_button() ;
  ::HU::ButtonInfo* mutable_button(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::ButtonInfo >*
      mutable_button();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::ButtonInfo>& _internal_button() const;
  ::google::protobuf::RepeatedPtrField<::HU::ButtonInfo>* _internal_mutable_button();
  public:
  const ::HU::ButtonInfo& button(int index) const;
  ::HU::ButtonInfo* add_button();
  const ::google::protobuf::RepeatedPtrField< ::HU::ButtonInfo >&
      button() const;
  // @@protoc_insertion_point(class_scope:HU.ButtonInfoWrapper)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::HU::ButtonInfo > button_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class AbsoluteInputEventWrapper final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.AbsoluteInputEventWrapper) */ {
 public:
  inline AbsoluteInputEventWrapper() : AbsoluteInputEventWrapper(nullptr) {}
  ~AbsoluteInputEventWrapper() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AbsoluteInputEventWrapper(::google::protobuf::internal::ConstantInitialized);

  inline AbsoluteInputEventWrapper(const AbsoluteInputEventWrapper& from)
      : AbsoluteInputEventWrapper(nullptr, from) {}
  AbsoluteInputEventWrapper(AbsoluteInputEventWrapper&& from) noexcept
    : AbsoluteInputEventWrapper() {
    *this = ::std::move(from);
  }

  inline AbsoluteInputEventWrapper& operator=(const AbsoluteInputEventWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteInputEventWrapper& operator=(AbsoluteInputEventWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbsoluteInputEventWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbsoluteInputEventWrapper* internal_default_instance() {
    return reinterpret_cast<const AbsoluteInputEventWrapper*>(
               &_AbsoluteInputEventWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AbsoluteInputEventWrapper& a, AbsoluteInputEventWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteInputEventWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteInputEventWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbsoluteInputEventWrapper* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbsoluteInputEventWrapper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbsoluteInputEventWrapper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AbsoluteInputEventWrapper& from) {
    AbsoluteInputEventWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AbsoluteInputEventWrapper* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.AbsoluteInputEventWrapper";
  }
  protected:
  explicit AbsoluteInputEventWrapper(::google::protobuf::Arena* arena);
  AbsoluteInputEventWrapper(::google::protobuf::Arena* arena, const AbsoluteInputEventWrapper& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // required .HU.AbsoluteInputEvent event = 1;
  bool has_event() const;
  void clear_event() ;
  const ::HU::AbsoluteInputEvent& event() const;
  PROTOBUF_NODISCARD ::HU::AbsoluteInputEvent* release_event();
  ::HU::AbsoluteInputEvent* mutable_event();
  void set_allocated_event(::HU::AbsoluteInputEvent* value);
  void unsafe_arena_set_allocated_event(::HU::AbsoluteInputEvent* value);
  ::HU::AbsoluteInputEvent* unsafe_arena_release_event();

  private:
  const ::HU::AbsoluteInputEvent& _internal_event() const;
  ::HU::AbsoluteInputEvent* _internal_mutable_event();

  public:
  // @@protoc_insertion_point(class_scope:HU.AbsoluteInputEventWrapper)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::HU::AbsoluteInputEvent* event_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class InputEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.InputEvent) */ {
 public:
  inline InputEvent() : InputEvent(nullptr) {}
  ~InputEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InputEvent(::google::protobuf::internal::ConstantInitialized);

  inline InputEvent(const InputEvent& from)
      : InputEvent(nullptr, from) {}
  InputEvent(InputEvent&& from) noexcept
    : InputEvent() {
    *this = ::std::move(from);
  }

  inline InputEvent& operator=(const InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputEvent& operator=(InputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputEvent* internal_default_instance() {
    return reinterpret_cast<const InputEvent*>(
               &_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InputEvent& a, InputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InputEvent& from) {
    InputEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.InputEvent";
  }
  protected:
  explicit InputEvent(::google::protobuf::Arena* arena);
  InputEvent(::google::protobuf::Arena* arena, const InputEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTouchFieldNumber = 3,
    kButtonFieldNumber = 4,
    kAbsEventFieldNumber = 5,
    kRelEventFieldNumber = 6,
    kTimestampFieldNumber = 1,
    kDispChannelFieldNumber = 2,
  };
  // optional .HU.TouchInfo touch = 3;
  bool has_touch() const;
  void clear_touch() ;
  const ::HU::TouchInfo& touch() const;
  PROTOBUF_NODISCARD ::HU::TouchInfo* release_touch();
  ::HU::TouchInfo* mutable_touch();
  void set_allocated_touch(::HU::TouchInfo* value);
  void unsafe_arena_set_allocated_touch(::HU::TouchInfo* value);
  ::HU::TouchInfo* unsafe_arena_release_touch();

  private:
  const ::HU::TouchInfo& _internal_touch() const;
  ::HU::TouchInfo* _internal_mutable_touch();

  public:
  // optional .HU.ButtonInfoWrapper button = 4;
  bool has_button() const;
  void clear_button() ;
  const ::HU::ButtonInfoWrapper& button() const;
  PROTOBUF_NODISCARD ::HU::ButtonInfoWrapper* release_button();
  ::HU::ButtonInfoWrapper* mutable_button();
  void set_allocated_button(::HU::ButtonInfoWrapper* value);
  void unsafe_arena_set_allocated_button(::HU::ButtonInfoWrapper* value);
  ::HU::ButtonInfoWrapper* unsafe_arena_release_button();

  private:
  const ::HU::ButtonInfoWrapper& _internal_button() const;
  ::HU::ButtonInfoWrapper* _internal_mutable_button();

  public:
  // optional .HU.AbsoluteInputEventWrapper abs_event = 5;
  bool has_abs_event() const;
  void clear_abs_event() ;
  const ::HU::AbsoluteInputEventWrapper& abs_event() const;
  PROTOBUF_NODISCARD ::HU::AbsoluteInputEventWrapper* release_abs_event();
  ::HU::AbsoluteInputEventWrapper* mutable_abs_event();
  void set_allocated_abs_event(::HU::AbsoluteInputEventWrapper* value);
  void unsafe_arena_set_allocated_abs_event(::HU::AbsoluteInputEventWrapper* value);
  ::HU::AbsoluteInputEventWrapper* unsafe_arena_release_abs_event();

  private:
  const ::HU::AbsoluteInputEventWrapper& _internal_abs_event() const;
  ::HU::AbsoluteInputEventWrapper* _internal_mutable_abs_event();

  public:
  // optional .HU.RelativeInputEventWrapper rel_event = 6;
  bool has_rel_event() const;
  void clear_rel_event() ;
  const ::HU::RelativeInputEventWrapper& rel_event() const;
  PROTOBUF_NODISCARD ::HU::RelativeInputEventWrapper* release_rel_event();
  ::HU::RelativeInputEventWrapper* mutable_rel_event();
  void set_allocated_rel_event(::HU::RelativeInputEventWrapper* value);
  void unsafe_arena_set_allocated_rel_event(::HU::RelativeInputEventWrapper* value);
  ::HU::RelativeInputEventWrapper* unsafe_arena_release_rel_event();

  private:
  const ::HU::RelativeInputEventWrapper& _internal_rel_event() const;
  ::HU::RelativeInputEventWrapper* _internal_mutable_rel_event();

  public:
  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional int32 disp_channel = 2;
  bool has_disp_channel() const;
  void clear_disp_channel() ;
  ::int32_t disp_channel() const;
  void set_disp_channel(::int32_t value);

  private:
  ::int32_t _internal_disp_channel() const;
  void _internal_set_disp_channel(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.InputEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::HU::TouchInfo* touch_;
    ::HU::ButtonInfoWrapper* button_;
    ::HU::AbsoluteInputEventWrapper* abs_event_;
    ::HU::RelativeInputEventWrapper* rel_event_;
    ::uint64_t timestamp_;
    ::int32_t disp_channel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ChannelDescriptor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor) */ {
 public:
  inline ChannelDescriptor() : ChannelDescriptor(nullptr) {}
  ~ChannelDescriptor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelDescriptor(::google::protobuf::internal::ConstantInitialized);

  inline ChannelDescriptor(const ChannelDescriptor& from)
      : ChannelDescriptor(nullptr, from) {}
  ChannelDescriptor(ChannelDescriptor&& from) noexcept
    : ChannelDescriptor() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor& operator=(const ChannelDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor& operator=(ChannelDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelDescriptor* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor*>(
               &_ChannelDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ChannelDescriptor& a, ChannelDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelDescriptor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelDescriptor& from) {
    ChannelDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelDescriptor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ChannelDescriptor";
  }
  protected:
  explicit ChannelDescriptor(::google::protobuf::Arena* arena);
  ChannelDescriptor(::google::protobuf::Arena* arena, const ChannelDescriptor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SensorChannel = ChannelDescriptor_SensorChannel;
  using OutputStreamChannel = ChannelDescriptor_OutputStreamChannel;
  using InputEventChannel = ChannelDescriptor_InputEventChannel;
  using InputStreamChannel = ChannelDescriptor_InputStreamChannel;
  using BluetoothService = ChannelDescriptor_BluetoothService;
  using NavigationStatusService = ChannelDescriptor_NavigationStatusService;
  using PhoneStatusService = ChannelDescriptor_PhoneStatusService;
  using VendorExtensionService = ChannelDescriptor_VendorExtensionService;
  using GenericNotificationService = ChannelDescriptor_GenericNotificationService;

  // accessors -------------------------------------------------------

  enum : int {
    kSensorChannelFieldNumber = 2,
    kOutputStreamChannelFieldNumber = 3,
    kInputEventChannelFieldNumber = 4,
    kInputStreamChannelFieldNumber = 5,
    kBluetoothServiceFieldNumber = 6,
    kNavigationStatusServiceFieldNumber = 8,
    kPhoneStatusServiceFieldNumber = 10,
    kVendorExtensionServiceFieldNumber = 12,
    kGenericNotificationServiceFieldNumber = 13,
    kChannelIdFieldNumber = 1,
  };
  // optional .HU.ChannelDescriptor.SensorChannel sensor_channel = 2;
  bool has_sensor_channel() const;
  void clear_sensor_channel() ;
  const ::HU::ChannelDescriptor_SensorChannel& sensor_channel() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_SensorChannel* release_sensor_channel();
  ::HU::ChannelDescriptor_SensorChannel* mutable_sensor_channel();
  void set_allocated_sensor_channel(::HU::ChannelDescriptor_SensorChannel* value);
  void unsafe_arena_set_allocated_sensor_channel(::HU::ChannelDescriptor_SensorChannel* value);
  ::HU::ChannelDescriptor_SensorChannel* unsafe_arena_release_sensor_channel();

  private:
  const ::HU::ChannelDescriptor_SensorChannel& _internal_sensor_channel() const;
  ::HU::ChannelDescriptor_SensorChannel* _internal_mutable_sensor_channel();

  public:
  // optional .HU.ChannelDescriptor.OutputStreamChannel output_stream_channel = 3;
  bool has_output_stream_channel() const;
  void clear_output_stream_channel() ;
  const ::HU::ChannelDescriptor_OutputStreamChannel& output_stream_channel() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_OutputStreamChannel* release_output_stream_channel();
  ::HU::ChannelDescriptor_OutputStreamChannel* mutable_output_stream_channel();
  void set_allocated_output_stream_channel(::HU::ChannelDescriptor_OutputStreamChannel* value);
  void unsafe_arena_set_allocated_output_stream_channel(::HU::ChannelDescriptor_OutputStreamChannel* value);
  ::HU::ChannelDescriptor_OutputStreamChannel* unsafe_arena_release_output_stream_channel();

  private:
  const ::HU::ChannelDescriptor_OutputStreamChannel& _internal_output_stream_channel() const;
  ::HU::ChannelDescriptor_OutputStreamChannel* _internal_mutable_output_stream_channel();

  public:
  // optional .HU.ChannelDescriptor.InputEventChannel input_event_channel = 4;
  bool has_input_event_channel() const;
  void clear_input_event_channel() ;
  const ::HU::ChannelDescriptor_InputEventChannel& input_event_channel() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_InputEventChannel* release_input_event_channel();
  ::HU::ChannelDescriptor_InputEventChannel* mutable_input_event_channel();
  void set_allocated_input_event_channel(::HU::ChannelDescriptor_InputEventChannel* value);
  void unsafe_arena_set_allocated_input_event_channel(::HU::ChannelDescriptor_InputEventChannel* value);
  ::HU::ChannelDescriptor_InputEventChannel* unsafe_arena_release_input_event_channel();

  private:
  const ::HU::ChannelDescriptor_InputEventChannel& _internal_input_event_channel() const;
  ::HU::ChannelDescriptor_InputEventChannel* _internal_mutable_input_event_channel();

  public:
  // optional .HU.ChannelDescriptor.InputStreamChannel input_stream_channel = 5;
  bool has_input_stream_channel() const;
  void clear_input_stream_channel() ;
  const ::HU::ChannelDescriptor_InputStreamChannel& input_stream_channel() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_InputStreamChannel* release_input_stream_channel();
  ::HU::ChannelDescriptor_InputStreamChannel* mutable_input_stream_channel();
  void set_allocated_input_stream_channel(::HU::ChannelDescriptor_InputStreamChannel* value);
  void unsafe_arena_set_allocated_input_stream_channel(::HU::ChannelDescriptor_InputStreamChannel* value);
  ::HU::ChannelDescriptor_InputStreamChannel* unsafe_arena_release_input_stream_channel();

  private:
  const ::HU::ChannelDescriptor_InputStreamChannel& _internal_input_stream_channel() const;
  ::HU::ChannelDescriptor_InputStreamChannel* _internal_mutable_input_stream_channel();

  public:
  // optional .HU.ChannelDescriptor.BluetoothService bluetooth_service = 6;
  bool has_bluetooth_service() const;
  void clear_bluetooth_service() ;
  const ::HU::ChannelDescriptor_BluetoothService& bluetooth_service() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_BluetoothService* release_bluetooth_service();
  ::HU::ChannelDescriptor_BluetoothService* mutable_bluetooth_service();
  void set_allocated_bluetooth_service(::HU::ChannelDescriptor_BluetoothService* value);
  void unsafe_arena_set_allocated_bluetooth_service(::HU::ChannelDescriptor_BluetoothService* value);
  ::HU::ChannelDescriptor_BluetoothService* unsafe_arena_release_bluetooth_service();

  private:
  const ::HU::ChannelDescriptor_BluetoothService& _internal_bluetooth_service() const;
  ::HU::ChannelDescriptor_BluetoothService* _internal_mutable_bluetooth_service();

  public:
  // optional .HU.ChannelDescriptor.NavigationStatusService navigation_status_service = 8;
  bool has_navigation_status_service() const;
  void clear_navigation_status_service() ;
  const ::HU::ChannelDescriptor_NavigationStatusService& navigation_status_service() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_NavigationStatusService* release_navigation_status_service();
  ::HU::ChannelDescriptor_NavigationStatusService* mutable_navigation_status_service();
  void set_allocated_navigation_status_service(::HU::ChannelDescriptor_NavigationStatusService* value);
  void unsafe_arena_set_allocated_navigation_status_service(::HU::ChannelDescriptor_NavigationStatusService* value);
  ::HU::ChannelDescriptor_NavigationStatusService* unsafe_arena_release_navigation_status_service();

  private:
  const ::HU::ChannelDescriptor_NavigationStatusService& _internal_navigation_status_service() const;
  ::HU::ChannelDescriptor_NavigationStatusService* _internal_mutable_navigation_status_service();

  public:
  // optional .HU.ChannelDescriptor.PhoneStatusService phone_status_service = 10;
  bool has_phone_status_service() const;
  void clear_phone_status_service() ;
  const ::HU::ChannelDescriptor_PhoneStatusService& phone_status_service() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_PhoneStatusService* release_phone_status_service();
  ::HU::ChannelDescriptor_PhoneStatusService* mutable_phone_status_service();
  void set_allocated_phone_status_service(::HU::ChannelDescriptor_PhoneStatusService* value);
  void unsafe_arena_set_allocated_phone_status_service(::HU::ChannelDescriptor_PhoneStatusService* value);
  ::HU::ChannelDescriptor_PhoneStatusService* unsafe_arena_release_phone_status_service();

  private:
  const ::HU::ChannelDescriptor_PhoneStatusService& _internal_phone_status_service() const;
  ::HU::ChannelDescriptor_PhoneStatusService* _internal_mutable_phone_status_service();

  public:
  // optional .HU.ChannelDescriptor.VendorExtensionService vendor_extension_service = 12;
  bool has_vendor_extension_service() const;
  void clear_vendor_extension_service() ;
  const ::HU::ChannelDescriptor_VendorExtensionService& vendor_extension_service() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_VendorExtensionService* release_vendor_extension_service();
  ::HU::ChannelDescriptor_VendorExtensionService* mutable_vendor_extension_service();
  void set_allocated_vendor_extension_service(::HU::ChannelDescriptor_VendorExtensionService* value);
  void unsafe_arena_set_allocated_vendor_extension_service(::HU::ChannelDescriptor_VendorExtensionService* value);
  ::HU::ChannelDescriptor_VendorExtensionService* unsafe_arena_release_vendor_extension_service();

  private:
  const ::HU::ChannelDescriptor_VendorExtensionService& _internal_vendor_extension_service() const;
  ::HU::ChannelDescriptor_VendorExtensionService* _internal_mutable_vendor_extension_service();

  public:
  // optional .HU.ChannelDescriptor.GenericNotificationService generic_notification_service = 13;
  bool has_generic_notification_service() const;
  void clear_generic_notification_service() ;
  const ::HU::ChannelDescriptor_GenericNotificationService& generic_notification_service() const;
  PROTOBUF_NODISCARD ::HU::ChannelDescriptor_GenericNotificationService* release_generic_notification_service();
  ::HU::ChannelDescriptor_GenericNotificationService* mutable_generic_notification_service();
  void set_allocated_generic_notification_service(::HU::ChannelDescriptor_GenericNotificationService* value);
  void unsafe_arena_set_allocated_generic_notification_service(::HU::ChannelDescriptor_GenericNotificationService* value);
  ::HU::ChannelDescriptor_GenericNotificationService* unsafe_arena_release_generic_notification_service();

  private:
  const ::HU::ChannelDescriptor_GenericNotificationService& _internal_generic_notification_service() const;
  ::HU::ChannelDescriptor_GenericNotificationService* _internal_mutable_generic_notification_service();

  public:
  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id() ;
  ::uint32_t channel_id() const;
  void set_channel_id(::uint32_t value);

  private:
  ::uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 9,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::HU::ChannelDescriptor_SensorChannel* sensor_channel_;
    ::HU::ChannelDescriptor_OutputStreamChannel* output_stream_channel_;
    ::HU::ChannelDescriptor_InputEventChannel* input_event_channel_;
    ::HU::ChannelDescriptor_InputStreamChannel* input_stream_channel_;
    ::HU::ChannelDescriptor_BluetoothService* bluetooth_service_;
    ::HU::ChannelDescriptor_NavigationStatusService* navigation_status_service_;
    ::HU::ChannelDescriptor_PhoneStatusService* phone_status_service_;
    ::HU::ChannelDescriptor_VendorExtensionService* vendor_extension_service_;
    ::HU::ChannelDescriptor_GenericNotificationService* generic_notification_service_;
    ::uint32_t channel_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};// -------------------------------------------------------------------

class ServiceDiscoveryResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HU.ServiceDiscoveryResponse) */ {
 public:
  inline ServiceDiscoveryResponse() : ServiceDiscoveryResponse(nullptr) {}
  ~ServiceDiscoveryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceDiscoveryResponse(::google::protobuf::internal::ConstantInitialized);

  inline ServiceDiscoveryResponse(const ServiceDiscoveryResponse& from)
      : ServiceDiscoveryResponse(nullptr, from) {}
  ServiceDiscoveryResponse(ServiceDiscoveryResponse&& from) noexcept
    : ServiceDiscoveryResponse() {
    *this = ::std::move(from);
  }

  inline ServiceDiscoveryResponse& operator=(const ServiceDiscoveryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceDiscoveryResponse& operator=(ServiceDiscoveryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceDiscoveryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceDiscoveryResponse* internal_default_instance() {
    return reinterpret_cast<const ServiceDiscoveryResponse*>(
               &_ServiceDiscoveryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ServiceDiscoveryResponse& a, ServiceDiscoveryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceDiscoveryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceDiscoveryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceDiscoveryResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceDiscoveryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServiceDiscoveryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ServiceDiscoveryResponse& from) {
    ServiceDiscoveryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServiceDiscoveryResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "HU.ServiceDiscoveryResponse";
  }
  protected:
  explicit ServiceDiscoveryResponse(::google::protobuf::Arena* arena);
  ServiceDiscoveryResponse(::google::protobuf::Arena* arena, const ServiceDiscoveryResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
    kHeadUnitNameFieldNumber = 2,
    kCarModelFieldNumber = 3,
    kCarYearFieldNumber = 4,
    kCarSerialFieldNumber = 5,
    kHeadunitMakeFieldNumber = 7,
    kHeadunitModelFieldNumber = 8,
    kSwBuildFieldNumber = 9,
    kSwVersionFieldNumber = 10,
    kDriverPosFieldNumber = 6,
    kCanPlayNativeMediaDuringVrFieldNumber = 11,
    kHideClockFieldNumber = 12,
  };
  // repeated .HU.ChannelDescriptor channels = 1;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::HU::ChannelDescriptor* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor >*
      mutable_channels();
  private:
  const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor>& _internal_channels() const;
  ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor>* _internal_mutable_channels();
  public:
  const ::HU::ChannelDescriptor& channels(int index) const;
  ::HU::ChannelDescriptor* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor >&
      channels() const;
  // required string head_unit_name = 2;
  bool has_head_unit_name() const;
  void clear_head_unit_name() ;
  const std::string& head_unit_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_head_unit_name(Arg_&& arg, Args_... args);
  std::string* mutable_head_unit_name();
  PROTOBUF_NODISCARD std::string* release_head_unit_name();
  void set_allocated_head_unit_name(std::string* value);

  private:
  const std::string& _internal_head_unit_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_head_unit_name(
      const std::string& value);
  std::string* _internal_mutable_head_unit_name();

  public:
  // required string car_model = 3;
  bool has_car_model() const;
  void clear_car_model() ;
  const std::string& car_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_car_model(Arg_&& arg, Args_... args);
  std::string* mutable_car_model();
  PROTOBUF_NODISCARD std::string* release_car_model();
  void set_allocated_car_model(std::string* value);

  private:
  const std::string& _internal_car_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car_model(
      const std::string& value);
  std::string* _internal_mutable_car_model();

  public:
  // required string car_year = 4;
  bool has_car_year() const;
  void clear_car_year() ;
  const std::string& car_year() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_car_year(Arg_&& arg, Args_... args);
  std::string* mutable_car_year();
  PROTOBUF_NODISCARD std::string* release_car_year();
  void set_allocated_car_year(std::string* value);

  private:
  const std::string& _internal_car_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car_year(
      const std::string& value);
  std::string* _internal_mutable_car_year();

  public:
  // required string car_serial = 5;
  bool has_car_serial() const;
  void clear_car_serial() ;
  const std::string& car_serial() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_car_serial(Arg_&& arg, Args_... args);
  std::string* mutable_car_serial();
  PROTOBUF_NODISCARD std::string* release_car_serial();
  void set_allocated_car_serial(std::string* value);

  private:
  const std::string& _internal_car_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car_serial(
      const std::string& value);
  std::string* _internal_mutable_car_serial();

  public:
  // required string headunit_make = 7;
  bool has_headunit_make() const;
  void clear_headunit_make() ;
  const std::string& headunit_make() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_headunit_make(Arg_&& arg, Args_... args);
  std::string* mutable_headunit_make();
  PROTOBUF_NODISCARD std::string* release_headunit_make();
  void set_allocated_headunit_make(std::string* value);

  private:
  const std::string& _internal_headunit_make() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headunit_make(
      const std::string& value);
  std::string* _internal_mutable_headunit_make();

  public:
  // required string headunit_model = 8;
  bool has_headunit_model() const;
  void clear_headunit_model() ;
  const std::string& headunit_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_headunit_model(Arg_&& arg, Args_... args);
  std::string* mutable_headunit_model();
  PROTOBUF_NODISCARD std::string* release_headunit_model();
  void set_allocated_headunit_model(std::string* value);

  private:
  const std::string& _internal_headunit_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headunit_model(
      const std::string& value);
  std::string* _internal_mutable_headunit_model();

  public:
  // required string sw_build = 9;
  bool has_sw_build() const;
  void clear_sw_build() ;
  const std::string& sw_build() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sw_build(Arg_&& arg, Args_... args);
  std::string* mutable_sw_build();
  PROTOBUF_NODISCARD std::string* release_sw_build();
  void set_allocated_sw_build(std::string* value);

  private:
  const std::string& _internal_sw_build() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sw_build(
      const std::string& value);
  std::string* _internal_mutable_sw_build();

  public:
  // required string sw_version = 10;
  bool has_sw_version() const;
  void clear_sw_version() ;
  const std::string& sw_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sw_version(Arg_&& arg, Args_... args);
  std::string* mutable_sw_version();
  PROTOBUF_NODISCARD std::string* release_sw_version();
  void set_allocated_sw_version(std::string* value);

  private:
  const std::string& _internal_sw_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sw_version(
      const std::string& value);
  std::string* _internal_mutable_sw_version();

  public:
  // required bool driver_pos = 6;
  bool has_driver_pos() const;
  void clear_driver_pos() ;
  bool driver_pos() const;
  void set_driver_pos(bool value);

  private:
  bool _internal_driver_pos() const;
  void _internal_set_driver_pos(bool value);

  public:
  // required bool can_play_native_media_during_vr = 11;
  bool has_can_play_native_media_during_vr() const;
  void clear_can_play_native_media_during_vr() ;
  bool can_play_native_media_during_vr() const;
  void set_can_play_native_media_during_vr(bool value);

  private:
  bool _internal_can_play_native_media_during_vr() const;
  void _internal_set_can_play_native_media_during_vr(bool value);

  public:
  // required bool hide_clock = 12;
  bool has_hide_clock() const;
  void clear_hide_clock() ;
  bool hide_clock() const;
  void set_hide_clock(bool value);

  private:
  bool _internal_hide_clock() const;
  void _internal_set_hide_clock(bool value);

  public:
  // @@protoc_insertion_point(class_scope:HU.ServiceDiscoveryResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      130, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::HU::ChannelDescriptor > channels_;
    ::google::protobuf::internal::ArenaStringPtr head_unit_name_;
    ::google::protobuf::internal::ArenaStringPtr car_model_;
    ::google::protobuf::internal::ArenaStringPtr car_year_;
    ::google::protobuf::internal::ArenaStringPtr car_serial_;
    ::google::protobuf::internal::ArenaStringPtr headunit_make_;
    ::google::protobuf::internal::ArenaStringPtr headunit_model_;
    ::google::protobuf::internal::ArenaStringPtr sw_build_;
    ::google::protobuf::internal::ArenaStringPtr sw_version_;
    bool driver_pos_;
    bool can_play_native_media_during_vr_;
    bool hide_clock_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AndroidAuto_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ButtonInfo

// required uint32 scan_code = 1;
inline bool ButtonInfo::has_scan_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ButtonInfo::clear_scan_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scan_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ButtonInfo::scan_code() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.scan_code)
  return _internal_scan_code();
}
inline void ButtonInfo::set_scan_code(::uint32_t value) {
  _internal_set_scan_code(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.scan_code)
}
inline ::uint32_t ButtonInfo::_internal_scan_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scan_code_;
}
inline void ButtonInfo::_internal_set_scan_code(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scan_code_ = value;
}

// required bool is_pressed = 2;
inline bool ButtonInfo::has_is_pressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ButtonInfo::clear_is_pressed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_pressed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ButtonInfo::is_pressed() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.is_pressed)
  return _internal_is_pressed();
}
inline void ButtonInfo::set_is_pressed(bool value) {
  _internal_set_is_pressed(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.is_pressed)
}
inline bool ButtonInfo::_internal_is_pressed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_pressed_;
}
inline void ButtonInfo::_internal_set_is_pressed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_pressed_ = value;
}

// required uint32 meta = 3;
inline bool ButtonInfo::has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ButtonInfo::clear_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.meta_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ButtonInfo::meta() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.meta)
  return _internal_meta();
}
inline void ButtonInfo::set_meta(::uint32_t value) {
  _internal_set_meta(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.meta)
}
inline ::uint32_t ButtonInfo::_internal_meta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.meta_;
}
inline void ButtonInfo::_internal_set_meta(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.meta_ = value;
}

// required bool long_press = 4;
inline bool ButtonInfo::has_long_press() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ButtonInfo::clear_long_press() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.long_press_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ButtonInfo::long_press() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.long_press)
  return _internal_long_press();
}
inline void ButtonInfo::set_long_press(bool value) {
  _internal_set_long_press(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.long_press)
}
inline bool ButtonInfo::_internal_long_press() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.long_press_;
}
inline void ButtonInfo::_internal_set_long_press(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.long_press_ = value;
}

// -------------------------------------------------------------------

// ButtonInfoWrapper

// repeated .HU.ButtonInfo button = 1;
inline int ButtonInfoWrapper::_internal_button_size() const {
  return _internal_button().size();
}
inline int ButtonInfoWrapper::button_size() const {
  return _internal_button_size();
}
inline void ButtonInfoWrapper::clear_button() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.button_.Clear();
}
inline ::HU::ButtonInfo* ButtonInfoWrapper::mutable_button(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.ButtonInfoWrapper.button)
  return _internal_mutable_button()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::ButtonInfo>* ButtonInfoWrapper::mutable_button()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ButtonInfoWrapper.button)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_button();
}
inline const ::HU::ButtonInfo& ButtonInfoWrapper::button(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ButtonInfoWrapper.button)
  return _internal_button().Get(index);
}
inline ::HU::ButtonInfo* ButtonInfoWrapper::add_button() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::ButtonInfo* _add = _internal_mutable_button()->Add();
  // @@protoc_insertion_point(field_add:HU.ButtonInfoWrapper.button)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ButtonInfo>& ButtonInfoWrapper::button() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ButtonInfoWrapper.button)
  return _internal_button();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ButtonInfo>&
ButtonInfoWrapper::_internal_button() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.button_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::ButtonInfo>*
ButtonInfoWrapper::_internal_mutable_button() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.button_;
}

// -------------------------------------------------------------------

// TouchInfo_Location

// required uint32 x = 1;
inline bool TouchInfo_Location::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TouchInfo_Location::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TouchInfo_Location::x() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.Location.x)
  return _internal_x();
}
inline void TouchInfo_Location::set_x(::uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.Location.x)
}
inline ::uint32_t TouchInfo_Location::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void TouchInfo_Location::_internal_set_x(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required uint32 y = 2;
inline bool TouchInfo_Location::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TouchInfo_Location::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TouchInfo_Location::y() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.Location.y)
  return _internal_y();
}
inline void TouchInfo_Location::set_y(::uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.Location.y)
}
inline ::uint32_t TouchInfo_Location::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void TouchInfo_Location::_internal_set_y(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// required uint32 pointer_id = 3;
inline bool TouchInfo_Location::has_pointer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TouchInfo_Location::clear_pointer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pointer_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TouchInfo_Location::pointer_id() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.Location.pointer_id)
  return _internal_pointer_id();
}
inline void TouchInfo_Location::set_pointer_id(::uint32_t value) {
  _internal_set_pointer_id(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.Location.pointer_id)
}
inline ::uint32_t TouchInfo_Location::_internal_pointer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pointer_id_;
}
inline void TouchInfo_Location::_internal_set_pointer_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pointer_id_ = value;
}

// -------------------------------------------------------------------

// TouchInfo

// repeated .HU.TouchInfo.Location location = 1;
inline int TouchInfo::_internal_location_size() const {
  return _internal_location().size();
}
inline int TouchInfo::location_size() const {
  return _internal_location_size();
}
inline void TouchInfo::clear_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_.Clear();
}
inline ::HU::TouchInfo_Location* TouchInfo::mutable_location(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.TouchInfo.location)
  return _internal_mutable_location()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::TouchInfo_Location>* TouchInfo::mutable_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.TouchInfo.location)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_location();
}
inline const ::HU::TouchInfo_Location& TouchInfo::location(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.location)
  return _internal_location().Get(index);
}
inline ::HU::TouchInfo_Location* TouchInfo::add_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::TouchInfo_Location* _add = _internal_mutable_location()->Add();
  // @@protoc_insertion_point(field_add:HU.TouchInfo.location)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::TouchInfo_Location>& TouchInfo::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.TouchInfo.location)
  return _internal_location();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::TouchInfo_Location>&
TouchInfo::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::TouchInfo_Location>*
TouchInfo::_internal_mutable_location() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.location_;
}

// optional uint32 action_index = 2;
inline bool TouchInfo::has_action_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TouchInfo::clear_action_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TouchInfo::action_index() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.action_index)
  return _internal_action_index();
}
inline void TouchInfo::set_action_index(::uint32_t value) {
  _internal_set_action_index(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.action_index)
}
inline ::uint32_t TouchInfo::_internal_action_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_index_;
}
inline void TouchInfo::_internal_set_action_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.action_index_ = value;
}

// required .HU.TouchInfo.TOUCH_ACTION action = 3;
inline bool TouchInfo::has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TouchInfo::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::TouchInfo_TOUCH_ACTION TouchInfo::action() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.action)
  return _internal_action();
}
inline void TouchInfo::set_action(::HU::TouchInfo_TOUCH_ACTION value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.action)
}
inline ::HU::TouchInfo_TOUCH_ACTION TouchInfo::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::TouchInfo_TOUCH_ACTION>(_impl_.action_);
}
inline void TouchInfo::_internal_set_action(::HU::TouchInfo_TOUCH_ACTION value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::TouchInfo_TOUCH_ACTION_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.action_ = value;
}

// -------------------------------------------------------------------

// RelativeInputEvent

// optional uint32 scan_code = 1;
inline bool RelativeInputEvent::has_scan_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RelativeInputEvent::clear_scan_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scan_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t RelativeInputEvent::scan_code() const {
  // @@protoc_insertion_point(field_get:HU.RelativeInputEvent.scan_code)
  return _internal_scan_code();
}
inline void RelativeInputEvent::set_scan_code(::uint32_t value) {
  _internal_set_scan_code(value);
  // @@protoc_insertion_point(field_set:HU.RelativeInputEvent.scan_code)
}
inline ::uint32_t RelativeInputEvent::_internal_scan_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scan_code_;
}
inline void RelativeInputEvent::_internal_set_scan_code(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scan_code_ = value;
}

// optional int32 delta = 2;
inline bool RelativeInputEvent::has_delta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RelativeInputEvent::clear_delta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.delta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RelativeInputEvent::delta() const {
  // @@protoc_insertion_point(field_get:HU.RelativeInputEvent.delta)
  return _internal_delta();
}
inline void RelativeInputEvent::set_delta(::int32_t value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:HU.RelativeInputEvent.delta)
}
inline ::int32_t RelativeInputEvent::_internal_delta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delta_;
}
inline void RelativeInputEvent::_internal_set_delta(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.delta_ = value;
}

// -------------------------------------------------------------------

// AbsoluteInputEvent

// optional uint32 scan_code = 1;
inline bool AbsoluteInputEvent::has_scan_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AbsoluteInputEvent::clear_scan_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scan_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AbsoluteInputEvent::scan_code() const {
  // @@protoc_insertion_point(field_get:HU.AbsoluteInputEvent.scan_code)
  return _internal_scan_code();
}
inline void AbsoluteInputEvent::set_scan_code(::uint32_t value) {
  _internal_set_scan_code(value);
  // @@protoc_insertion_point(field_set:HU.AbsoluteInputEvent.scan_code)
}
inline ::uint32_t AbsoluteInputEvent::_internal_scan_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scan_code_;
}
inline void AbsoluteInputEvent::_internal_set_scan_code(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scan_code_ = value;
}

// optional int32 value = 2;
inline bool AbsoluteInputEvent::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AbsoluteInputEvent::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AbsoluteInputEvent::value() const {
  // @@protoc_insertion_point(field_get:HU.AbsoluteInputEvent.value)
  return _internal_value();
}
inline void AbsoluteInputEvent::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:HU.AbsoluteInputEvent.value)
}
inline ::int32_t AbsoluteInputEvent::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void AbsoluteInputEvent::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// AbsoluteInputEventWrapper

// required .HU.AbsoluteInputEvent event = 1;
inline bool AbsoluteInputEventWrapper::has_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.event_ != nullptr);
  return value;
}
inline void AbsoluteInputEventWrapper::clear_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.event_ != nullptr) _impl_.event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::AbsoluteInputEvent& AbsoluteInputEventWrapper::_internal_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::AbsoluteInputEvent* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::AbsoluteInputEvent&>(::HU::_AbsoluteInputEvent_default_instance_);
}
inline const ::HU::AbsoluteInputEvent& AbsoluteInputEventWrapper::event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.AbsoluteInputEventWrapper.event)
  return _internal_event();
}
inline void AbsoluteInputEventWrapper::unsafe_arena_set_allocated_event(::HU::AbsoluteInputEvent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = reinterpret_cast<::HU::AbsoluteInputEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.AbsoluteInputEventWrapper.event)
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::release_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::AbsoluteInputEvent* released = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::unsafe_arena_release_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.AbsoluteInputEventWrapper.event)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::AbsoluteInputEvent* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::_internal_mutable_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::AbsoluteInputEvent>(GetArena());
    _impl_.event_ = reinterpret_cast<::HU::AbsoluteInputEvent*>(p);
  }
  return _impl_.event_;
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::mutable_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::AbsoluteInputEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:HU.AbsoluteInputEventWrapper.event)
  return _msg;
}
inline void AbsoluteInputEventWrapper::set_allocated_event(::HU::AbsoluteInputEvent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::AbsoluteInputEvent*>(_impl_.event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::AbsoluteInputEvent*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.event_ = reinterpret_cast<::HU::AbsoluteInputEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.AbsoluteInputEventWrapper.event)
}

// -------------------------------------------------------------------

// RelativeInputEventWrapper

// required .HU.RelativeInputEvent event = 1;
inline bool RelativeInputEventWrapper::has_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.event_ != nullptr);
  return value;
}
inline void RelativeInputEventWrapper::clear_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.event_ != nullptr) _impl_.event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::RelativeInputEvent& RelativeInputEventWrapper::_internal_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::RelativeInputEvent* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::RelativeInputEvent&>(::HU::_RelativeInputEvent_default_instance_);
}
inline const ::HU::RelativeInputEvent& RelativeInputEventWrapper::event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.RelativeInputEventWrapper.event)
  return _internal_event();
}
inline void RelativeInputEventWrapper::unsafe_arena_set_allocated_event(::HU::RelativeInputEvent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = reinterpret_cast<::HU::RelativeInputEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.RelativeInputEventWrapper.event)
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::release_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::RelativeInputEvent* released = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::unsafe_arena_release_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.RelativeInputEventWrapper.event)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::RelativeInputEvent* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::_internal_mutable_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::RelativeInputEvent>(GetArena());
    _impl_.event_ = reinterpret_cast<::HU::RelativeInputEvent*>(p);
  }
  return _impl_.event_;
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::mutable_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::RelativeInputEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:HU.RelativeInputEventWrapper.event)
  return _msg;
}
inline void RelativeInputEventWrapper::set_allocated_event(::HU::RelativeInputEvent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::RelativeInputEvent*>(_impl_.event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::RelativeInputEvent*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.event_ = reinterpret_cast<::HU::RelativeInputEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.RelativeInputEventWrapper.event)
}

// -------------------------------------------------------------------

// InputEvent

// required uint64 timestamp = 1;
inline bool InputEvent::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InputEvent::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t InputEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.timestamp)
  return _internal_timestamp();
}
inline void InputEvent::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.InputEvent.timestamp)
}
inline ::uint64_t InputEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void InputEvent::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timestamp_ = value;
}

// optional int32 disp_channel = 2;
inline bool InputEvent::has_disp_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InputEvent::clear_disp_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disp_channel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t InputEvent::disp_channel() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.disp_channel)
  return _internal_disp_channel();
}
inline void InputEvent::set_disp_channel(::int32_t value) {
  _internal_set_disp_channel(value);
  // @@protoc_insertion_point(field_set:HU.InputEvent.disp_channel)
}
inline ::int32_t InputEvent::_internal_disp_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disp_channel_;
}
inline void InputEvent::_internal_set_disp_channel(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.disp_channel_ = value;
}

// optional .HU.TouchInfo touch = 3;
inline bool InputEvent::has_touch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.touch_ != nullptr);
  return value;
}
inline void InputEvent::clear_touch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.touch_ != nullptr) _impl_.touch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::TouchInfo& InputEvent::_internal_touch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::TouchInfo* p = _impl_.touch_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::TouchInfo&>(::HU::_TouchInfo_default_instance_);
}
inline const ::HU::TouchInfo& InputEvent::touch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.InputEvent.touch)
  return _internal_touch();
}
inline void InputEvent::unsafe_arena_set_allocated_touch(::HU::TouchInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.touch_);
  }
  _impl_.touch_ = reinterpret_cast<::HU::TouchInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.touch)
}
inline ::HU::TouchInfo* InputEvent::release_touch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::TouchInfo* released = _impl_.touch_;
  _impl_.touch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::TouchInfo* InputEvent::unsafe_arena_release_touch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.InputEvent.touch)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::TouchInfo* temp = _impl_.touch_;
  _impl_.touch_ = nullptr;
  return temp;
}
inline ::HU::TouchInfo* InputEvent::_internal_mutable_touch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.touch_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::TouchInfo>(GetArena());
    _impl_.touch_ = reinterpret_cast<::HU::TouchInfo*>(p);
  }
  return _impl_.touch_;
}
inline ::HU::TouchInfo* InputEvent::mutable_touch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::TouchInfo* _msg = _internal_mutable_touch();
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.touch)
  return _msg;
}
inline void InputEvent::set_allocated_touch(::HU::TouchInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::TouchInfo*>(_impl_.touch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::TouchInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.touch_ = reinterpret_cast<::HU::TouchInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.touch)
}

// optional .HU.ButtonInfoWrapper button = 4;
inline bool InputEvent::has_button() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.button_ != nullptr);
  return value;
}
inline void InputEvent::clear_button() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.button_ != nullptr) _impl_.button_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HU::ButtonInfoWrapper& InputEvent::_internal_button() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ButtonInfoWrapper* p = _impl_.button_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ButtonInfoWrapper&>(::HU::_ButtonInfoWrapper_default_instance_);
}
inline const ::HU::ButtonInfoWrapper& InputEvent::button() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.InputEvent.button)
  return _internal_button();
}
inline void InputEvent::unsafe_arena_set_allocated_button(::HU::ButtonInfoWrapper* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.button_);
  }
  _impl_.button_ = reinterpret_cast<::HU::ButtonInfoWrapper*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.button)
}
inline ::HU::ButtonInfoWrapper* InputEvent::release_button() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HU::ButtonInfoWrapper* released = _impl_.button_;
  _impl_.button_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ButtonInfoWrapper* InputEvent::unsafe_arena_release_button() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.InputEvent.button)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HU::ButtonInfoWrapper* temp = _impl_.button_;
  _impl_.button_ = nullptr;
  return temp;
}
inline ::HU::ButtonInfoWrapper* InputEvent::_internal_mutable_button() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.button_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ButtonInfoWrapper>(GetArena());
    _impl_.button_ = reinterpret_cast<::HU::ButtonInfoWrapper*>(p);
  }
  return _impl_.button_;
}
inline ::HU::ButtonInfoWrapper* InputEvent::mutable_button() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ButtonInfoWrapper* _msg = _internal_mutable_button();
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.button)
  return _msg;
}
inline void InputEvent::set_allocated_button(::HU::ButtonInfoWrapper* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ButtonInfoWrapper*>(_impl_.button_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ButtonInfoWrapper*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.button_ = reinterpret_cast<::HU::ButtonInfoWrapper*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.button)
}

// optional .HU.AbsoluteInputEventWrapper abs_event = 5;
inline bool InputEvent::has_abs_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.abs_event_ != nullptr);
  return value;
}
inline void InputEvent::clear_abs_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.abs_event_ != nullptr) _impl_.abs_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HU::AbsoluteInputEventWrapper& InputEvent::_internal_abs_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::AbsoluteInputEventWrapper* p = _impl_.abs_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::AbsoluteInputEventWrapper&>(::HU::_AbsoluteInputEventWrapper_default_instance_);
}
inline const ::HU::AbsoluteInputEventWrapper& InputEvent::abs_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.InputEvent.abs_event)
  return _internal_abs_event();
}
inline void InputEvent::unsafe_arena_set_allocated_abs_event(::HU::AbsoluteInputEventWrapper* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.abs_event_);
  }
  _impl_.abs_event_ = reinterpret_cast<::HU::AbsoluteInputEventWrapper*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.abs_event)
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::release_abs_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HU::AbsoluteInputEventWrapper* released = _impl_.abs_event_;
  _impl_.abs_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::unsafe_arena_release_abs_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.InputEvent.abs_event)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HU::AbsoluteInputEventWrapper* temp = _impl_.abs_event_;
  _impl_.abs_event_ = nullptr;
  return temp;
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::_internal_mutable_abs_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.abs_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::AbsoluteInputEventWrapper>(GetArena());
    _impl_.abs_event_ = reinterpret_cast<::HU::AbsoluteInputEventWrapper*>(p);
  }
  return _impl_.abs_event_;
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::mutable_abs_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::AbsoluteInputEventWrapper* _msg = _internal_mutable_abs_event();
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.abs_event)
  return _msg;
}
inline void InputEvent::set_allocated_abs_event(::HU::AbsoluteInputEventWrapper* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::AbsoluteInputEventWrapper*>(_impl_.abs_event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::AbsoluteInputEventWrapper*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.abs_event_ = reinterpret_cast<::HU::AbsoluteInputEventWrapper*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.abs_event)
}

// optional .HU.RelativeInputEventWrapper rel_event = 6;
inline bool InputEvent::has_rel_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rel_event_ != nullptr);
  return value;
}
inline void InputEvent::clear_rel_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rel_event_ != nullptr) _impl_.rel_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HU::RelativeInputEventWrapper& InputEvent::_internal_rel_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::RelativeInputEventWrapper* p = _impl_.rel_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::RelativeInputEventWrapper&>(::HU::_RelativeInputEventWrapper_default_instance_);
}
inline const ::HU::RelativeInputEventWrapper& InputEvent::rel_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.InputEvent.rel_event)
  return _internal_rel_event();
}
inline void InputEvent::unsafe_arena_set_allocated_rel_event(::HU::RelativeInputEventWrapper* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rel_event_);
  }
  _impl_.rel_event_ = reinterpret_cast<::HU::RelativeInputEventWrapper*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.rel_event)
}
inline ::HU::RelativeInputEventWrapper* InputEvent::release_rel_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HU::RelativeInputEventWrapper* released = _impl_.rel_event_;
  _impl_.rel_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::RelativeInputEventWrapper* InputEvent::unsafe_arena_release_rel_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.InputEvent.rel_event)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HU::RelativeInputEventWrapper* temp = _impl_.rel_event_;
  _impl_.rel_event_ = nullptr;
  return temp;
}
inline ::HU::RelativeInputEventWrapper* InputEvent::_internal_mutable_rel_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rel_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::RelativeInputEventWrapper>(GetArena());
    _impl_.rel_event_ = reinterpret_cast<::HU::RelativeInputEventWrapper*>(p);
  }
  return _impl_.rel_event_;
}
inline ::HU::RelativeInputEventWrapper* InputEvent::mutable_rel_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::RelativeInputEventWrapper* _msg = _internal_mutable_rel_event();
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.rel_event)
  return _msg;
}
inline void InputEvent::set_allocated_rel_event(::HU::RelativeInputEventWrapper* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::RelativeInputEventWrapper*>(_impl_.rel_event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::RelativeInputEventWrapper*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.rel_event_ = reinterpret_cast<::HU::RelativeInputEventWrapper*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.rel_event)
}

// -------------------------------------------------------------------

// BindingRequest

// repeated int32 scan_codes = 1;
inline int BindingRequest::_internal_scan_codes_size() const {
  return _internal_scan_codes().size();
}
inline int BindingRequest::scan_codes_size() const {
  return _internal_scan_codes_size();
}
inline void BindingRequest::clear_scan_codes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scan_codes_.Clear();
}
inline ::int32_t BindingRequest::scan_codes(int index) const {
  // @@protoc_insertion_point(field_get:HU.BindingRequest.scan_codes)
  return _internal_scan_codes().Get(index);
}
inline void BindingRequest::set_scan_codes(int index, ::int32_t value) {
  _internal_mutable_scan_codes()->Set(index, value);
  // @@protoc_insertion_point(field_set:HU.BindingRequest.scan_codes)
}
inline void BindingRequest::add_scan_codes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scan_codes()->Add(value);
  // @@protoc_insertion_point(field_add:HU.BindingRequest.scan_codes)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& BindingRequest::scan_codes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.BindingRequest.scan_codes)
  return _internal_scan_codes();
}
inline ::google::protobuf::RepeatedField<::int32_t>* BindingRequest::mutable_scan_codes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.BindingRequest.scan_codes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scan_codes();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& BindingRequest::_internal_scan_codes()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scan_codes_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* BindingRequest::_internal_mutable_scan_codes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scan_codes_;
}

// -------------------------------------------------------------------

// BindingResponse

// required .HU.STATUS status = 1;
inline bool BindingResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BindingResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS BindingResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.BindingResponse.status)
  return _internal_status();
}
inline void BindingResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.BindingResponse.status)
}
inline ::HU::STATUS BindingResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::STATUS>(_impl_.status_);
}
inline void BindingResponse::_internal_set_status(::HU::STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_LocationData

// optional uint64 timestamp = 1;
inline bool SensorEvent_LocationData::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SensorEvent_LocationData::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.timestamp)
  return _internal_timestamp();
}
inline void SensorEvent_LocationData::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.timestamp)
}
inline ::uint64_t SensorEvent_LocationData::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void SensorEvent_LocationData::_internal_set_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}

// optional int32 latitude = 2;
inline bool SensorEvent_LocationData::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_LocationData::latitude() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.latitude)
  return _internal_latitude();
}
inline void SensorEvent_LocationData::set_latitude(::int32_t value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.latitude)
}
inline ::int32_t SensorEvent_LocationData::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void SensorEvent_LocationData::_internal_set_latitude(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_ = value;
}

// optional int32 longitude = 3;
inline bool SensorEvent_LocationData::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SensorEvent_LocationData::longitude() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.longitude)
  return _internal_longitude();
}
inline void SensorEvent_LocationData::set_longitude(::int32_t value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.longitude)
}
inline ::int32_t SensorEvent_LocationData::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void SensorEvent_LocationData::_internal_set_longitude(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.longitude_ = value;
}

// optional uint32 accuracy = 4;
inline bool SensorEvent_LocationData::has_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accuracy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t SensorEvent_LocationData::accuracy() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.accuracy)
  return _internal_accuracy();
}
inline void SensorEvent_LocationData::set_accuracy(::uint32_t value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.accuracy)
}
inline ::uint32_t SensorEvent_LocationData::_internal_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accuracy_;
}
inline void SensorEvent_LocationData::_internal_set_accuracy(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.accuracy_ = value;
}

// optional int32 altitude = 5;
inline bool SensorEvent_LocationData::has_altitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_altitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.altitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SensorEvent_LocationData::altitude() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.altitude)
  return _internal_altitude();
}
inline void SensorEvent_LocationData::set_altitude(::int32_t value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.altitude)
}
inline ::int32_t SensorEvent_LocationData::_internal_altitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.altitude_;
}
inline void SensorEvent_LocationData::_internal_set_altitude(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.altitude_ = value;
}

// optional int32 speed = 6;
inline bool SensorEvent_LocationData::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t SensorEvent_LocationData::speed() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.speed)
  return _internal_speed();
}
inline void SensorEvent_LocationData::set_speed(::int32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.speed)
}
inline ::int32_t SensorEvent_LocationData::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void SensorEvent_LocationData::_internal_set_speed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.speed_ = value;
}

// optional int32 bearing = 7;
inline bool SensorEvent_LocationData::has_bearing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SensorEvent_LocationData::clear_bearing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bearing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t SensorEvent_LocationData::bearing() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.bearing)
  return _internal_bearing();
}
inline void SensorEvent_LocationData::set_bearing(::int32_t value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.bearing)
}
inline ::int32_t SensorEvent_LocationData::_internal_bearing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bearing_;
}
inline void SensorEvent_LocationData::_internal_set_bearing(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.bearing_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_NightMode

// required bool is_night = 1;
inline bool SensorEvent_NightMode::has_is_night() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_NightMode::clear_is_night() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_night_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_NightMode::is_night() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.NightMode.is_night)
  return _internal_is_night();
}
inline void SensorEvent_NightMode::set_is_night(bool value) {
  _internal_set_is_night(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.NightMode.is_night)
}
inline bool SensorEvent_NightMode::_internal_is_night() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_night_;
}
inline void SensorEvent_NightMode::_internal_set_is_night(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.is_night_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_RPM

// required int32 rpm = 1;
inline bool SensorEvent_RPM::has_rpm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_RPM::clear_rpm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rpm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_RPM::rpm() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.RPM.rpm)
  return _internal_rpm();
}
inline void SensorEvent_RPM::set_rpm(::int32_t value) {
  _internal_set_rpm(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.RPM.rpm)
}
inline ::int32_t SensorEvent_RPM::_internal_rpm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rpm_;
}
inline void SensorEvent_RPM::_internal_set_rpm(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rpm_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_FuelLevel

// required int32 fuel_level = 1;
inline bool SensorEvent_FuelLevel::has_fuel_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_FuelLevel::clear_fuel_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fuel_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_FuelLevel::fuel_level() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.FuelLevel.fuel_level)
  return _internal_fuel_level();
}
inline void SensorEvent_FuelLevel::set_fuel_level(::int32_t value) {
  _internal_set_fuel_level(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.FuelLevel.fuel_level)
}
inline ::int32_t SensorEvent_FuelLevel::_internal_fuel_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fuel_level_;
}
inline void SensorEvent_FuelLevel::_internal_set_fuel_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fuel_level_ = value;
}

// optional int32 range = 2;
inline bool SensorEvent_FuelLevel::has_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_FuelLevel::clear_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_FuelLevel::range() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.FuelLevel.range)
  return _internal_range();
}
inline void SensorEvent_FuelLevel::set_range(::int32_t value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.FuelLevel.range)
}
inline ::int32_t SensorEvent_FuelLevel::_internal_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.range_;
}
inline void SensorEvent_FuelLevel::_internal_set_range(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.range_ = value;
}

// optional bool low_fuel = 3;
inline bool SensorEvent_FuelLevel::has_low_fuel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_FuelLevel::clear_low_fuel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.low_fuel_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SensorEvent_FuelLevel::low_fuel() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.FuelLevel.low_fuel)
  return _internal_low_fuel();
}
inline void SensorEvent_FuelLevel::set_low_fuel(bool value) {
  _internal_set_low_fuel(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.FuelLevel.low_fuel)
}
inline bool SensorEvent_FuelLevel::_internal_low_fuel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.low_fuel_;
}
inline void SensorEvent_FuelLevel::_internal_set_low_fuel(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.low_fuel_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_DrivingStatus

// required int32 status = 1;
inline bool SensorEvent_DrivingStatus::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_DrivingStatus::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_DrivingStatus::status() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.DrivingStatus.status)
  return _internal_status();
}
inline void SensorEvent_DrivingStatus::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.DrivingStatus.status)
}
inline ::int32_t SensorEvent_DrivingStatus::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void SensorEvent_DrivingStatus::_internal_set_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_DeadReckoning

// optional int32 steering_angel = 1;
inline bool SensorEvent_DeadReckoning::has_steering_angel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_DeadReckoning::clear_steering_angel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steering_angel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_DeadReckoning::steering_angel() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.DeadReckoning.steering_angel)
  return _internal_steering_angel();
}
inline void SensorEvent_DeadReckoning::set_steering_angel(::int32_t value) {
  _internal_set_steering_angel(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.DeadReckoning.steering_angel)
}
inline ::int32_t SensorEvent_DeadReckoning::_internal_steering_angel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steering_angel_;
}
inline void SensorEvent_DeadReckoning::_internal_set_steering_angel(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.steering_angel_ = value;
}

// optional int32 wheel_speed = 2;
inline bool SensorEvent_DeadReckoning::has_wheel_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_DeadReckoning::clear_wheel_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wheel_speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_DeadReckoning::wheel_speed() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.DeadReckoning.wheel_speed)
  return _internal_wheel_speed();
}
inline void SensorEvent_DeadReckoning::set_wheel_speed(::int32_t value) {
  _internal_set_wheel_speed(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.DeadReckoning.wheel_speed)
}
inline ::int32_t SensorEvent_DeadReckoning::_internal_wheel_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wheel_speed_;
}
inline void SensorEvent_DeadReckoning::_internal_set_wheel_speed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wheel_speed_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_CompassData

// optional int32 bearing_e6 = 1;
inline bool SensorEvent_CompassData::has_bearing_e6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_CompassData::clear_bearing_e6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bearing_e6_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_CompassData::bearing_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.CompassData.bearing_e6)
  return _internal_bearing_e6();
}
inline void SensorEvent_CompassData::set_bearing_e6(::int32_t value) {
  _internal_set_bearing_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.CompassData.bearing_e6)
}
inline ::int32_t SensorEvent_CompassData::_internal_bearing_e6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bearing_e6_;
}
inline void SensorEvent_CompassData::_internal_set_bearing_e6(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bearing_e6_ = value;
}

// optional int32 pitch_e6 = 2;
inline bool SensorEvent_CompassData::has_pitch_e6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_CompassData::clear_pitch_e6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pitch_e6_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_CompassData::pitch_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.CompassData.pitch_e6)
  return _internal_pitch_e6();
}
inline void SensorEvent_CompassData::set_pitch_e6(::int32_t value) {
  _internal_set_pitch_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.CompassData.pitch_e6)
}
inline ::int32_t SensorEvent_CompassData::_internal_pitch_e6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pitch_e6_;
}
inline void SensorEvent_CompassData::_internal_set_pitch_e6(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pitch_e6_ = value;
}

// optional int32 roll_e6 = 3;
inline bool SensorEvent_CompassData::has_roll_e6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_CompassData::clear_roll_e6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roll_e6_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SensorEvent_CompassData::roll_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.CompassData.roll_e6)
  return _internal_roll_e6();
}
inline void SensorEvent_CompassData::set_roll_e6(::int32_t value) {
  _internal_set_roll_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.CompassData.roll_e6)
}
inline ::int32_t SensorEvent_CompassData::_internal_roll_e6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roll_e6_;
}
inline void SensorEvent_CompassData::_internal_set_roll_e6(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.roll_e6_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_SpeedData

// optional int32 speed_e6 = 1;
inline bool SensorEvent_SpeedData::has_speed_e6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_SpeedData::clear_speed_e6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_e6_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_SpeedData::speed_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.SpeedData.speed_e6)
  return _internal_speed_e6();
}
inline void SensorEvent_SpeedData::set_speed_e6(::int32_t value) {
  _internal_set_speed_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.SpeedData.speed_e6)
}
inline ::int32_t SensorEvent_SpeedData::_internal_speed_e6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_e6_;
}
inline void SensorEvent_SpeedData::_internal_set_speed_e6(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.speed_e6_ = value;
}

// optional bool cruise_engaged = 2;
inline bool SensorEvent_SpeedData::has_cruise_engaged() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_SpeedData::clear_cruise_engaged() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cruise_engaged_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SensorEvent_SpeedData::cruise_engaged() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.SpeedData.cruise_engaged)
  return _internal_cruise_engaged();
}
inline void SensorEvent_SpeedData::set_cruise_engaged(bool value) {
  _internal_set_cruise_engaged(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.SpeedData.cruise_engaged)
}
inline bool SensorEvent_SpeedData::_internal_cruise_engaged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cruise_engaged_;
}
inline void SensorEvent_SpeedData::_internal_set_cruise_engaged(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cruise_engaged_ = value;
}

// optional bool cruise_set_speed = 3;
inline bool SensorEvent_SpeedData::has_cruise_set_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_SpeedData::clear_cruise_set_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cruise_set_speed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SensorEvent_SpeedData::cruise_set_speed() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.SpeedData.cruise_set_speed)
  return _internal_cruise_set_speed();
}
inline void SensorEvent_SpeedData::set_cruise_set_speed(bool value) {
  _internal_set_cruise_set_speed(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.SpeedData.cruise_set_speed)
}
inline bool SensorEvent_SpeedData::_internal_cruise_set_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cruise_set_speed_;
}
inline void SensorEvent_SpeedData::_internal_set_cruise_set_speed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cruise_set_speed_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_OdometerData

// optional int32 kms_el = 1;
inline bool SensorEvent_OdometerData::has_kms_el() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_OdometerData::clear_kms_el() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kms_el_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_OdometerData::kms_el() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.OdometerData.kms_el)
  return _internal_kms_el();
}
inline void SensorEvent_OdometerData::set_kms_el(::int32_t value) {
  _internal_set_kms_el(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.OdometerData.kms_el)
}
inline ::int32_t SensorEvent_OdometerData::_internal_kms_el() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kms_el_;
}
inline void SensorEvent_OdometerData::_internal_set_kms_el(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kms_el_ = value;
}

// optional int32 trip_kms_el = 2;
inline bool SensorEvent_OdometerData::has_trip_kms_el() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_OdometerData::clear_trip_kms_el() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trip_kms_el_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_OdometerData::trip_kms_el() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.OdometerData.trip_kms_el)
  return _internal_trip_kms_el();
}
inline void SensorEvent_OdometerData::set_trip_kms_el(::int32_t value) {
  _internal_set_trip_kms_el(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.OdometerData.trip_kms_el)
}
inline ::int32_t SensorEvent_OdometerData::_internal_trip_kms_el() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trip_kms_el_;
}
inline void SensorEvent_OdometerData::_internal_set_trip_kms_el(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.trip_kms_el_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_ParkingBreak

// optional bool parking_breake = 1;
inline bool SensorEvent_ParkingBreak::has_parking_breake() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_ParkingBreak::clear_parking_breake() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parking_breake_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_ParkingBreak::parking_breake() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.ParkingBreak.parking_breake)
  return _internal_parking_breake();
}
inline void SensorEvent_ParkingBreak::set_parking_breake(bool value) {
  _internal_set_parking_breake(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.ParkingBreak.parking_breake)
}
inline bool SensorEvent_ParkingBreak::_internal_parking_breake() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parking_breake_;
}
inline void SensorEvent_ParkingBreak::_internal_set_parking_breake(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parking_breake_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_Passenger

// optional bool passenger_present = 1;
inline bool SensorEvent_Passenger::has_passenger_present() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Passenger::clear_passenger_present() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passenger_present_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_Passenger::passenger_present() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Passenger.passenger_present)
  return _internal_passenger_present();
}
inline void SensorEvent_Passenger::set_passenger_present(bool value) {
  _internal_set_passenger_present(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Passenger.passenger_present)
}
inline bool SensorEvent_Passenger::_internal_passenger_present() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passenger_present_;
}
inline void SensorEvent_Passenger::_internal_set_passenger_present(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.passenger_present_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_Diagnostics

// optional bytes diagnostics_byte = 1;
inline bool SensorEvent_Diagnostics::has_diagnostics_byte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Diagnostics::clear_diagnostics_byte() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diagnostics_byte_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SensorEvent_Diagnostics::diagnostics_byte() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Diagnostics.diagnostics_byte)
  return _internal_diagnostics_byte();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorEvent_Diagnostics::set_diagnostics_byte(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.diagnostics_byte_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Diagnostics.diagnostics_byte)
}
inline std::string* SensorEvent_Diagnostics::mutable_diagnostics_byte() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_diagnostics_byte();
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.Diagnostics.diagnostics_byte)
  return _s;
}
inline const std::string& SensorEvent_Diagnostics::_internal_diagnostics_byte() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.diagnostics_byte_.Get();
}
inline void SensorEvent_Diagnostics::_internal_set_diagnostics_byte(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.diagnostics_byte_.Set(value, GetArena());
}
inline std::string* SensorEvent_Diagnostics::_internal_mutable_diagnostics_byte() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.diagnostics_byte_.Mutable( GetArena());
}
inline std::string* SensorEvent_Diagnostics::release_diagnostics_byte() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.SensorEvent.Diagnostics.diagnostics_byte)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.diagnostics_byte_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.diagnostics_byte_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SensorEvent_Diagnostics::set_allocated_diagnostics_byte(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.diagnostics_byte_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.diagnostics_byte_.IsDefault()) {
          _impl_.diagnostics_byte_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.SensorEvent.Diagnostics.diagnostics_byte)
}

// -------------------------------------------------------------------

// SensorEvent_Environment

// optional int32 temperature_e3 = 1;
inline bool SensorEvent_Environment::has_temperature_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Environment::clear_temperature_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.temperature_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_Environment::temperature_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Environment.temperature_e3)
  return _internal_temperature_e3();
}
inline void SensorEvent_Environment::set_temperature_e3(::int32_t value) {
  _internal_set_temperature_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Environment.temperature_e3)
}
inline ::int32_t SensorEvent_Environment::_internal_temperature_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.temperature_e3_;
}
inline void SensorEvent_Environment::_internal_set_temperature_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.temperature_e3_ = value;
}

// optional int32 pressure_e3 = 2;
inline bool SensorEvent_Environment::has_pressure_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_Environment::clear_pressure_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pressure_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_Environment::pressure_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Environment.pressure_e3)
  return _internal_pressure_e3();
}
inline void SensorEvent_Environment::set_pressure_e3(::int32_t value) {
  _internal_set_pressure_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Environment.pressure_e3)
}
inline ::int32_t SensorEvent_Environment::_internal_pressure_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pressure_e3_;
}
inline void SensorEvent_Environment::_internal_set_pressure_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pressure_e3_ = value;
}

// optional int32 rain = 3;
inline bool SensorEvent_Environment::has_rain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_Environment::clear_rain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rain_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SensorEvent_Environment::rain() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Environment.rain)
  return _internal_rain();
}
inline void SensorEvent_Environment::set_rain(::int32_t value) {
  _internal_set_rain(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Environment.rain)
}
inline ::int32_t SensorEvent_Environment::_internal_rain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rain_;
}
inline void SensorEvent_Environment::_internal_set_rain(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rain_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_HVAC

// optional int32 target_temperature_e3 = 1;
inline bool SensorEvent_HVAC::has_target_temperature_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_HVAC::clear_target_temperature_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_temperature_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_HVAC::target_temperature_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.HVAC.target_temperature_e3)
  return _internal_target_temperature_e3();
}
inline void SensorEvent_HVAC::set_target_temperature_e3(::int32_t value) {
  _internal_set_target_temperature_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.HVAC.target_temperature_e3)
}
inline ::int32_t SensorEvent_HVAC::_internal_target_temperature_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_temperature_e3_;
}
inline void SensorEvent_HVAC::_internal_set_target_temperature_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_temperature_e3_ = value;
}

// optional int32 current_temperature_e3 = 2;
inline bool SensorEvent_HVAC::has_current_temperature_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_HVAC::clear_current_temperature_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_temperature_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_HVAC::current_temperature_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.HVAC.current_temperature_e3)
  return _internal_current_temperature_e3();
}
inline void SensorEvent_HVAC::set_current_temperature_e3(::int32_t value) {
  _internal_set_current_temperature_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.HVAC.current_temperature_e3)
}
inline ::int32_t SensorEvent_HVAC::_internal_current_temperature_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_temperature_e3_;
}
inline void SensorEvent_HVAC::_internal_set_current_temperature_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.current_temperature_e3_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_Accel

// optional int32 acceleration_x_e3 = 1;
inline bool SensorEvent_Accel::has_acceleration_x_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Accel::clear_acceleration_x_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceleration_x_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_Accel::acceleration_x_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Accel.acceleration_x_e3)
  return _internal_acceleration_x_e3();
}
inline void SensorEvent_Accel::set_acceleration_x_e3(::int32_t value) {
  _internal_set_acceleration_x_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Accel.acceleration_x_e3)
}
inline ::int32_t SensorEvent_Accel::_internal_acceleration_x_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceleration_x_e3_;
}
inline void SensorEvent_Accel::_internal_set_acceleration_x_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.acceleration_x_e3_ = value;
}

// optional int32 acceleration_y_e3 = 2;
inline bool SensorEvent_Accel::has_acceleration_y_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_Accel::clear_acceleration_y_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceleration_y_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_Accel::acceleration_y_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Accel.acceleration_y_e3)
  return _internal_acceleration_y_e3();
}
inline void SensorEvent_Accel::set_acceleration_y_e3(::int32_t value) {
  _internal_set_acceleration_y_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Accel.acceleration_y_e3)
}
inline ::int32_t SensorEvent_Accel::_internal_acceleration_y_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceleration_y_e3_;
}
inline void SensorEvent_Accel::_internal_set_acceleration_y_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.acceleration_y_e3_ = value;
}

// optional int32 acceleration_z_e3 = 3;
inline bool SensorEvent_Accel::has_acceleration_z_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_Accel::clear_acceleration_z_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceleration_z_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SensorEvent_Accel::acceleration_z_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Accel.acceleration_z_e3)
  return _internal_acceleration_z_e3();
}
inline void SensorEvent_Accel::set_acceleration_z_e3(::int32_t value) {
  _internal_set_acceleration_z_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Accel.acceleration_z_e3)
}
inline ::int32_t SensorEvent_Accel::_internal_acceleration_z_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceleration_z_e3_;
}
inline void SensorEvent_Accel::_internal_set_acceleration_z_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.acceleration_z_e3_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_Gyro

// optional int32 rotation_speed_x_e3 = 1;
inline bool SensorEvent_Gyro::has_rotation_speed_x_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Gyro::clear_rotation_speed_x_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotation_speed_x_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SensorEvent_Gyro::rotation_speed_x_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Gyro.rotation_speed_x_e3)
  return _internal_rotation_speed_x_e3();
}
inline void SensorEvent_Gyro::set_rotation_speed_x_e3(::int32_t value) {
  _internal_set_rotation_speed_x_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Gyro.rotation_speed_x_e3)
}
inline ::int32_t SensorEvent_Gyro::_internal_rotation_speed_x_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotation_speed_x_e3_;
}
inline void SensorEvent_Gyro::_internal_set_rotation_speed_x_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rotation_speed_x_e3_ = value;
}

// optional int32 rotation_speed_y_e3 = 2;
inline bool SensorEvent_Gyro::has_rotation_speed_y_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_Gyro::clear_rotation_speed_y_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotation_speed_y_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SensorEvent_Gyro::rotation_speed_y_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Gyro.rotation_speed_y_e3)
  return _internal_rotation_speed_y_e3();
}
inline void SensorEvent_Gyro::set_rotation_speed_y_e3(::int32_t value) {
  _internal_set_rotation_speed_y_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Gyro.rotation_speed_y_e3)
}
inline ::int32_t SensorEvent_Gyro::_internal_rotation_speed_y_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotation_speed_y_e3_;
}
inline void SensorEvent_Gyro::_internal_set_rotation_speed_y_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rotation_speed_y_e3_ = value;
}

// optional int32 rotation_speed_z_e3 = 3;
inline bool SensorEvent_Gyro::has_rotation_speed_z_e3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_Gyro::clear_rotation_speed_z_e3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotation_speed_z_e3_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SensorEvent_Gyro::rotation_speed_z_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Gyro.rotation_speed_z_e3)
  return _internal_rotation_speed_z_e3();
}
inline void SensorEvent_Gyro::set_rotation_speed_z_e3(::int32_t value) {
  _internal_set_rotation_speed_z_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Gyro.rotation_speed_z_e3)
}
inline ::int32_t SensorEvent_Gyro::_internal_rotation_speed_z_e3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotation_speed_z_e3_;
}
inline void SensorEvent_Gyro::_internal_set_rotation_speed_z_e3(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rotation_speed_z_e3_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_Door

// optional bool hood_open = 1;
inline bool SensorEvent_Door::has_hood_open() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Door::clear_hood_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hood_open_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_Door::hood_open() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Door.hood_open)
  return _internal_hood_open();
}
inline void SensorEvent_Door::set_hood_open(bool value) {
  _internal_set_hood_open(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Door.hood_open)
}
inline bool SensorEvent_Door::_internal_hood_open() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hood_open_;
}
inline void SensorEvent_Door::_internal_set_hood_open(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hood_open_ = value;
}

// optional bool boot_open = 2;
inline bool SensorEvent_Door::has_boot_open() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_Door::clear_boot_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.boot_open_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SensorEvent_Door::boot_open() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Door.boot_open)
  return _internal_boot_open();
}
inline void SensorEvent_Door::set_boot_open(bool value) {
  _internal_set_boot_open(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Door.boot_open)
}
inline bool SensorEvent_Door::_internal_boot_open() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.boot_open_;
}
inline void SensorEvent_Door::_internal_set_boot_open(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.boot_open_ = value;
}

// repeated bool door_open = 3;
inline int SensorEvent_Door::_internal_door_open_size() const {
  return _internal_door_open().size();
}
inline int SensorEvent_Door::door_open_size() const {
  return _internal_door_open_size();
}
inline void SensorEvent_Door::clear_door_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.door_open_.Clear();
}
inline bool SensorEvent_Door::door_open(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Door.door_open)
  return _internal_door_open().Get(index);
}
inline void SensorEvent_Door::set_door_open(int index, bool value) {
  _internal_mutable_door_open()->Set(index, value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Door.door_open)
}
inline void SensorEvent_Door::add_door_open(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_door_open()->Add(value);
  // @@protoc_insertion_point(field_add:HU.SensorEvent.Door.door_open)
}
inline const ::google::protobuf::RepeatedField<bool>& SensorEvent_Door::door_open() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.Door.door_open)
  return _internal_door_open();
}
inline ::google::protobuf::RepeatedField<bool>* SensorEvent_Door::mutable_door_open()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.Door.door_open)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_door_open();
}
inline const ::google::protobuf::RepeatedField<bool>& SensorEvent_Door::_internal_door_open()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.door_open_;
}
inline ::google::protobuf::RepeatedField<bool>* SensorEvent_Door::_internal_mutable_door_open() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.door_open_;
}

// -------------------------------------------------------------------

// SensorEvent_Light

// optional .HU.SensorEvent.Light.HEADLIGHT_STATE headlight = 1;
inline bool SensorEvent_Light::has_headlight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_Light::clear_headlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headlight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light::headlight() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Light.headlight)
  return _internal_headlight();
}
inline void SensorEvent_Light::set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value) {
  _internal_set_headlight(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Light.headlight)
}
inline ::HU::SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light::_internal_headlight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::SensorEvent_Light_HEADLIGHT_STATE>(_impl_.headlight_);
}
inline void SensorEvent_Light::_internal_set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::SensorEvent_Light_HEADLIGHT_STATE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.headlight_ = value;
}

// optional .HU.SensorEvent.Light.TURN_INDICATOR_STATE turn_indicator = 2;
inline bool SensorEvent_Light::has_turn_indicator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorEvent_Light::clear_turn_indicator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_indicator_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light::turn_indicator() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Light.turn_indicator)
  return _internal_turn_indicator();
}
inline void SensorEvent_Light::set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value) {
  _internal_set_turn_indicator(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Light.turn_indicator)
}
inline ::HU::SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light::_internal_turn_indicator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::SensorEvent_Light_TURN_INDICATOR_STATE>(_impl_.turn_indicator_);
}
inline void SensorEvent_Light::_internal_set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::SensorEvent_Light_TURN_INDICATOR_STATE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.turn_indicator_ = value;
}

// optional bool hazard_light_on = 3;
inline bool SensorEvent_Light::has_hazard_light_on() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SensorEvent_Light::clear_hazard_light_on() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hazard_light_on_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SensorEvent_Light::hazard_light_on() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Light.hazard_light_on)
  return _internal_hazard_light_on();
}
inline void SensorEvent_Light::set_hazard_light_on(bool value) {
  _internal_set_hazard_light_on(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Light.hazard_light_on)
}
inline bool SensorEvent_Light::_internal_hazard_light_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hazard_light_on_;
}
inline void SensorEvent_Light::_internal_set_hazard_light_on(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hazard_light_on_ = value;
}

// -------------------------------------------------------------------

// SensorEvent_GearData

// required .HU.SensorEvent.GearData.GEAR gear = 1;
inline bool SensorEvent_GearData::has_gear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorEvent_GearData::clear_gear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gear_ = 100;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::SensorEvent_GearData_GEAR SensorEvent_GearData::gear() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.GearData.gear)
  return _internal_gear();
}
inline void SensorEvent_GearData::set_gear(::HU::SensorEvent_GearData_GEAR value) {
  _internal_set_gear(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.GearData.gear)
}
inline ::HU::SensorEvent_GearData_GEAR SensorEvent_GearData::_internal_gear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::SensorEvent_GearData_GEAR>(_impl_.gear_);
}
inline void SensorEvent_GearData::_internal_set_gear(::HU::SensorEvent_GearData_GEAR value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::SensorEvent_GearData_GEAR_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gear_ = value;
}

// -------------------------------------------------------------------

// SensorEvent

// repeated .HU.SensorEvent.LocationData location_data = 1;
inline int SensorEvent::_internal_location_data_size() const {
  return _internal_location_data().size();
}
inline int SensorEvent::location_data_size() const {
  return _internal_location_data_size();
}
inline void SensorEvent::clear_location_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_data_.Clear();
}
inline ::HU::SensorEvent_LocationData* SensorEvent::mutable_location_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.location_data)
  return _internal_mutable_location_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_LocationData>* SensorEvent::mutable_location_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.location_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_location_data();
}
inline const ::HU::SensorEvent_LocationData& SensorEvent::location_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.location_data)
  return _internal_location_data().Get(index);
}
inline ::HU::SensorEvent_LocationData* SensorEvent::add_location_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_LocationData* _add = _internal_mutable_location_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.location_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_LocationData>& SensorEvent::location_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.location_data)
  return _internal_location_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_LocationData>&
SensorEvent::_internal_location_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_LocationData>*
SensorEvent::_internal_mutable_location_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.location_data_;
}

// repeated .HU.SensorEvent.CompassData compass_data = 2;
inline int SensorEvent::_internal_compass_data_size() const {
  return _internal_compass_data().size();
}
inline int SensorEvent::compass_data_size() const {
  return _internal_compass_data_size();
}
inline void SensorEvent::clear_compass_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compass_data_.Clear();
}
inline ::HU::SensorEvent_CompassData* SensorEvent::mutable_compass_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.compass_data)
  return _internal_mutable_compass_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_CompassData>* SensorEvent::mutable_compass_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.compass_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_compass_data();
}
inline const ::HU::SensorEvent_CompassData& SensorEvent::compass_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.compass_data)
  return _internal_compass_data().Get(index);
}
inline ::HU::SensorEvent_CompassData* SensorEvent::add_compass_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_CompassData* _add = _internal_mutable_compass_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.compass_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_CompassData>& SensorEvent::compass_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.compass_data)
  return _internal_compass_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_CompassData>&
SensorEvent::_internal_compass_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compass_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_CompassData>*
SensorEvent::_internal_mutable_compass_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.compass_data_;
}

// repeated .HU.SensorEvent.SpeedData speed_data = 3;
inline int SensorEvent::_internal_speed_data_size() const {
  return _internal_speed_data().size();
}
inline int SensorEvent::speed_data_size() const {
  return _internal_speed_data_size();
}
inline void SensorEvent::clear_speed_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_data_.Clear();
}
inline ::HU::SensorEvent_SpeedData* SensorEvent::mutable_speed_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.speed_data)
  return _internal_mutable_speed_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_SpeedData>* SensorEvent::mutable_speed_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.speed_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_speed_data();
}
inline const ::HU::SensorEvent_SpeedData& SensorEvent::speed_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.speed_data)
  return _internal_speed_data().Get(index);
}
inline ::HU::SensorEvent_SpeedData* SensorEvent::add_speed_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_SpeedData* _add = _internal_mutable_speed_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.speed_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_SpeedData>& SensorEvent::speed_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.speed_data)
  return _internal_speed_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_SpeedData>&
SensorEvent::_internal_speed_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_SpeedData>*
SensorEvent::_internal_mutable_speed_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.speed_data_;
}

// repeated .HU.SensorEvent.RPM rpm = 4;
inline int SensorEvent::_internal_rpm_size() const {
  return _internal_rpm().size();
}
inline int SensorEvent::rpm_size() const {
  return _internal_rpm_size();
}
inline void SensorEvent::clear_rpm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rpm_.Clear();
}
inline ::HU::SensorEvent_RPM* SensorEvent::mutable_rpm(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.rpm)
  return _internal_mutable_rpm()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_RPM>* SensorEvent::mutable_rpm()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.rpm)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rpm();
}
inline const ::HU::SensorEvent_RPM& SensorEvent::rpm(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.rpm)
  return _internal_rpm().Get(index);
}
inline ::HU::SensorEvent_RPM* SensorEvent::add_rpm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_RPM* _add = _internal_mutable_rpm()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.rpm)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_RPM>& SensorEvent::rpm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.rpm)
  return _internal_rpm();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_RPM>&
SensorEvent::_internal_rpm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rpm_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_RPM>*
SensorEvent::_internal_mutable_rpm() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rpm_;
}

// repeated .HU.SensorEvent.OdometerData odometer_data = 5;
inline int SensorEvent::_internal_odometer_data_size() const {
  return _internal_odometer_data().size();
}
inline int SensorEvent::odometer_data_size() const {
  return _internal_odometer_data_size();
}
inline void SensorEvent::clear_odometer_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.odometer_data_.Clear();
}
inline ::HU::SensorEvent_OdometerData* SensorEvent::mutable_odometer_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.odometer_data)
  return _internal_mutable_odometer_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_OdometerData>* SensorEvent::mutable_odometer_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.odometer_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_odometer_data();
}
inline const ::HU::SensorEvent_OdometerData& SensorEvent::odometer_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.odometer_data)
  return _internal_odometer_data().Get(index);
}
inline ::HU::SensorEvent_OdometerData* SensorEvent::add_odometer_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_OdometerData* _add = _internal_mutable_odometer_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.odometer_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_OdometerData>& SensorEvent::odometer_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.odometer_data)
  return _internal_odometer_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_OdometerData>&
SensorEvent::_internal_odometer_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.odometer_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_OdometerData>*
SensorEvent::_internal_mutable_odometer_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.odometer_data_;
}

// repeated .HU.SensorEvent.FuelLevel fuel_data = 6;
inline int SensorEvent::_internal_fuel_data_size() const {
  return _internal_fuel_data().size();
}
inline int SensorEvent::fuel_data_size() const {
  return _internal_fuel_data_size();
}
inline void SensorEvent::clear_fuel_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fuel_data_.Clear();
}
inline ::HU::SensorEvent_FuelLevel* SensorEvent::mutable_fuel_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.fuel_data)
  return _internal_mutable_fuel_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_FuelLevel>* SensorEvent::mutable_fuel_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.fuel_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fuel_data();
}
inline const ::HU::SensorEvent_FuelLevel& SensorEvent::fuel_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.fuel_data)
  return _internal_fuel_data().Get(index);
}
inline ::HU::SensorEvent_FuelLevel* SensorEvent::add_fuel_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_FuelLevel* _add = _internal_mutable_fuel_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.fuel_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_FuelLevel>& SensorEvent::fuel_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.fuel_data)
  return _internal_fuel_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_FuelLevel>&
SensorEvent::_internal_fuel_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fuel_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_FuelLevel>*
SensorEvent::_internal_mutable_fuel_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fuel_data_;
}

// repeated .HU.SensorEvent.ParkingBreak parkingbrake_data = 7;
inline int SensorEvent::_internal_parkingbrake_data_size() const {
  return _internal_parkingbrake_data().size();
}
inline int SensorEvent::parkingbrake_data_size() const {
  return _internal_parkingbrake_data_size();
}
inline void SensorEvent::clear_parkingbrake_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parkingbrake_data_.Clear();
}
inline ::HU::SensorEvent_ParkingBreak* SensorEvent::mutable_parkingbrake_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.parkingbrake_data)
  return _internal_mutable_parkingbrake_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_ParkingBreak>* SensorEvent::mutable_parkingbrake_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.parkingbrake_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parkingbrake_data();
}
inline const ::HU::SensorEvent_ParkingBreak& SensorEvent::parkingbrake_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.parkingbrake_data)
  return _internal_parkingbrake_data().Get(index);
}
inline ::HU::SensorEvent_ParkingBreak* SensorEvent::add_parkingbrake_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_ParkingBreak* _add = _internal_mutable_parkingbrake_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.parkingbrake_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_ParkingBreak>& SensorEvent::parkingbrake_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.parkingbrake_data)
  return _internal_parkingbrake_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_ParkingBreak>&
SensorEvent::_internal_parkingbrake_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parkingbrake_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_ParkingBreak>*
SensorEvent::_internal_mutable_parkingbrake_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parkingbrake_data_;
}

// repeated .HU.SensorEvent.GearData gear_data = 8;
inline int SensorEvent::_internal_gear_data_size() const {
  return _internal_gear_data().size();
}
inline int SensorEvent::gear_data_size() const {
  return _internal_gear_data_size();
}
inline void SensorEvent::clear_gear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gear_data_.Clear();
}
inline ::HU::SensorEvent_GearData* SensorEvent::mutable_gear_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.gear_data)
  return _internal_mutable_gear_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_GearData>* SensorEvent::mutable_gear_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.gear_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gear_data();
}
inline const ::HU::SensorEvent_GearData& SensorEvent::gear_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.gear_data)
  return _internal_gear_data().Get(index);
}
inline ::HU::SensorEvent_GearData* SensorEvent::add_gear_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_GearData* _add = _internal_mutable_gear_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.gear_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_GearData>& SensorEvent::gear_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.gear_data)
  return _internal_gear_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_GearData>&
SensorEvent::_internal_gear_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gear_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_GearData>*
SensorEvent::_internal_mutable_gear_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gear_data_;
}

// repeated .HU.SensorEvent.Diagnostics diagnostics_data = 9;
inline int SensorEvent::_internal_diagnostics_data_size() const {
  return _internal_diagnostics_data().size();
}
inline int SensorEvent::diagnostics_data_size() const {
  return _internal_diagnostics_data_size();
}
inline void SensorEvent::clear_diagnostics_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diagnostics_data_.Clear();
}
inline ::HU::SensorEvent_Diagnostics* SensorEvent::mutable_diagnostics_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.diagnostics_data)
  return _internal_mutable_diagnostics_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Diagnostics>* SensorEvent::mutable_diagnostics_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.diagnostics_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_diagnostics_data();
}
inline const ::HU::SensorEvent_Diagnostics& SensorEvent::diagnostics_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.diagnostics_data)
  return _internal_diagnostics_data().Get(index);
}
inline ::HU::SensorEvent_Diagnostics* SensorEvent::add_diagnostics_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Diagnostics* _add = _internal_mutable_diagnostics_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.diagnostics_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Diagnostics>& SensorEvent::diagnostics_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.diagnostics_data)
  return _internal_diagnostics_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Diagnostics>&
SensorEvent::_internal_diagnostics_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.diagnostics_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Diagnostics>*
SensorEvent::_internal_mutable_diagnostics_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.diagnostics_data_;
}

// repeated .HU.SensorEvent.NightMode night_mode = 10;
inline int SensorEvent::_internal_night_mode_size() const {
  return _internal_night_mode().size();
}
inline int SensorEvent::night_mode_size() const {
  return _internal_night_mode_size();
}
inline void SensorEvent::clear_night_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.night_mode_.Clear();
}
inline ::HU::SensorEvent_NightMode* SensorEvent::mutable_night_mode(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.night_mode)
  return _internal_mutable_night_mode()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_NightMode>* SensorEvent::mutable_night_mode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.night_mode)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_night_mode();
}
inline const ::HU::SensorEvent_NightMode& SensorEvent::night_mode(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.night_mode)
  return _internal_night_mode().Get(index);
}
inline ::HU::SensorEvent_NightMode* SensorEvent::add_night_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_NightMode* _add = _internal_mutable_night_mode()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.night_mode)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_NightMode>& SensorEvent::night_mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.night_mode)
  return _internal_night_mode();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_NightMode>&
SensorEvent::_internal_night_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.night_mode_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_NightMode>*
SensorEvent::_internal_mutable_night_mode() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.night_mode_;
}

// repeated .HU.SensorEvent.Environment enviorment_data = 11;
inline int SensorEvent::_internal_enviorment_data_size() const {
  return _internal_enviorment_data().size();
}
inline int SensorEvent::enviorment_data_size() const {
  return _internal_enviorment_data_size();
}
inline void SensorEvent::clear_enviorment_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enviorment_data_.Clear();
}
inline ::HU::SensorEvent_Environment* SensorEvent::mutable_enviorment_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.enviorment_data)
  return _internal_mutable_enviorment_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Environment>* SensorEvent::mutable_enviorment_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.enviorment_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_enviorment_data();
}
inline const ::HU::SensorEvent_Environment& SensorEvent::enviorment_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.enviorment_data)
  return _internal_enviorment_data().Get(index);
}
inline ::HU::SensorEvent_Environment* SensorEvent::add_enviorment_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Environment* _add = _internal_mutable_enviorment_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.enviorment_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Environment>& SensorEvent::enviorment_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.enviorment_data)
  return _internal_enviorment_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Environment>&
SensorEvent::_internal_enviorment_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enviorment_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Environment>*
SensorEvent::_internal_mutable_enviorment_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.enviorment_data_;
}

// repeated .HU.SensorEvent.HVAC hvac_data = 12;
inline int SensorEvent::_internal_hvac_data_size() const {
  return _internal_hvac_data().size();
}
inline int SensorEvent::hvac_data_size() const {
  return _internal_hvac_data_size();
}
inline void SensorEvent::clear_hvac_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hvac_data_.Clear();
}
inline ::HU::SensorEvent_HVAC* SensorEvent::mutable_hvac_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.hvac_data)
  return _internal_mutable_hvac_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_HVAC>* SensorEvent::mutable_hvac_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.hvac_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hvac_data();
}
inline const ::HU::SensorEvent_HVAC& SensorEvent::hvac_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.hvac_data)
  return _internal_hvac_data().Get(index);
}
inline ::HU::SensorEvent_HVAC* SensorEvent::add_hvac_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_HVAC* _add = _internal_mutable_hvac_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.hvac_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_HVAC>& SensorEvent::hvac_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.hvac_data)
  return _internal_hvac_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_HVAC>&
SensorEvent::_internal_hvac_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hvac_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_HVAC>*
SensorEvent::_internal_mutable_hvac_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hvac_data_;
}

// repeated .HU.SensorEvent.DrivingStatus driving_status = 13;
inline int SensorEvent::_internal_driving_status_size() const {
  return _internal_driving_status().size();
}
inline int SensorEvent::driving_status_size() const {
  return _internal_driving_status_size();
}
inline void SensorEvent::clear_driving_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driving_status_.Clear();
}
inline ::HU::SensorEvent_DrivingStatus* SensorEvent::mutable_driving_status(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.driving_status)
  return _internal_mutable_driving_status()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DrivingStatus>* SensorEvent::mutable_driving_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.driving_status)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_driving_status();
}
inline const ::HU::SensorEvent_DrivingStatus& SensorEvent::driving_status(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.driving_status)
  return _internal_driving_status().Get(index);
}
inline ::HU::SensorEvent_DrivingStatus* SensorEvent::add_driving_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_DrivingStatus* _add = _internal_mutable_driving_status()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.driving_status)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DrivingStatus>& SensorEvent::driving_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.driving_status)
  return _internal_driving_status();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DrivingStatus>&
SensorEvent::_internal_driving_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driving_status_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DrivingStatus>*
SensorEvent::_internal_mutable_driving_status() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.driving_status_;
}

// repeated .HU.SensorEvent.DeadReckoning dead_reckoning = 14;
inline int SensorEvent::_internal_dead_reckoning_size() const {
  return _internal_dead_reckoning().size();
}
inline int SensorEvent::dead_reckoning_size() const {
  return _internal_dead_reckoning_size();
}
inline void SensorEvent::clear_dead_reckoning() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dead_reckoning_.Clear();
}
inline ::HU::SensorEvent_DeadReckoning* SensorEvent::mutable_dead_reckoning(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.dead_reckoning)
  return _internal_mutable_dead_reckoning()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DeadReckoning>* SensorEvent::mutable_dead_reckoning()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.dead_reckoning)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dead_reckoning();
}
inline const ::HU::SensorEvent_DeadReckoning& SensorEvent::dead_reckoning(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.dead_reckoning)
  return _internal_dead_reckoning().Get(index);
}
inline ::HU::SensorEvent_DeadReckoning* SensorEvent::add_dead_reckoning() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_DeadReckoning* _add = _internal_mutable_dead_reckoning()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.dead_reckoning)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DeadReckoning>& SensorEvent::dead_reckoning() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.dead_reckoning)
  return _internal_dead_reckoning();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DeadReckoning>&
SensorEvent::_internal_dead_reckoning() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dead_reckoning_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_DeadReckoning>*
SensorEvent::_internal_mutable_dead_reckoning() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dead_reckoning_;
}

// repeated .HU.SensorEvent.Passenger passenger_data = 15;
inline int SensorEvent::_internal_passenger_data_size() const {
  return _internal_passenger_data().size();
}
inline int SensorEvent::passenger_data_size() const {
  return _internal_passenger_data_size();
}
inline void SensorEvent::clear_passenger_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passenger_data_.Clear();
}
inline ::HU::SensorEvent_Passenger* SensorEvent::mutable_passenger_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.passenger_data)
  return _internal_mutable_passenger_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Passenger>* SensorEvent::mutable_passenger_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.passenger_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_passenger_data();
}
inline const ::HU::SensorEvent_Passenger& SensorEvent::passenger_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.passenger_data)
  return _internal_passenger_data().Get(index);
}
inline ::HU::SensorEvent_Passenger* SensorEvent::add_passenger_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Passenger* _add = _internal_mutable_passenger_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.passenger_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Passenger>& SensorEvent::passenger_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.passenger_data)
  return _internal_passenger_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Passenger>&
SensorEvent::_internal_passenger_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passenger_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Passenger>*
SensorEvent::_internal_mutable_passenger_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.passenger_data_;
}

// repeated .HU.SensorEvent.Door door_data = 16;
inline int SensorEvent::_internal_door_data_size() const {
  return _internal_door_data().size();
}
inline int SensorEvent::door_data_size() const {
  return _internal_door_data_size();
}
inline void SensorEvent::clear_door_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.door_data_.Clear();
}
inline ::HU::SensorEvent_Door* SensorEvent::mutable_door_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.door_data)
  return _internal_mutable_door_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Door>* SensorEvent::mutable_door_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.door_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_door_data();
}
inline const ::HU::SensorEvent_Door& SensorEvent::door_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.door_data)
  return _internal_door_data().Get(index);
}
inline ::HU::SensorEvent_Door* SensorEvent::add_door_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Door* _add = _internal_mutable_door_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.door_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Door>& SensorEvent::door_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.door_data)
  return _internal_door_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Door>&
SensorEvent::_internal_door_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.door_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Door>*
SensorEvent::_internal_mutable_door_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.door_data_;
}

// repeated .HU.SensorEvent.Light light_data = 17;
inline int SensorEvent::_internal_light_data_size() const {
  return _internal_light_data().size();
}
inline int SensorEvent::light_data_size() const {
  return _internal_light_data_size();
}
inline void SensorEvent::clear_light_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.light_data_.Clear();
}
inline ::HU::SensorEvent_Light* SensorEvent::mutable_light_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.light_data)
  return _internal_mutable_light_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Light>* SensorEvent::mutable_light_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.light_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_light_data();
}
inline const ::HU::SensorEvent_Light& SensorEvent::light_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.light_data)
  return _internal_light_data().Get(index);
}
inline ::HU::SensorEvent_Light* SensorEvent::add_light_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Light* _add = _internal_mutable_light_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.light_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Light>& SensorEvent::light_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.light_data)
  return _internal_light_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Light>&
SensorEvent::_internal_light_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.light_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Light>*
SensorEvent::_internal_mutable_light_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.light_data_;
}

// repeated .HU.SensorEvent.Accel accel_data = 19;
inline int SensorEvent::_internal_accel_data_size() const {
  return _internal_accel_data().size();
}
inline int SensorEvent::accel_data_size() const {
  return _internal_accel_data_size();
}
inline void SensorEvent::clear_accel_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accel_data_.Clear();
}
inline ::HU::SensorEvent_Accel* SensorEvent::mutable_accel_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.accel_data)
  return _internal_mutable_accel_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Accel>* SensorEvent::mutable_accel_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.accel_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_accel_data();
}
inline const ::HU::SensorEvent_Accel& SensorEvent::accel_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.accel_data)
  return _internal_accel_data().Get(index);
}
inline ::HU::SensorEvent_Accel* SensorEvent::add_accel_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Accel* _add = _internal_mutable_accel_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.accel_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Accel>& SensorEvent::accel_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.accel_data)
  return _internal_accel_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Accel>&
SensorEvent::_internal_accel_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accel_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Accel>*
SensorEvent::_internal_mutable_accel_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.accel_data_;
}

// repeated .HU.SensorEvent.Gyro gyro_data = 20;
inline int SensorEvent::_internal_gyro_data_size() const {
  return _internal_gyro_data().size();
}
inline int SensorEvent::gyro_data_size() const {
  return _internal_gyro_data_size();
}
inline void SensorEvent::clear_gyro_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gyro_data_.Clear();
}
inline ::HU::SensorEvent_Gyro* SensorEvent::mutable_gyro_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.gyro_data)
  return _internal_mutable_gyro_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Gyro>* SensorEvent::mutable_gyro_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.gyro_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gyro_data();
}
inline const ::HU::SensorEvent_Gyro& SensorEvent::gyro_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.gyro_data)
  return _internal_gyro_data().Get(index);
}
inline ::HU::SensorEvent_Gyro* SensorEvent::add_gyro_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::SensorEvent_Gyro* _add = _internal_mutable_gyro_data()->Add();
  // @@protoc_insertion_point(field_add:HU.SensorEvent.gyro_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Gyro>& SensorEvent::gyro_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.gyro_data)
  return _internal_gyro_data();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Gyro>&
SensorEvent::_internal_gyro_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gyro_data_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::SensorEvent_Gyro>*
SensorEvent::_internal_mutable_gyro_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gyro_data_;
}

// -------------------------------------------------------------------

// AudioCofig

// required uint32 sample_rate = 1;
inline bool AudioCofig::has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AudioCofig::clear_sample_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AudioCofig::sample_rate() const {
  // @@protoc_insertion_point(field_get:HU.AudioCofig.sample_rate)
  return _internal_sample_rate();
}
inline void AudioCofig::set_sample_rate(::uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:HU.AudioCofig.sample_rate)
}
inline ::uint32_t AudioCofig::_internal_sample_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_;
}
inline void AudioCofig::_internal_set_sample_rate(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sample_rate_ = value;
}

// required uint32 bit_depth = 2;
inline bool AudioCofig::has_bit_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AudioCofig::clear_bit_depth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bit_depth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AudioCofig::bit_depth() const {
  // @@protoc_insertion_point(field_get:HU.AudioCofig.bit_depth)
  return _internal_bit_depth();
}
inline void AudioCofig::set_bit_depth(::uint32_t value) {
  _internal_set_bit_depth(value);
  // @@protoc_insertion_point(field_set:HU.AudioCofig.bit_depth)
}
inline ::uint32_t AudioCofig::_internal_bit_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bit_depth_;
}
inline void AudioCofig::_internal_set_bit_depth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bit_depth_ = value;
}

// required uint32 channel_count = 3;
inline bool AudioCofig::has_channel_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AudioCofig::clear_channel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AudioCofig::channel_count() const {
  // @@protoc_insertion_point(field_get:HU.AudioCofig.channel_count)
  return _internal_channel_count();
}
inline void AudioCofig::set_channel_count(::uint32_t value) {
  _internal_set_channel_count(value);
  // @@protoc_insertion_point(field_set:HU.AudioCofig.channel_count)
}
inline ::uint32_t AudioCofig::_internal_channel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_count_;
}
inline void AudioCofig::_internal_set_channel_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_count_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_SensorChannel_Sensor

// optional .HU.SENSOR_TYPE type = 1;
inline bool ChannelDescriptor_SensorChannel_Sensor::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_SensorChannel_Sensor::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::SENSOR_TYPE ChannelDescriptor_SensorChannel_Sensor::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.SensorChannel.Sensor.type)
  return _internal_type();
}
inline void ChannelDescriptor_SensorChannel_Sensor::set_type(::HU::SENSOR_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.SensorChannel.Sensor.type)
}
inline ::HU::SENSOR_TYPE ChannelDescriptor_SensorChannel_Sensor::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::SENSOR_TYPE>(_impl_.type_);
}
inline void ChannelDescriptor_SensorChannel_Sensor::_internal_set_type(::HU::SENSOR_TYPE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::SENSOR_TYPE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_SensorChannel

// repeated .HU.ChannelDescriptor.SensorChannel.Sensor sensor_list = 1;
inline int ChannelDescriptor_SensorChannel::_internal_sensor_list_size() const {
  return _internal_sensor_list().size();
}
inline int ChannelDescriptor_SensorChannel::sensor_list_size() const {
  return _internal_sensor_list_size();
}
inline void ChannelDescriptor_SensorChannel::clear_sensor_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_list_.Clear();
}
inline ::HU::ChannelDescriptor_SensorChannel_Sensor* ChannelDescriptor_SensorChannel::mutable_sensor_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return _internal_mutable_sensor_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_SensorChannel_Sensor>* ChannelDescriptor_SensorChannel::mutable_sensor_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.SensorChannel.sensor_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor_list();
}
inline const ::HU::ChannelDescriptor_SensorChannel_Sensor& ChannelDescriptor_SensorChannel::sensor_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return _internal_sensor_list().Get(index);
}
inline ::HU::ChannelDescriptor_SensorChannel_Sensor* ChannelDescriptor_SensorChannel::add_sensor_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::ChannelDescriptor_SensorChannel_Sensor* _add = _internal_mutable_sensor_list()->Add();
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_SensorChannel_Sensor>& ChannelDescriptor_SensorChannel::sensor_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return _internal_sensor_list();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_SensorChannel_Sensor>&
ChannelDescriptor_SensorChannel::_internal_sensor_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_list_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_SensorChannel_Sensor>*
ChannelDescriptor_SensorChannel::_internal_mutable_sensor_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_list_;
}

// -------------------------------------------------------------------

// ChannelDescriptor_OutputStreamChannel_VideoConfig

// required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_RESOLUTION resolution = 1;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_resolution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resolution_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig::resolution() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.resolution)
  return _internal_resolution();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.resolution)
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_resolution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>(_impl_.resolution_);
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.resolution_ = value;
}

// required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_FPS frame_rate = 2;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_frame_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_frame_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_rate_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig::frame_rate() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.frame_rate)
  return _internal_frame_rate();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.frame_rate)
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_frame_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>(_impl_.frame_rate_);
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.frame_rate_ = value;
}

// required uint32 margin_width = 3;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_margin_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_margin_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.margin_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::margin_width() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_width)
  return _internal_margin_width();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_margin_width(::uint32_t value) {
  _internal_set_margin_width(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_width)
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_margin_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.margin_width_;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_margin_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.margin_width_ = value;
}

// required uint32 margin_height = 4;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_margin_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_margin_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.margin_height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::margin_height() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_height)
  return _internal_margin_height();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_margin_height(::uint32_t value) {
  _internal_set_margin_height(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_height)
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_margin_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.margin_height_;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_margin_height(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.margin_height_ = value;
}

// required uint32 dpi = 5;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_dpi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_dpi() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dpi_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::dpi() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.dpi)
  return _internal_dpi();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_dpi(::uint32_t value) {
  _internal_set_dpi(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.dpi)
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_dpi() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dpi_;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_dpi(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dpi_ = value;
}

// optional uint32 additional_depth = 6;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_additional_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_additional_depth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.additional_depth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::additional_depth() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.additional_depth)
  return _internal_additional_depth();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_additional_depth(::uint32_t value) {
  _internal_set_additional_depth(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.additional_depth)
}
inline ::uint32_t ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_additional_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.additional_depth_;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_additional_depth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.additional_depth_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_OutputStreamChannel

// required .HU.STREAM_TYPE type = 1;
inline bool ChannelDescriptor_OutputStreamChannel::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::STREAM_TYPE ChannelDescriptor_OutputStreamChannel::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.type)
  return _internal_type();
}
inline void ChannelDescriptor_OutputStreamChannel::set_type(::HU::STREAM_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.type)
}
inline ::HU::STREAM_TYPE ChannelDescriptor_OutputStreamChannel::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::STREAM_TYPE>(_impl_.type_);
}
inline void ChannelDescriptor_OutputStreamChannel::_internal_set_type(::HU::STREAM_TYPE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::STREAM_TYPE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .HU.AUDIO_TYPE audio_type = 2;
inline bool ChannelDescriptor_OutputStreamChannel::has_audio_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel::clear_audio_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HU::AUDIO_TYPE ChannelDescriptor_OutputStreamChannel::audio_type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.audio_type)
  return _internal_audio_type();
}
inline void ChannelDescriptor_OutputStreamChannel::set_audio_type(::HU::AUDIO_TYPE value) {
  _internal_set_audio_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.audio_type)
}
inline ::HU::AUDIO_TYPE ChannelDescriptor_OutputStreamChannel::_internal_audio_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::AUDIO_TYPE>(_impl_.audio_type_);
}
inline void ChannelDescriptor_OutputStreamChannel::_internal_set_audio_type(::HU::AUDIO_TYPE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::AUDIO_TYPE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.audio_type_ = value;
}

// repeated .HU.AudioCofig audio_configs = 3;
inline int ChannelDescriptor_OutputStreamChannel::_internal_audio_configs_size() const {
  return _internal_audio_configs().size();
}
inline int ChannelDescriptor_OutputStreamChannel::audio_configs_size() const {
  return _internal_audio_configs_size();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_audio_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_configs_.Clear();
}
inline ::HU::AudioCofig* ChannelDescriptor_OutputStreamChannel::mutable_audio_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return _internal_mutable_audio_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::AudioCofig>* ChannelDescriptor_OutputStreamChannel::mutable_audio_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_audio_configs();
}
inline const ::HU::AudioCofig& ChannelDescriptor_OutputStreamChannel::audio_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return _internal_audio_configs().Get(index);
}
inline ::HU::AudioCofig* ChannelDescriptor_OutputStreamChannel::add_audio_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::AudioCofig* _add = _internal_mutable_audio_configs()->Add();
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::AudioCofig>& ChannelDescriptor_OutputStreamChannel::audio_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return _internal_audio_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::AudioCofig>&
ChannelDescriptor_OutputStreamChannel::_internal_audio_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::AudioCofig>*
ChannelDescriptor_OutputStreamChannel::_internal_mutable_audio_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.audio_configs_;
}

// repeated .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig video_configs = 4;
inline int ChannelDescriptor_OutputStreamChannel::_internal_video_configs_size() const {
  return _internal_video_configs().size();
}
inline int ChannelDescriptor_OutputStreamChannel::video_configs_size() const {
  return _internal_video_configs_size();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_video_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_configs_.Clear();
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* ChannelDescriptor_OutputStreamChannel::mutable_video_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return _internal_mutable_video_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>* ChannelDescriptor_OutputStreamChannel::mutable_video_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_video_configs();
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig& ChannelDescriptor_OutputStreamChannel::video_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return _internal_video_configs().Get(index);
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* ChannelDescriptor_OutputStreamChannel::add_video_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* _add = _internal_mutable_video_configs()->Add();
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>& ChannelDescriptor_OutputStreamChannel::video_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return _internal_video_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>&
ChannelDescriptor_OutputStreamChannel::_internal_video_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>*
ChannelDescriptor_OutputStreamChannel::_internal_mutable_video_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.video_configs_;
}

// optional bool available_while_in_call = 5;
inline bool ChannelDescriptor_OutputStreamChannel::has_available_while_in_call() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_OutputStreamChannel::clear_available_while_in_call() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_while_in_call_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ChannelDescriptor_OutputStreamChannel::available_while_in_call() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.available_while_in_call)
  return _internal_available_while_in_call();
}
inline void ChannelDescriptor_OutputStreamChannel::set_available_while_in_call(bool value) {
  _internal_set_available_while_in_call(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.available_while_in_call)
}
inline bool ChannelDescriptor_OutputStreamChannel::_internal_available_while_in_call() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_while_in_call_;
}
inline void ChannelDescriptor_OutputStreamChannel::_internal_set_available_while_in_call(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.available_while_in_call_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_InputEventChannel_TouchScreenConfig

// required uint32 width = 1;
inline bool ChannelDescriptor_InputEventChannel_TouchScreenConfig::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t ChannelDescriptor_InputEventChannel_TouchScreenConfig::width() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.width)
  return _internal_width();
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.width)
}
inline ::uint32_t ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_set_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}

// required uint32 height = 2;
inline bool ChannelDescriptor_InputEventChannel_TouchScreenConfig::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ChannelDescriptor_InputEventChannel_TouchScreenConfig::height() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.height)
  return _internal_height();
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.height)
}
inline ::uint32_t ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_set_height(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_InputEventChannel

// repeated uint32 keycodes_supported = 1;
inline int ChannelDescriptor_InputEventChannel::_internal_keycodes_supported_size() const {
  return _internal_keycodes_supported().size();
}
inline int ChannelDescriptor_InputEventChannel::keycodes_supported_size() const {
  return _internal_keycodes_supported_size();
}
inline void ChannelDescriptor_InputEventChannel::clear_keycodes_supported() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keycodes_supported_.Clear();
}
inline ::uint32_t ChannelDescriptor_InputEventChannel::keycodes_supported(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
  return _internal_keycodes_supported().Get(index);
}
inline void ChannelDescriptor_InputEventChannel::set_keycodes_supported(int index, ::uint32_t value) {
  _internal_mutable_keycodes_supported()->Set(index, value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
}
inline void ChannelDescriptor_InputEventChannel::add_keycodes_supported(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_keycodes_supported()->Add(value);
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ChannelDescriptor_InputEventChannel::keycodes_supported() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
  return _internal_keycodes_supported();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* ChannelDescriptor_InputEventChannel::mutable_keycodes_supported()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_keycodes_supported();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ChannelDescriptor_InputEventChannel::_internal_keycodes_supported()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keycodes_supported_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* ChannelDescriptor_InputEventChannel::_internal_mutable_keycodes_supported() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.keycodes_supported_;
}

// optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_screen_config = 2;
inline bool ChannelDescriptor_InputEventChannel::has_touch_screen_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.touch_screen_config_ != nullptr);
  return value;
}
inline void ChannelDescriptor_InputEventChannel::clear_touch_screen_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.touch_screen_config_ != nullptr) _impl_.touch_screen_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::_internal_touch_screen_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* p = _impl_.touch_screen_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig&>(::HU::_ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::touch_screen_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
  return _internal_touch_screen_config();
}
inline void ChannelDescriptor_InputEventChannel::unsafe_arena_set_allocated_touch_screen_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.touch_screen_config_);
  }
  _impl_.touch_screen_config_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::release_touch_screen_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* released = _impl_.touch_screen_config_;
  _impl_.touch_screen_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::unsafe_arena_release_touch_screen_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* temp = _impl_.touch_screen_config_;
  _impl_.touch_screen_config_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::_internal_mutable_touch_screen_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.touch_screen_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig>(GetArena());
    _impl_.touch_screen_config_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(p);
  }
  return _impl_.touch_screen_config_;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::mutable_touch_screen_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* _msg = _internal_mutable_touch_screen_config();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
  return _msg;
}
inline void ChannelDescriptor_InputEventChannel::set_allocated_touch_screen_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(_impl_.touch_screen_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.touch_screen_config_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
}

// optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_pad_config = 3;
inline bool ChannelDescriptor_InputEventChannel::has_touch_pad_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.touch_pad_config_ != nullptr);
  return value;
}
inline void ChannelDescriptor_InputEventChannel::clear_touch_pad_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.touch_pad_config_ != nullptr) _impl_.touch_pad_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::_internal_touch_pad_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* p = _impl_.touch_pad_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig&>(::HU::_ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::touch_pad_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
  return _internal_touch_pad_config();
}
inline void ChannelDescriptor_InputEventChannel::unsafe_arena_set_allocated_touch_pad_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.touch_pad_config_);
  }
  _impl_.touch_pad_config_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::release_touch_pad_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* released = _impl_.touch_pad_config_;
  _impl_.touch_pad_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::unsafe_arena_release_touch_pad_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* temp = _impl_.touch_pad_config_;
  _impl_.touch_pad_config_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::_internal_mutable_touch_pad_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.touch_pad_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig>(GetArena());
    _impl_.touch_pad_config_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(p);
  }
  return _impl_.touch_pad_config_;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::mutable_touch_pad_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* _msg = _internal_mutable_touch_pad_config();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
  return _msg;
}
inline void ChannelDescriptor_InputEventChannel::set_allocated_touch_pad_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(_impl_.touch_pad_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.touch_pad_config_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
}

// -------------------------------------------------------------------

// ChannelDescriptor_InputStreamChannel

// required .HU.STREAM_TYPE type = 1;
inline bool ChannelDescriptor_InputStreamChannel::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChannelDescriptor_InputStreamChannel::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HU::STREAM_TYPE ChannelDescriptor_InputStreamChannel::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputStreamChannel.type)
  return _internal_type();
}
inline void ChannelDescriptor_InputStreamChannel::set_type(::HU::STREAM_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputStreamChannel.type)
}
inline ::HU::STREAM_TYPE ChannelDescriptor_InputStreamChannel::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::STREAM_TYPE>(_impl_.type_);
}
inline void ChannelDescriptor_InputStreamChannel::_internal_set_type(::HU::STREAM_TYPE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::STREAM_TYPE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// required .HU.AudioCofig audio_config = 2;
inline bool ChannelDescriptor_InputStreamChannel::has_audio_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_config_ != nullptr);
  return value;
}
inline void ChannelDescriptor_InputStreamChannel::clear_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.audio_config_ != nullptr) _impl_.audio_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::AudioCofig& ChannelDescriptor_InputStreamChannel::_internal_audio_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::AudioCofig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::AudioCofig&>(::HU::_AudioCofig_default_instance_);
}
inline const ::HU::AudioCofig& ChannelDescriptor_InputStreamChannel::audio_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputStreamChannel.audio_config)
  return _internal_audio_config();
}
inline void ChannelDescriptor_InputStreamChannel::unsafe_arena_set_allocated_audio_config(::HU::AudioCofig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = reinterpret_cast<::HU::AudioCofig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.InputStreamChannel.audio_config)
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::release_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::AudioCofig* released = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::unsafe_arena_release_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.InputStreamChannel.audio_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::AudioCofig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::_internal_mutable_audio_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::AudioCofig>(GetArena());
    _impl_.audio_config_ = reinterpret_cast<::HU::AudioCofig*>(p);
  }
  return _impl_.audio_config_;
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::mutable_audio_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::AudioCofig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.InputStreamChannel.audio_config)
  return _msg;
}
inline void ChannelDescriptor_InputStreamChannel::set_allocated_audio_config(::HU::AudioCofig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::AudioCofig*>(_impl_.audio_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::AudioCofig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.audio_config_ = reinterpret_cast<::HU::AudioCofig*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.InputStreamChannel.audio_config)
}

// optional bool available_while_in_call = 3;
inline bool ChannelDescriptor_InputStreamChannel::has_available_while_in_call() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_InputStreamChannel::clear_available_while_in_call() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_while_in_call_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ChannelDescriptor_InputStreamChannel::available_while_in_call() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputStreamChannel.available_while_in_call)
  return _internal_available_while_in_call();
}
inline void ChannelDescriptor_InputStreamChannel::set_available_while_in_call(bool value) {
  _internal_set_available_while_in_call(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputStreamChannel.available_while_in_call)
}
inline bool ChannelDescriptor_InputStreamChannel::_internal_available_while_in_call() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_while_in_call_;
}
inline void ChannelDescriptor_InputStreamChannel::_internal_set_available_while_in_call(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.available_while_in_call_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_BluetoothService

// required string car_address = 1;
inline bool ChannelDescriptor_BluetoothService::has_car_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_BluetoothService::clear_car_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.car_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelDescriptor_BluetoothService::car_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.BluetoothService.car_address)
  return _internal_car_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelDescriptor_BluetoothService::set_car_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.car_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.BluetoothService.car_address)
}
inline std::string* ChannelDescriptor_BluetoothService::mutable_car_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_car_address();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.BluetoothService.car_address)
  return _s;
}
inline const std::string& ChannelDescriptor_BluetoothService::_internal_car_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.car_address_.Get();
}
inline void ChannelDescriptor_BluetoothService::_internal_set_car_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.car_address_.Set(value, GetArena());
}
inline std::string* ChannelDescriptor_BluetoothService::_internal_mutable_car_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.car_address_.Mutable( GetArena());
}
inline std::string* ChannelDescriptor_BluetoothService::release_car_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.BluetoothService.car_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.car_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.car_address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChannelDescriptor_BluetoothService::set_allocated_car_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.car_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.car_address_.IsDefault()) {
          _impl_.car_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.BluetoothService.car_address)
}

// repeated .HU.BluetoothPairingMethod supported_pairing_methods = 2;
inline int ChannelDescriptor_BluetoothService::_internal_supported_pairing_methods_size() const {
  return _internal_supported_pairing_methods().size();
}
inline int ChannelDescriptor_BluetoothService::supported_pairing_methods_size() const {
  return _internal_supported_pairing_methods_size();
}
inline void ChannelDescriptor_BluetoothService::clear_supported_pairing_methods() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supported_pairing_methods_.Clear();
}
inline ::HU::BluetoothPairingMethod ChannelDescriptor_BluetoothService::supported_pairing_methods(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  return static_cast<::HU::BluetoothPairingMethod>(_internal_supported_pairing_methods().Get(index));
}
inline void ChannelDescriptor_BluetoothService::set_supported_pairing_methods(int index, ::HU::BluetoothPairingMethod value) {
  assert(::HU::BluetoothPairingMethod_IsValid(value));
  _internal_mutable_supported_pairing_methods()->Set(index, value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
}
inline void ChannelDescriptor_BluetoothService::add_supported_pairing_methods(::HU::BluetoothPairingMethod value) {
  assert(::HU::BluetoothPairingMethod_IsValid(value));
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_supported_pairing_methods()->Add(value);
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
}
inline const ::google::protobuf::RepeatedField<int>& ChannelDescriptor_BluetoothService::supported_pairing_methods() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  return _internal_supported_pairing_methods();
}
inline ::google::protobuf::RepeatedField<int>* ChannelDescriptor_BluetoothService::mutable_supported_pairing_methods()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_supported_pairing_methods();
}
inline const ::google::protobuf::RepeatedField<int>& ChannelDescriptor_BluetoothService::_internal_supported_pairing_methods() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supported_pairing_methods_;
}
inline ::google::protobuf::RepeatedField<int>* ChannelDescriptor_BluetoothService::_internal_mutable_supported_pairing_methods() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.supported_pairing_methods_;
}

// -------------------------------------------------------------------

// ChannelDescriptor_NavigationStatusService_ImageOptions

// required int32 width = 1;
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ChannelDescriptor_NavigationStatusService_ImageOptions::width() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.width)
  return _internal_width();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.width)
}
inline ::int32_t ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}

// required int32 height = 2;
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ChannelDescriptor_NavigationStatusService_ImageOptions::height() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.height)
  return _internal_height();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.height)
}
inline ::int32_t ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}

// required int32 colour_depth_bits = 3;
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::has_colour_depth_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::clear_colour_depth_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.colour_depth_bits_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ChannelDescriptor_NavigationStatusService_ImageOptions::colour_depth_bits() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.colour_depth_bits)
  return _internal_colour_depth_bits();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::set_colour_depth_bits(::int32_t value) {
  _internal_set_colour_depth_bits(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.colour_depth_bits)
}
inline ::int32_t ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_colour_depth_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.colour_depth_bits_;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_set_colour_depth_bits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.colour_depth_bits_ = value;
}

// -------------------------------------------------------------------

// ChannelDescriptor_NavigationStatusService

// required uint32 minimum_interval_ms = 1;
inline bool ChannelDescriptor_NavigationStatusService::has_minimum_interval_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_NavigationStatusService::clear_minimum_interval_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimum_interval_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ChannelDescriptor_NavigationStatusService::minimum_interval_ms() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.minimum_interval_ms)
  return _internal_minimum_interval_ms();
}
inline void ChannelDescriptor_NavigationStatusService::set_minimum_interval_ms(::uint32_t value) {
  _internal_set_minimum_interval_ms(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.minimum_interval_ms)
}
inline ::uint32_t ChannelDescriptor_NavigationStatusService::_internal_minimum_interval_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minimum_interval_ms_;
}
inline void ChannelDescriptor_NavigationStatusService::_internal_set_minimum_interval_ms(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.minimum_interval_ms_ = value;
}

// required .HU.ChannelDescriptor.NavigationStatusService.CLUSTER_TYPE type = 2;
inline bool ChannelDescriptor_NavigationStatusService::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChannelDescriptor_NavigationStatusService::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.type)
  return _internal_type();
}
inline void ChannelDescriptor_NavigationStatusService::set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.type)
}
inline ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>(_impl_.type_);
}
inline void ChannelDescriptor_NavigationStatusService::_internal_set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .HU.ChannelDescriptor.NavigationStatusService.ImageOptions image_options = 3;
inline bool ChannelDescriptor_NavigationStatusService::has_image_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_options_ != nullptr);
  return value;
}
inline void ChannelDescriptor_NavigationStatusService::clear_image_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.image_options_ != nullptr) _impl_.image_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& ChannelDescriptor_NavigationStatusService::_internal_image_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* p = _impl_.image_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions&>(::HU::_ChannelDescriptor_NavigationStatusService_ImageOptions_default_instance_);
}
inline const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& ChannelDescriptor_NavigationStatusService::image_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.image_options)
  return _internal_image_options();
}
inline void ChannelDescriptor_NavigationStatusService::unsafe_arena_set_allocated_image_options(::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.image_options_);
  }
  _impl_.image_options_ = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.NavigationStatusService.image_options)
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::release_image_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* released = _impl_.image_options_;
  _impl_.image_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::unsafe_arena_release_image_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.NavigationStatusService.image_options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* temp = _impl_.image_options_;
  _impl_.image_options_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::_internal_mutable_image_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.image_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions>(GetArena());
    _impl_.image_options_ = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions*>(p);
  }
  return _impl_.image_options_;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::mutable_image_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* _msg = _internal_mutable_image_options();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.NavigationStatusService.image_options)
  return _msg;
}
inline void ChannelDescriptor_NavigationStatusService::set_allocated_image_options(::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions*>(_impl_.image_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.image_options_ = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.NavigationStatusService.image_options)
}

// -------------------------------------------------------------------

// ChannelDescriptor_PhoneStatusService

// -------------------------------------------------------------------

// ChannelDescriptor_VendorExtensionService

// optional string name = 1;
inline bool ChannelDescriptor_VendorExtensionService::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_VendorExtensionService::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.VendorExtensionService.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelDescriptor_VendorExtensionService::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.name)
}
inline std::string* ChannelDescriptor_VendorExtensionService::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.VendorExtensionService.name)
  return _s;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ChannelDescriptor_VendorExtensionService::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ChannelDescriptor_VendorExtensionService::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ChannelDescriptor_VendorExtensionService::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.VendorExtensionService.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChannelDescriptor_VendorExtensionService::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.VendorExtensionService.name)
}

// repeated string package_white_list = 2;
inline int ChannelDescriptor_VendorExtensionService::_internal_package_white_list_size() const {
  return _internal_package_white_list().size();
}
inline int ChannelDescriptor_VendorExtensionService::package_white_list_size() const {
  return _internal_package_white_list_size();
}
inline void ChannelDescriptor_VendorExtensionService::clear_package_white_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.package_white_list_.Clear();
}
inline std::string* ChannelDescriptor_VendorExtensionService::add_package_white_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_package_white_list()->Add();
  // @@protoc_insertion_point(field_add_mutable:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return _s;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::package_white_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return _internal_package_white_list().Get(index);
}
inline std::string* ChannelDescriptor_VendorExtensionService::mutable_package_white_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return _internal_mutable_package_white_list()->Mutable(index);
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, const std::string& value) {
  _internal_mutable_package_white_list()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, std::string&& value) {
  _internal_mutable_package_white_list()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_package_white_list()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_package_white_list()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, absl::string_view value) {
  _internal_mutable_package_white_list()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_package_white_list()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_package_white_list()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_package_white_list()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_package_white_list()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_package_white_list()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ChannelDescriptor_VendorExtensionService::package_white_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return _internal_package_white_list();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ChannelDescriptor_VendorExtensionService::mutable_package_white_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_package_white_list();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ChannelDescriptor_VendorExtensionService::_internal_package_white_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.package_white_list_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ChannelDescriptor_VendorExtensionService::_internal_mutable_package_white_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.package_white_list_;
}

// optional bytes data = 3;
inline bool ChannelDescriptor_VendorExtensionService::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelDescriptor_VendorExtensionService::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.VendorExtensionService.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelDescriptor_VendorExtensionService::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.data)
}
inline std::string* ChannelDescriptor_VendorExtensionService::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.VendorExtensionService.data)
  return _s;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void ChannelDescriptor_VendorExtensionService::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* ChannelDescriptor_VendorExtensionService::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* ChannelDescriptor_VendorExtensionService::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.VendorExtensionService.data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChannelDescriptor_VendorExtensionService::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.VendorExtensionService.data)
}

// -------------------------------------------------------------------

// ChannelDescriptor_GenericNotificationService

// optional string name = 1;
inline bool ChannelDescriptor_GenericNotificationService::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelDescriptor_GenericNotificationService::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelDescriptor_GenericNotificationService::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.GenericNotificationService.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelDescriptor_GenericNotificationService::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.GenericNotificationService.name)
}
inline std::string* ChannelDescriptor_GenericNotificationService::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.GenericNotificationService.name)
  return _s;
}
inline const std::string& ChannelDescriptor_GenericNotificationService::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ChannelDescriptor_GenericNotificationService::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ChannelDescriptor_GenericNotificationService::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ChannelDescriptor_GenericNotificationService::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.GenericNotificationService.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChannelDescriptor_GenericNotificationService::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.GenericNotificationService.name)
}

// -------------------------------------------------------------------

// ChannelDescriptor

// required uint32 channel_id = 1;
inline bool ChannelDescriptor::has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ChannelDescriptor::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t ChannelDescriptor::channel_id() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.channel_id)
  return _internal_channel_id();
}
inline void ChannelDescriptor::set_channel_id(::uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.channel_id)
}
inline ::uint32_t ChannelDescriptor::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_;
}
inline void ChannelDescriptor::_internal_set_channel_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.channel_id_ = value;
}

// optional .HU.ChannelDescriptor.SensorChannel sensor_channel = 2;
inline bool ChannelDescriptor::has_sensor_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensor_channel_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_sensor_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sensor_channel_ != nullptr) _impl_.sensor_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::ChannelDescriptor_SensorChannel& ChannelDescriptor::_internal_sensor_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_SensorChannel* p = _impl_.sensor_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_SensorChannel&>(::HU::_ChannelDescriptor_SensorChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_SensorChannel& ChannelDescriptor::sensor_channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.sensor_channel)
  return _internal_sensor_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_sensor_channel(::HU::ChannelDescriptor_SensorChannel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_channel_);
  }
  _impl_.sensor_channel_ = reinterpret_cast<::HU::ChannelDescriptor_SensorChannel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.sensor_channel)
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::release_sensor_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_SensorChannel* released = _impl_.sensor_channel_;
  _impl_.sensor_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::unsafe_arena_release_sensor_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.sensor_channel)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_SensorChannel* temp = _impl_.sensor_channel_;
  _impl_.sensor_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::_internal_mutable_sensor_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sensor_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_SensorChannel>(GetArena());
    _impl_.sensor_channel_ = reinterpret_cast<::HU::ChannelDescriptor_SensorChannel*>(p);
  }
  return _impl_.sensor_channel_;
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::mutable_sensor_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_SensorChannel* _msg = _internal_mutable_sensor_channel();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.sensor_channel)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_sensor_channel(::HU::ChannelDescriptor_SensorChannel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_SensorChannel*>(_impl_.sensor_channel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_SensorChannel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sensor_channel_ = reinterpret_cast<::HU::ChannelDescriptor_SensorChannel*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.sensor_channel)
}

// optional .HU.ChannelDescriptor.OutputStreamChannel output_stream_channel = 3;
inline bool ChannelDescriptor::has_output_stream_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_stream_channel_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_output_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.output_stream_channel_ != nullptr) _impl_.output_stream_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel& ChannelDescriptor::_internal_output_stream_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_OutputStreamChannel* p = _impl_.output_stream_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_OutputStreamChannel&>(::HU::_ChannelDescriptor_OutputStreamChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel& ChannelDescriptor::output_stream_channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.output_stream_channel)
  return _internal_output_stream_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_output_stream_channel(::HU::ChannelDescriptor_OutputStreamChannel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_stream_channel_);
  }
  _impl_.output_stream_channel_ = reinterpret_cast<::HU::ChannelDescriptor_OutputStreamChannel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.output_stream_channel)
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::release_output_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HU::ChannelDescriptor_OutputStreamChannel* released = _impl_.output_stream_channel_;
  _impl_.output_stream_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::unsafe_arena_release_output_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.output_stream_channel)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HU::ChannelDescriptor_OutputStreamChannel* temp = _impl_.output_stream_channel_;
  _impl_.output_stream_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::_internal_mutable_output_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.output_stream_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_OutputStreamChannel>(GetArena());
    _impl_.output_stream_channel_ = reinterpret_cast<::HU::ChannelDescriptor_OutputStreamChannel*>(p);
  }
  return _impl_.output_stream_channel_;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::mutable_output_stream_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_OutputStreamChannel* _msg = _internal_mutable_output_stream_channel();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.output_stream_channel)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_output_stream_channel(::HU::ChannelDescriptor_OutputStreamChannel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_OutputStreamChannel*>(_impl_.output_stream_channel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_OutputStreamChannel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.output_stream_channel_ = reinterpret_cast<::HU::ChannelDescriptor_OutputStreamChannel*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.output_stream_channel)
}

// optional .HU.ChannelDescriptor.InputEventChannel input_event_channel = 4;
inline bool ChannelDescriptor::has_input_event_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_event_channel_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_input_event_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.input_event_channel_ != nullptr) _impl_.input_event_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HU::ChannelDescriptor_InputEventChannel& ChannelDescriptor::_internal_input_event_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_InputEventChannel* p = _impl_.input_event_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_InputEventChannel&>(::HU::_ChannelDescriptor_InputEventChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputEventChannel& ChannelDescriptor::input_event_channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.input_event_channel)
  return _internal_input_event_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_input_event_channel(::HU::ChannelDescriptor_InputEventChannel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_event_channel_);
  }
  _impl_.input_event_channel_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.input_event_channel)
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::release_input_event_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HU::ChannelDescriptor_InputEventChannel* released = _impl_.input_event_channel_;
  _impl_.input_event_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::unsafe_arena_release_input_event_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.input_event_channel)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HU::ChannelDescriptor_InputEventChannel* temp = _impl_.input_event_channel_;
  _impl_.input_event_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::_internal_mutable_input_event_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.input_event_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel>(GetArena());
    _impl_.input_event_channel_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel*>(p);
  }
  return _impl_.input_event_channel_;
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::mutable_input_event_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_InputEventChannel* _msg = _internal_mutable_input_event_channel();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.input_event_channel)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_input_event_channel(::HU::ChannelDescriptor_InputEventChannel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel*>(_impl_.input_event_channel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.input_event_channel_ = reinterpret_cast<::HU::ChannelDescriptor_InputEventChannel*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.input_event_channel)
}

// optional .HU.ChannelDescriptor.InputStreamChannel input_stream_channel = 5;
inline bool ChannelDescriptor::has_input_stream_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_stream_channel_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_input_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.input_stream_channel_ != nullptr) _impl_.input_stream_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HU::ChannelDescriptor_InputStreamChannel& ChannelDescriptor::_internal_input_stream_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_InputStreamChannel* p = _impl_.input_stream_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_InputStreamChannel&>(::HU::_ChannelDescriptor_InputStreamChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputStreamChannel& ChannelDescriptor::input_stream_channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.input_stream_channel)
  return _internal_input_stream_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_input_stream_channel(::HU::ChannelDescriptor_InputStreamChannel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_stream_channel_);
  }
  _impl_.input_stream_channel_ = reinterpret_cast<::HU::ChannelDescriptor_InputStreamChannel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.input_stream_channel)
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::release_input_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HU::ChannelDescriptor_InputStreamChannel* released = _impl_.input_stream_channel_;
  _impl_.input_stream_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::unsafe_arena_release_input_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.input_stream_channel)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HU::ChannelDescriptor_InputStreamChannel* temp = _impl_.input_stream_channel_;
  _impl_.input_stream_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::_internal_mutable_input_stream_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.input_stream_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputStreamChannel>(GetArena());
    _impl_.input_stream_channel_ = reinterpret_cast<::HU::ChannelDescriptor_InputStreamChannel*>(p);
  }
  return _impl_.input_stream_channel_;
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::mutable_input_stream_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_InputStreamChannel* _msg = _internal_mutable_input_stream_channel();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.input_stream_channel)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_input_stream_channel(::HU::ChannelDescriptor_InputStreamChannel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_InputStreamChannel*>(_impl_.input_stream_channel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_InputStreamChannel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.input_stream_channel_ = reinterpret_cast<::HU::ChannelDescriptor_InputStreamChannel*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.input_stream_channel)
}

// optional .HU.ChannelDescriptor.BluetoothService bluetooth_service = 6;
inline bool ChannelDescriptor::has_bluetooth_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bluetooth_service_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_bluetooth_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bluetooth_service_ != nullptr) _impl_.bluetooth_service_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::HU::ChannelDescriptor_BluetoothService& ChannelDescriptor::_internal_bluetooth_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_BluetoothService* p = _impl_.bluetooth_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_BluetoothService&>(::HU::_ChannelDescriptor_BluetoothService_default_instance_);
}
inline const ::HU::ChannelDescriptor_BluetoothService& ChannelDescriptor::bluetooth_service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.bluetooth_service)
  return _internal_bluetooth_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_bluetooth_service(::HU::ChannelDescriptor_BluetoothService* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bluetooth_service_);
  }
  _impl_.bluetooth_service_ = reinterpret_cast<::HU::ChannelDescriptor_BluetoothService*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.bluetooth_service)
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::release_bluetooth_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HU::ChannelDescriptor_BluetoothService* released = _impl_.bluetooth_service_;
  _impl_.bluetooth_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::unsafe_arena_release_bluetooth_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.bluetooth_service)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HU::ChannelDescriptor_BluetoothService* temp = _impl_.bluetooth_service_;
  _impl_.bluetooth_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::_internal_mutable_bluetooth_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.bluetooth_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_BluetoothService>(GetArena());
    _impl_.bluetooth_service_ = reinterpret_cast<::HU::ChannelDescriptor_BluetoothService*>(p);
  }
  return _impl_.bluetooth_service_;
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::mutable_bluetooth_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_BluetoothService* _msg = _internal_mutable_bluetooth_service();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.bluetooth_service)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_bluetooth_service(::HU::ChannelDescriptor_BluetoothService* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_BluetoothService*>(_impl_.bluetooth_service_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_BluetoothService*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.bluetooth_service_ = reinterpret_cast<::HU::ChannelDescriptor_BluetoothService*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.bluetooth_service)
}

// optional .HU.ChannelDescriptor.NavigationStatusService navigation_status_service = 8;
inline bool ChannelDescriptor::has_navigation_status_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.navigation_status_service_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_navigation_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.navigation_status_service_ != nullptr) _impl_.navigation_status_service_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::HU::ChannelDescriptor_NavigationStatusService& ChannelDescriptor::_internal_navigation_status_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_NavigationStatusService* p = _impl_.navigation_status_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_NavigationStatusService&>(::HU::_ChannelDescriptor_NavigationStatusService_default_instance_);
}
inline const ::HU::ChannelDescriptor_NavigationStatusService& ChannelDescriptor::navigation_status_service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.navigation_status_service)
  return _internal_navigation_status_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_navigation_status_service(::HU::ChannelDescriptor_NavigationStatusService* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.navigation_status_service_);
  }
  _impl_.navigation_status_service_ = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.navigation_status_service)
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::release_navigation_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::HU::ChannelDescriptor_NavigationStatusService* released = _impl_.navigation_status_service_;
  _impl_.navigation_status_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::unsafe_arena_release_navigation_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.navigation_status_service)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::HU::ChannelDescriptor_NavigationStatusService* temp = _impl_.navigation_status_service_;
  _impl_.navigation_status_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::_internal_mutable_navigation_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.navigation_status_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_NavigationStatusService>(GetArena());
    _impl_.navigation_status_service_ = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService*>(p);
  }
  return _impl_.navigation_status_service_;
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::mutable_navigation_status_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_NavigationStatusService* _msg = _internal_mutable_navigation_status_service();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.navigation_status_service)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_navigation_status_service(::HU::ChannelDescriptor_NavigationStatusService* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService*>(_impl_.navigation_status_service_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.navigation_status_service_ = reinterpret_cast<::HU::ChannelDescriptor_NavigationStatusService*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.navigation_status_service)
}

// optional .HU.ChannelDescriptor.PhoneStatusService phone_status_service = 10;
inline bool ChannelDescriptor::has_phone_status_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.phone_status_service_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_phone_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.phone_status_service_ != nullptr) _impl_.phone_status_service_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::HU::ChannelDescriptor_PhoneStatusService& ChannelDescriptor::_internal_phone_status_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_PhoneStatusService* p = _impl_.phone_status_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_PhoneStatusService&>(::HU::_ChannelDescriptor_PhoneStatusService_default_instance_);
}
inline const ::HU::ChannelDescriptor_PhoneStatusService& ChannelDescriptor::phone_status_service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.phone_status_service)
  return _internal_phone_status_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_phone_status_service(::HU::ChannelDescriptor_PhoneStatusService* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.phone_status_service_);
  }
  _impl_.phone_status_service_ = reinterpret_cast<::HU::ChannelDescriptor_PhoneStatusService*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.phone_status_service)
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::release_phone_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::HU::ChannelDescriptor_PhoneStatusService* released = _impl_.phone_status_service_;
  _impl_.phone_status_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::unsafe_arena_release_phone_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.phone_status_service)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::HU::ChannelDescriptor_PhoneStatusService* temp = _impl_.phone_status_service_;
  _impl_.phone_status_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::_internal_mutable_phone_status_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.phone_status_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_PhoneStatusService>(GetArena());
    _impl_.phone_status_service_ = reinterpret_cast<::HU::ChannelDescriptor_PhoneStatusService*>(p);
  }
  return _impl_.phone_status_service_;
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::mutable_phone_status_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_PhoneStatusService* _msg = _internal_mutable_phone_status_service();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.phone_status_service)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_phone_status_service(::HU::ChannelDescriptor_PhoneStatusService* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_PhoneStatusService*>(_impl_.phone_status_service_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_PhoneStatusService*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.phone_status_service_ = reinterpret_cast<::HU::ChannelDescriptor_PhoneStatusService*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.phone_status_service)
}

// optional .HU.ChannelDescriptor.VendorExtensionService vendor_extension_service = 12;
inline bool ChannelDescriptor::has_vendor_extension_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vendor_extension_service_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_vendor_extension_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.vendor_extension_service_ != nullptr) _impl_.vendor_extension_service_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::HU::ChannelDescriptor_VendorExtensionService& ChannelDescriptor::_internal_vendor_extension_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_VendorExtensionService* p = _impl_.vendor_extension_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_VendorExtensionService&>(::HU::_ChannelDescriptor_VendorExtensionService_default_instance_);
}
inline const ::HU::ChannelDescriptor_VendorExtensionService& ChannelDescriptor::vendor_extension_service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.vendor_extension_service)
  return _internal_vendor_extension_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_vendor_extension_service(::HU::ChannelDescriptor_VendorExtensionService* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vendor_extension_service_);
  }
  _impl_.vendor_extension_service_ = reinterpret_cast<::HU::ChannelDescriptor_VendorExtensionService*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.vendor_extension_service)
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::release_vendor_extension_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::HU::ChannelDescriptor_VendorExtensionService* released = _impl_.vendor_extension_service_;
  _impl_.vendor_extension_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::unsafe_arena_release_vendor_extension_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.vendor_extension_service)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::HU::ChannelDescriptor_VendorExtensionService* temp = _impl_.vendor_extension_service_;
  _impl_.vendor_extension_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::_internal_mutable_vendor_extension_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.vendor_extension_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_VendorExtensionService>(GetArena());
    _impl_.vendor_extension_service_ = reinterpret_cast<::HU::ChannelDescriptor_VendorExtensionService*>(p);
  }
  return _impl_.vendor_extension_service_;
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::mutable_vendor_extension_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_VendorExtensionService* _msg = _internal_mutable_vendor_extension_service();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.vendor_extension_service)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_vendor_extension_service(::HU::ChannelDescriptor_VendorExtensionService* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_VendorExtensionService*>(_impl_.vendor_extension_service_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_VendorExtensionService*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.vendor_extension_service_ = reinterpret_cast<::HU::ChannelDescriptor_VendorExtensionService*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.vendor_extension_service)
}

// optional .HU.ChannelDescriptor.GenericNotificationService generic_notification_service = 13;
inline bool ChannelDescriptor::has_generic_notification_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.generic_notification_service_ != nullptr);
  return value;
}
inline void ChannelDescriptor::clear_generic_notification_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.generic_notification_service_ != nullptr) _impl_.generic_notification_service_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::HU::ChannelDescriptor_GenericNotificationService& ChannelDescriptor::_internal_generic_notification_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::HU::ChannelDescriptor_GenericNotificationService* p = _impl_.generic_notification_service_;
  return p != nullptr ? *p : reinterpret_cast<const ::HU::ChannelDescriptor_GenericNotificationService&>(::HU::_ChannelDescriptor_GenericNotificationService_default_instance_);
}
inline const ::HU::ChannelDescriptor_GenericNotificationService& ChannelDescriptor::generic_notification_service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.generic_notification_service)
  return _internal_generic_notification_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_generic_notification_service(::HU::ChannelDescriptor_GenericNotificationService* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.generic_notification_service_);
  }
  _impl_.generic_notification_service_ = reinterpret_cast<::HU::ChannelDescriptor_GenericNotificationService*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.generic_notification_service)
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::release_generic_notification_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::HU::ChannelDescriptor_GenericNotificationService* released = _impl_.generic_notification_service_;
  _impl_.generic_notification_service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::unsafe_arena_release_generic_notification_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.generic_notification_service)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::HU::ChannelDescriptor_GenericNotificationService* temp = _impl_.generic_notification_service_;
  _impl_.generic_notification_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::_internal_mutable_generic_notification_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.generic_notification_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_GenericNotificationService>(GetArena());
    _impl_.generic_notification_service_ = reinterpret_cast<::HU::ChannelDescriptor_GenericNotificationService*>(p);
  }
  return _impl_.generic_notification_service_;
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::mutable_generic_notification_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::HU::ChannelDescriptor_GenericNotificationService* _msg = _internal_mutable_generic_notification_service();
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.generic_notification_service)
  return _msg;
}
inline void ChannelDescriptor::set_allocated_generic_notification_service(::HU::ChannelDescriptor_GenericNotificationService* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::HU::ChannelDescriptor_GenericNotificationService*>(_impl_.generic_notification_service_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::HU::ChannelDescriptor_GenericNotificationService*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.generic_notification_service_ = reinterpret_cast<::HU::ChannelDescriptor_GenericNotificationService*>(value);
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.generic_notification_service)
}

// -------------------------------------------------------------------

// ServiceDiscoveryRequest

// optional string phone_name = 4;
inline bool ServiceDiscoveryRequest::has_phone_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServiceDiscoveryRequest::clear_phone_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phone_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceDiscoveryRequest::phone_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryRequest.phone_name)
  return _internal_phone_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryRequest::set_phone_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryRequest.phone_name)
}
inline std::string* ServiceDiscoveryRequest::mutable_phone_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_name();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryRequest.phone_name)
  return _s;
}
inline const std::string& ServiceDiscoveryRequest::_internal_phone_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_name_.Get();
}
inline void ServiceDiscoveryRequest::_internal_set_phone_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_name_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryRequest::_internal_mutable_phone_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phone_name_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryRequest::release_phone_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryRequest.phone_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phone_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryRequest::set_allocated_phone_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phone_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_name_.IsDefault()) {
          _impl_.phone_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryRequest.phone_name)
}

// -------------------------------------------------------------------

// ServiceDiscoveryResponse

// repeated .HU.ChannelDescriptor channels = 1;
inline int ServiceDiscoveryResponse::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int ServiceDiscoveryResponse::channels_size() const {
  return _internal_channels_size();
}
inline void ServiceDiscoveryResponse::clear_channels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channels_.Clear();
}
inline ::HU::ChannelDescriptor* ServiceDiscoveryResponse::mutable_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor>* ServiceDiscoveryResponse::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.ServiceDiscoveryResponse.channels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_channels();
}
inline const ::HU::ChannelDescriptor& ServiceDiscoveryResponse::channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.channels)
  return _internal_channels().Get(index);
}
inline ::HU::ChannelDescriptor* ServiceDiscoveryResponse::add_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::ChannelDescriptor* _add = _internal_mutable_channels()->Add();
  // @@protoc_insertion_point(field_add:HU.ServiceDiscoveryResponse.channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor>& ServiceDiscoveryResponse::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.ServiceDiscoveryResponse.channels)
  return _internal_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor>&
ServiceDiscoveryResponse::_internal_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::ChannelDescriptor>*
ServiceDiscoveryResponse::_internal_mutable_channels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.channels_;
}

// required string head_unit_name = 2;
inline bool ServiceDiscoveryResponse::has_head_unit_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_head_unit_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.head_unit_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceDiscoveryResponse::head_unit_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.head_unit_name)
  return _internal_head_unit_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_head_unit_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.head_unit_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.head_unit_name)
}
inline std::string* ServiceDiscoveryResponse::mutable_head_unit_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_head_unit_name();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.head_unit_name)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_head_unit_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.head_unit_name_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_head_unit_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.head_unit_name_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_head_unit_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.head_unit_name_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_head_unit_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.head_unit_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.head_unit_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.head_unit_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_head_unit_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.head_unit_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.head_unit_name_.IsDefault()) {
          _impl_.head_unit_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.head_unit_name)
}

// required string car_model = 3;
inline bool ServiceDiscoveryResponse::has_car_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_car_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.car_model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServiceDiscoveryResponse::car_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.car_model)
  return _internal_car_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_car_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.car_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.car_model)
}
inline std::string* ServiceDiscoveryResponse::mutable_car_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_car_model();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.car_model)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_car_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.car_model_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_car_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.car_model_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_car_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.car_model_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_car_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.car_model)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.car_model_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.car_model_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_car_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.car_model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.car_model_.IsDefault()) {
          _impl_.car_model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.car_model)
}

// required string car_year = 4;
inline bool ServiceDiscoveryResponse::has_car_year() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_car_year() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.car_year_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ServiceDiscoveryResponse::car_year() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.car_year)
  return _internal_car_year();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_car_year(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.car_year_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.car_year)
}
inline std::string* ServiceDiscoveryResponse::mutable_car_year() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_car_year();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.car_year)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_car_year() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.car_year_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_car_year(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.car_year_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_car_year() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.car_year_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_car_year() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.car_year)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.car_year_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.car_year_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_car_year(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.car_year_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.car_year_.IsDefault()) {
          _impl_.car_year_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.car_year)
}

// required string car_serial = 5;
inline bool ServiceDiscoveryResponse::has_car_serial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_car_serial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.car_serial_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ServiceDiscoveryResponse::car_serial() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.car_serial)
  return _internal_car_serial();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_car_serial(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.car_serial_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.car_serial)
}
inline std::string* ServiceDiscoveryResponse::mutable_car_serial() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_car_serial();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.car_serial)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_car_serial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.car_serial_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_car_serial(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.car_serial_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_car_serial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.car_serial_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_car_serial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.car_serial)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.car_serial_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.car_serial_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_car_serial(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.car_serial_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.car_serial_.IsDefault()) {
          _impl_.car_serial_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.car_serial)
}

// required bool driver_pos = 6;
inline bool ServiceDiscoveryResponse::has_driver_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_driver_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_pos_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ServiceDiscoveryResponse::driver_pos() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.driver_pos)
  return _internal_driver_pos();
}
inline void ServiceDiscoveryResponse::set_driver_pos(bool value) {
  _internal_set_driver_pos(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.driver_pos)
}
inline bool ServiceDiscoveryResponse::_internal_driver_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driver_pos_;
}
inline void ServiceDiscoveryResponse::_internal_set_driver_pos(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.driver_pos_ = value;
}

// required string headunit_make = 7;
inline bool ServiceDiscoveryResponse::has_headunit_make() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_headunit_make() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headunit_make_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ServiceDiscoveryResponse::headunit_make() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.headunit_make)
  return _internal_headunit_make();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_headunit_make(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.headunit_make_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.headunit_make)
}
inline std::string* ServiceDiscoveryResponse::mutable_headunit_make() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_headunit_make();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.headunit_make)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_headunit_make() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headunit_make_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_headunit_make(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.headunit_make_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_headunit_make() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.headunit_make_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_headunit_make() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.headunit_make)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.headunit_make_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.headunit_make_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_headunit_make(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.headunit_make_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.headunit_make_.IsDefault()) {
          _impl_.headunit_make_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.headunit_make)
}

// required string headunit_model = 8;
inline bool ServiceDiscoveryResponse::has_headunit_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_headunit_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headunit_model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ServiceDiscoveryResponse::headunit_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.headunit_model)
  return _internal_headunit_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_headunit_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.headunit_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.headunit_model)
}
inline std::string* ServiceDiscoveryResponse::mutable_headunit_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_headunit_model();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.headunit_model)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_headunit_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headunit_model_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_headunit_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.headunit_model_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_headunit_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.headunit_model_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_headunit_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.headunit_model)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.headunit_model_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.headunit_model_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_headunit_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.headunit_model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.headunit_model_.IsDefault()) {
          _impl_.headunit_model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.headunit_model)
}

// required string sw_build = 9;
inline bool ServiceDiscoveryResponse::has_sw_build() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_sw_build() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sw_build_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ServiceDiscoveryResponse::sw_build() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.sw_build)
  return _internal_sw_build();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_sw_build(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sw_build_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.sw_build)
}
inline std::string* ServiceDiscoveryResponse::mutable_sw_build() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sw_build();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.sw_build)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_sw_build() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sw_build_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_sw_build(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sw_build_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_sw_build() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.sw_build_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_sw_build() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.sw_build)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.sw_build_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sw_build_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_sw_build(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.sw_build_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sw_build_.IsDefault()) {
          _impl_.sw_build_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.sw_build)
}

// required string sw_version = 10;
inline bool ServiceDiscoveryResponse::has_sw_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_sw_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sw_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ServiceDiscoveryResponse::sw_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.sw_version)
  return _internal_sw_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceDiscoveryResponse::set_sw_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sw_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.sw_version)
}
inline std::string* ServiceDiscoveryResponse::mutable_sw_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sw_version();
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.sw_version)
  return _s;
}
inline const std::string& ServiceDiscoveryResponse::_internal_sw_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sw_version_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_sw_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sw_version_.Set(value, GetArena());
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_sw_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.sw_version_.Mutable( GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_sw_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.sw_version)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.sw_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sw_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceDiscoveryResponse::set_allocated_sw_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.sw_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sw_version_.IsDefault()) {
          _impl_.sw_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.sw_version)
}

// required bool can_play_native_media_during_vr = 11;
inline bool ServiceDiscoveryResponse::has_can_play_native_media_during_vr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_can_play_native_media_during_vr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.can_play_native_media_during_vr_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ServiceDiscoveryResponse::can_play_native_media_during_vr() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.can_play_native_media_during_vr)
  return _internal_can_play_native_media_during_vr();
}
inline void ServiceDiscoveryResponse::set_can_play_native_media_during_vr(bool value) {
  _internal_set_can_play_native_media_during_vr(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.can_play_native_media_during_vr)
}
inline bool ServiceDiscoveryResponse::_internal_can_play_native_media_during_vr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.can_play_native_media_during_vr_;
}
inline void ServiceDiscoveryResponse::_internal_set_can_play_native_media_during_vr(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.can_play_native_media_during_vr_ = value;
}

// required bool hide_clock = 12;
inline bool ServiceDiscoveryResponse::has_hide_clock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ServiceDiscoveryResponse::clear_hide_clock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hide_clock_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ServiceDiscoveryResponse::hide_clock() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.hide_clock)
  return _internal_hide_clock();
}
inline void ServiceDiscoveryResponse::set_hide_clock(bool value) {
  _internal_set_hide_clock(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.hide_clock)
}
inline bool ServiceDiscoveryResponse::_internal_hide_clock() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hide_clock_;
}
inline void ServiceDiscoveryResponse::_internal_set_hide_clock(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.hide_clock_ = value;
}

// -------------------------------------------------------------------

// ChannelOpenRequest

// optional int32 priority = 1;
inline bool ChannelOpenRequest::has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelOpenRequest::clear_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ChannelOpenRequest::priority() const {
  // @@protoc_insertion_point(field_get:HU.ChannelOpenRequest.priority)
  return _internal_priority();
}
inline void ChannelOpenRequest::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:HU.ChannelOpenRequest.priority)
}
inline ::int32_t ChannelOpenRequest::_internal_priority() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priority_;
}
inline void ChannelOpenRequest::_internal_set_priority(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.priority_ = value;
}

// optional int32 id = 2;
inline bool ChannelOpenRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelOpenRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ChannelOpenRequest::id() const {
  // @@protoc_insertion_point(field_get:HU.ChannelOpenRequest.id)
  return _internal_id();
}
inline void ChannelOpenRequest::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:HU.ChannelOpenRequest.id)
}
inline ::int32_t ChannelOpenRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void ChannelOpenRequest::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// ChannelOpenResponse

// required .HU.STATUS status = 1;
inline bool ChannelOpenResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelOpenResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS ChannelOpenResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.ChannelOpenResponse.status)
  return _internal_status();
}
inline void ChannelOpenResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.ChannelOpenResponse.status)
}
inline ::HU::STATUS ChannelOpenResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::STATUS>(_impl_.status_);
}
inline void ChannelOpenResponse::_internal_set_status(::HU::STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// PingRequest

// required int64 timestamp = 1;
inline bool PingRequest::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PingRequest::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t PingRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.PingRequest.timestamp)
  return _internal_timestamp();
}
inline void PingRequest::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.PingRequest.timestamp)
}
inline ::int64_t PingRequest::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PingRequest::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// PingResponse

// required int64 timestamp = 1;
inline bool PingResponse::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PingResponse::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t PingResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.PingResponse.timestamp)
  return _internal_timestamp();
}
inline void PingResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.PingResponse.timestamp)
}
inline ::int64_t PingResponse::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void PingResponse::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// ShutdownRequest

// optional .HU.ShutdownRequest.REASON reason = 1;
inline bool ShutdownRequest::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ShutdownRequest::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::ShutdownRequest_REASON ShutdownRequest::reason() const {
  // @@protoc_insertion_point(field_get:HU.ShutdownRequest.reason)
  return _internal_reason();
}
inline void ShutdownRequest::set_reason(::HU::ShutdownRequest_REASON value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:HU.ShutdownRequest.reason)
}
inline ::HU::ShutdownRequest_REASON ShutdownRequest::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::ShutdownRequest_REASON>(_impl_.reason_);
}
inline void ShutdownRequest::_internal_set_reason(::HU::ShutdownRequest_REASON value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::ShutdownRequest_REASON_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_ = value;
}

// -------------------------------------------------------------------

// ShutdownResponse

// -------------------------------------------------------------------

// MediaSetupRequest

// optional uint32 type = 1;
inline bool MediaSetupRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaSetupRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t MediaSetupRequest::type() const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupRequest.type)
  return _internal_type();
}
inline void MediaSetupRequest::set_type(::uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupRequest.type)
}
inline ::uint32_t MediaSetupRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void MediaSetupRequest::_internal_set_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// MediaSetupResponse

// required .HU.MediaSetupResponse.MEDIA_STATUS media_status = 1;
inline bool MediaSetupResponse::has_media_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaSetupResponse::clear_media_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.media_status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::MediaSetupResponse_MEDIA_STATUS MediaSetupResponse::media_status() const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupResponse.media_status)
  return _internal_media_status();
}
inline void MediaSetupResponse::set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value) {
  _internal_set_media_status(value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupResponse.media_status)
}
inline ::HU::MediaSetupResponse_MEDIA_STATUS MediaSetupResponse::_internal_media_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::MediaSetupResponse_MEDIA_STATUS>(_impl_.media_status_);
}
inline void MediaSetupResponse::_internal_set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::MediaSetupResponse_MEDIA_STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.media_status_ = value;
}

// required uint32 max_unacked = 2;
inline bool MediaSetupResponse::has_max_unacked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaSetupResponse::clear_max_unacked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_unacked_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t MediaSetupResponse::max_unacked() const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupResponse.max_unacked)
  return _internal_max_unacked();
}
inline void MediaSetupResponse::set_max_unacked(::uint32_t value) {
  _internal_set_max_unacked(value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupResponse.max_unacked)
}
inline ::uint32_t MediaSetupResponse::_internal_max_unacked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_unacked_;
}
inline void MediaSetupResponse::_internal_set_max_unacked(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_unacked_ = value;
}

// repeated uint32 configs = 3;
inline int MediaSetupResponse::_internal_configs_size() const {
  return _internal_configs().size();
}
inline int MediaSetupResponse::configs_size() const {
  return _internal_configs_size();
}
inline void MediaSetupResponse::clear_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configs_.Clear();
}
inline ::uint32_t MediaSetupResponse::configs(int index) const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupResponse.configs)
  return _internal_configs().Get(index);
}
inline void MediaSetupResponse::set_configs(int index, ::uint32_t value) {
  _internal_mutable_configs()->Set(index, value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupResponse.configs)
}
inline void MediaSetupResponse::add_configs(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_configs()->Add(value);
  // @@protoc_insertion_point(field_add:HU.MediaSetupResponse.configs)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& MediaSetupResponse::configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.MediaSetupResponse.configs)
  return _internal_configs();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* MediaSetupResponse::mutable_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.MediaSetupResponse.configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_configs();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& MediaSetupResponse::_internal_configs()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configs_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* MediaSetupResponse::_internal_mutable_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.configs_;
}

// -------------------------------------------------------------------

// MediaStopRequest

// -------------------------------------------------------------------

// MediaStartRequest

// required int32 session = 1;
inline bool MediaStartRequest::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaStartRequest::clear_session() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MediaStartRequest::session() const {
  // @@protoc_insertion_point(field_get:HU.MediaStartRequest.session)
  return _internal_session();
}
inline void MediaStartRequest::set_session(::int32_t value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:HU.MediaStartRequest.session)
}
inline ::int32_t MediaStartRequest::_internal_session() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_;
}
inline void MediaStartRequest::_internal_set_session(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.session_ = value;
}

// optional uint32 config = 2;
inline bool MediaStartRequest::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaStartRequest::clear_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.config_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MediaStartRequest::config() const {
  // @@protoc_insertion_point(field_get:HU.MediaStartRequest.config)
  return _internal_config();
}
inline void MediaStartRequest::set_config(::uint32_t value) {
  _internal_set_config(value);
  // @@protoc_insertion_point(field_set:HU.MediaStartRequest.config)
}
inline ::uint32_t MediaStartRequest::_internal_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.config_;
}
inline void MediaStartRequest::_internal_set_config(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.config_ = value;
}

// -------------------------------------------------------------------

// MediaAck

// required int32 session = 1;
inline bool MediaAck::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaAck::clear_session() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MediaAck::session() const {
  // @@protoc_insertion_point(field_get:HU.MediaAck.session)
  return _internal_session();
}
inline void MediaAck::set_session(::int32_t value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:HU.MediaAck.session)
}
inline ::int32_t MediaAck::_internal_session() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_;
}
inline void MediaAck::_internal_set_session(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.session_ = value;
}

// required uint32 value = 2;
inline bool MediaAck::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaAck::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MediaAck::value() const {
  // @@protoc_insertion_point(field_get:HU.MediaAck.value)
  return _internal_value();
}
inline void MediaAck::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:HU.MediaAck.value)
}
inline ::uint32_t MediaAck::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void MediaAck::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// MicRequest

// required bool open = 1;
inline bool MicRequest::has_open() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MicRequest::clear_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.open_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MicRequest::open() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.open)
  return _internal_open();
}
inline void MicRequest::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.open)
}
inline bool MicRequest::_internal_open() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.open_;
}
inline void MicRequest::_internal_set_open(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.open_ = value;
}

// optional bool anc = 2;
inline bool MicRequest::has_anc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MicRequest::clear_anc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.anc_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MicRequest::anc() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.anc)
  return _internal_anc();
}
inline void MicRequest::set_anc(bool value) {
  _internal_set_anc(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.anc)
}
inline bool MicRequest::_internal_anc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.anc_;
}
inline void MicRequest::_internal_set_anc(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.anc_ = value;
}

// optional bool ec = 3;
inline bool MicRequest::has_ec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MicRequest::clear_ec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ec_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MicRequest::ec() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.ec)
  return _internal_ec();
}
inline void MicRequest::set_ec(bool value) {
  _internal_set_ec(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.ec)
}
inline bool MicRequest::_internal_ec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ec_;
}
inline void MicRequest::_internal_set_ec(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ec_ = value;
}

// optional int32 max_unacked = 4;
inline bool MicRequest::has_max_unacked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MicRequest::clear_max_unacked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_unacked_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MicRequest::max_unacked() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.max_unacked)
  return _internal_max_unacked();
}
inline void MicRequest::set_max_unacked(::int32_t value) {
  _internal_set_max_unacked(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.max_unacked)
}
inline ::int32_t MicRequest::_internal_max_unacked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_unacked_;
}
inline void MicRequest::_internal_set_max_unacked(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_unacked_ = value;
}

// -------------------------------------------------------------------

// MicResponse

// required int32 session = 1;
inline bool MicResponse::has_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MicResponse::clear_session() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MicResponse::session() const {
  // @@protoc_insertion_point(field_get:HU.MicResponse.session)
  return _internal_session();
}
inline void MicResponse::set_session(::int32_t value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:HU.MicResponse.session)
}
inline ::int32_t MicResponse::_internal_session() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_;
}
inline void MicResponse::_internal_set_session(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.session_ = value;
}

// required uint32 value = 2;
inline bool MicResponse::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MicResponse::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MicResponse::value() const {
  // @@protoc_insertion_point(field_get:HU.MicResponse.value)
  return _internal_value();
}
inline void MicResponse::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:HU.MicResponse.value)
}
inline ::uint32_t MicResponse::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void MicResponse::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// VideoFocusRequest

// optional int32 disp_index = 1;
inline bool VideoFocusRequest::has_disp_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VideoFocusRequest::clear_disp_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disp_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t VideoFocusRequest::disp_index() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocusRequest.disp_index)
  return _internal_disp_index();
}
inline void VideoFocusRequest::set_disp_index(::int32_t value) {
  _internal_set_disp_index(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocusRequest.disp_index)
}
inline ::int32_t VideoFocusRequest::_internal_disp_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disp_index_;
}
inline void VideoFocusRequest::_internal_set_disp_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.disp_index_ = value;
}

// optional .HU.VIDEO_FOCUS_MODE mode = 2;
inline bool VideoFocusRequest::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VideoFocusRequest::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocusRequest::mode() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocusRequest.mode)
  return _internal_mode();
}
inline void VideoFocusRequest::set_mode(::HU::VIDEO_FOCUS_MODE value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocusRequest.mode)
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocusRequest::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::VIDEO_FOCUS_MODE>(_impl_.mode_);
}
inline void VideoFocusRequest::_internal_set_mode(::HU::VIDEO_FOCUS_MODE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::VIDEO_FOCUS_MODE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mode_ = value;
}

// optional .HU.VIDEO_FOCUS_REASON reason = 3;
inline bool VideoFocusRequest::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VideoFocusRequest::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HU::VIDEO_FOCUS_REASON VideoFocusRequest::reason() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocusRequest.reason)
  return _internal_reason();
}
inline void VideoFocusRequest::set_reason(::HU::VIDEO_FOCUS_REASON value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocusRequest.reason)
}
inline ::HU::VIDEO_FOCUS_REASON VideoFocusRequest::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::VIDEO_FOCUS_REASON>(_impl_.reason_);
}
inline void VideoFocusRequest::_internal_set_reason(::HU::VIDEO_FOCUS_REASON value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::VIDEO_FOCUS_REASON_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reason_ = value;
}

// -------------------------------------------------------------------

// VideoFocus

// optional .HU.VIDEO_FOCUS_MODE mode = 1;
inline bool VideoFocus::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VideoFocus::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocus::mode() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocus.mode)
  return _internal_mode();
}
inline void VideoFocus::set_mode(::HU::VIDEO_FOCUS_MODE value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocus.mode)
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocus::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::VIDEO_FOCUS_MODE>(_impl_.mode_);
}
inline void VideoFocus::_internal_set_mode(::HU::VIDEO_FOCUS_MODE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::VIDEO_FOCUS_MODE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mode_ = value;
}

// optional bool unrequested = 2;
inline bool VideoFocus::has_unrequested() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VideoFocus::clear_unrequested() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unrequested_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool VideoFocus::unrequested() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocus.unrequested)
  return _internal_unrequested();
}
inline void VideoFocus::set_unrequested(bool value) {
  _internal_set_unrequested(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocus.unrequested)
}
inline bool VideoFocus::_internal_unrequested() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unrequested_;
}
inline void VideoFocus::_internal_set_unrequested(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unrequested_ = value;
}

// -------------------------------------------------------------------

// SensorStartRequest

// required .HU.SENSOR_TYPE type = 1;
inline bool SensorStartRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SensorStartRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::SENSOR_TYPE SensorStartRequest::type() const {
  // @@protoc_insertion_point(field_get:HU.SensorStartRequest.type)
  return _internal_type();
}
inline void SensorStartRequest::set_type(::HU::SENSOR_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.SensorStartRequest.type)
}
inline ::HU::SENSOR_TYPE SensorStartRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::SENSOR_TYPE>(_impl_.type_);
}
inline void SensorStartRequest::_internal_set_type(::HU::SENSOR_TYPE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::SENSOR_TYPE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional int64 refresh_interval = 2;
inline bool SensorStartRequest::has_refresh_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorStartRequest::clear_refresh_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_interval_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SensorStartRequest::refresh_interval() const {
  // @@protoc_insertion_point(field_get:HU.SensorStartRequest.refresh_interval)
  return _internal_refresh_interval();
}
inline void SensorStartRequest::set_refresh_interval(::int64_t value) {
  _internal_set_refresh_interval(value);
  // @@protoc_insertion_point(field_set:HU.SensorStartRequest.refresh_interval)
}
inline ::int64_t SensorStartRequest::_internal_refresh_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.refresh_interval_;
}
inline void SensorStartRequest::_internal_set_refresh_interval(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.refresh_interval_ = value;
}

// -------------------------------------------------------------------

// SensorStartResponse

// required .HU.STATUS status = 1;
inline bool SensorStartResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SensorStartResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS SensorStartResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.SensorStartResponse.status)
  return _internal_status();
}
inline void SensorStartResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.SensorStartResponse.status)
}
inline ::HU::STATUS SensorStartResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::STATUS>(_impl_.status_);
}
inline void SensorStartResponse::_internal_set_status(::HU::STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// NavigationFocusRequest

// optional uint32 focus_type = 1;
inline bool NavigationFocusRequest::has_focus_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NavigationFocusRequest::clear_focus_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.focus_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NavigationFocusRequest::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.NavigationFocusRequest.focus_type)
  return _internal_focus_type();
}
inline void NavigationFocusRequest::set_focus_type(::uint32_t value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.NavigationFocusRequest.focus_type)
}
inline ::uint32_t NavigationFocusRequest::_internal_focus_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.focus_type_;
}
inline void NavigationFocusRequest::_internal_set_focus_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.focus_type_ = value;
}

// -------------------------------------------------------------------

// NavigationFocusResponse

// optional uint32 focus_type = 1;
inline bool NavigationFocusResponse::has_focus_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NavigationFocusResponse::clear_focus_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.focus_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NavigationFocusResponse::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.NavigationFocusResponse.focus_type)
  return _internal_focus_type();
}
inline void NavigationFocusResponse::set_focus_type(::uint32_t value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.NavigationFocusResponse.focus_type)
}
inline ::uint32_t NavigationFocusResponse::_internal_focus_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.focus_type_;
}
inline void NavigationFocusResponse::_internal_set_focus_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.focus_type_ = value;
}

// -------------------------------------------------------------------

// VoiceSessionRequest

// optional .HU.VoiceSessionRequest.VOICE_STATUS voice_status = 1;
inline bool VoiceSessionRequest::has_voice_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VoiceSessionRequest::clear_voice_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest::voice_status() const {
  // @@protoc_insertion_point(field_get:HU.VoiceSessionRequest.voice_status)
  return _internal_voice_status();
}
inline void VoiceSessionRequest::set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value) {
  _internal_set_voice_status(value);
  // @@protoc_insertion_point(field_set:HU.VoiceSessionRequest.voice_status)
}
inline ::HU::VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest::_internal_voice_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::VoiceSessionRequest_VOICE_STATUS>(_impl_.voice_status_);
}
inline void VoiceSessionRequest::_internal_set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::VoiceSessionRequest_VOICE_STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.voice_status_ = value;
}

// -------------------------------------------------------------------

// AudioFocusRequest

// required .HU.AudioFocusRequest.AUDIO_FOCUS focus_type = 1;
inline bool AudioFocusRequest::has_focus_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AudioFocusRequest::clear_focus_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.focus_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.AudioFocusRequest.focus_type)
  return _internal_focus_type();
}
inline void AudioFocusRequest::set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.AudioFocusRequest.focus_type)
}
inline ::HU::AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest::_internal_focus_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::AudioFocusRequest_AUDIO_FOCUS>(_impl_.focus_type_);
}
inline void AudioFocusRequest::_internal_set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::AudioFocusRequest_AUDIO_FOCUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.focus_type_ = value;
}

// -------------------------------------------------------------------

// AudioFocusResponse

// required .HU.AudioFocusResponse.AUDIO_FOCUS_STATE focus_type = 1;
inline bool AudioFocusResponse::has_focus_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AudioFocusResponse::clear_focus_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.focus_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.AudioFocusResponse.focus_type)
  return _internal_focus_type();
}
inline void AudioFocusResponse::set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.AudioFocusResponse.focus_type)
}
inline ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse::_internal_focus_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::AudioFocusResponse_AUDIO_FOCUS_STATE>(_impl_.focus_type_);
}
inline void AudioFocusResponse::_internal_set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.focus_type_ = value;
}

// -------------------------------------------------------------------

// AuthCompleteResponse

// required .HU.STATUS status = 1;
inline bool AuthCompleteResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AuthCompleteResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS AuthCompleteResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.AuthCompleteResponse.status)
  return _internal_status();
}
inline void AuthCompleteResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.AuthCompleteResponse.status)
}
inline ::HU::STATUS AuthCompleteResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::STATUS>(_impl_.status_);
}
inline void AuthCompleteResponse::_internal_set_status(::HU::STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// PhoneStatus_Call

// optional .HU.PhoneStatus.PHONE_STATE state = 1;
inline bool PhoneStatus_Call::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PhoneStatus_Call::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::HU::PhoneStatus_PHONE_STATE PhoneStatus_Call::state() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.state)
  return _internal_state();
}
inline void PhoneStatus_Call::set_state(::HU::PhoneStatus_PHONE_STATE value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.state)
}
inline ::HU::PhoneStatus_PHONE_STATE PhoneStatus_Call::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::PhoneStatus_PHONE_STATE>(_impl_.state_);
}
inline void PhoneStatus_Call::_internal_set_state(::HU::PhoneStatus_PHONE_STATE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::PhoneStatus_PHONE_STATE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.state_ = value;
}

// optional uint32 call_time = 2;
inline bool PhoneStatus_Call::has_call_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PhoneStatus_Call::clear_call_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.call_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t PhoneStatus_Call::call_time() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.call_time)
  return _internal_call_time();
}
inline void PhoneStatus_Call::set_call_time(::uint32_t value) {
  _internal_set_call_time(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.call_time)
}
inline ::uint32_t PhoneStatus_Call::_internal_call_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.call_time_;
}
inline void PhoneStatus_Call::_internal_set_call_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.call_time_ = value;
}

// optional string phone_number = 3;
inline bool PhoneStatus_Call::has_phone_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PhoneStatus_Call::clear_phone_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phone_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneStatus_Call::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PhoneStatus_Call::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.phone_number)
}
inline std::string* PhoneStatus_Call::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.phone_number)
  return _s;
}
inline const std::string& PhoneStatus_Call::_internal_phone_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_number_.Get();
}
inline void PhoneStatus_Call::_internal_set_phone_number(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* PhoneStatus_Call::_internal_mutable_phone_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* PhoneStatus_Call::release_phone_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.phone_number)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phone_number_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_number_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PhoneStatus_Call::set_allocated_phone_number(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phone_number_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_number_.IsDefault()) {
          _impl_.phone_number_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.phone_number)
}

// optional string caller_id = 4;
inline bool PhoneStatus_Call::has_caller_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PhoneStatus_Call::clear_caller_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.caller_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhoneStatus_Call::caller_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.caller_id)
  return _internal_caller_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PhoneStatus_Call::set_caller_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.caller_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.caller_id)
}
inline std::string* PhoneStatus_Call::mutable_caller_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_caller_id();
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.caller_id)
  return _s;
}
inline const std::string& PhoneStatus_Call::_internal_caller_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.caller_id_.Get();
}
inline void PhoneStatus_Call::_internal_set_caller_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.caller_id_.Set(value, GetArena());
}
inline std::string* PhoneStatus_Call::_internal_mutable_caller_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.caller_id_.Mutable( GetArena());
}
inline std::string* PhoneStatus_Call::release_caller_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.caller_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.caller_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.caller_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PhoneStatus_Call::set_allocated_caller_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.caller_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.caller_id_.IsDefault()) {
          _impl_.caller_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.caller_id)
}

// optional string phone_number_type = 5;
inline bool PhoneStatus_Call::has_phone_number_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PhoneStatus_Call::clear_phone_number_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phone_number_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PhoneStatus_Call::phone_number_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.phone_number_type)
  return _internal_phone_number_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PhoneStatus_Call::set_phone_number_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.phone_number_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.phone_number_type)
}
inline std::string* PhoneStatus_Call::mutable_phone_number_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number_type();
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.phone_number_type)
  return _s;
}
inline const std::string& PhoneStatus_Call::_internal_phone_number_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_number_type_.Get();
}
inline void PhoneStatus_Call::_internal_set_phone_number_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.phone_number_type_.Set(value, GetArena());
}
inline std::string* PhoneStatus_Call::_internal_mutable_phone_number_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.phone_number_type_.Mutable( GetArena());
}
inline std::string* PhoneStatus_Call::release_phone_number_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.phone_number_type)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.phone_number_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_number_type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PhoneStatus_Call::set_allocated_phone_number_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.phone_number_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_number_type_.IsDefault()) {
          _impl_.phone_number_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.phone_number_type)
}

// optional bytes thumbnail = 6;
inline bool PhoneStatus_Call::has_thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PhoneStatus_Call::clear_thumbnail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbnail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PhoneStatus_Call::thumbnail() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.thumbnail)
  return _internal_thumbnail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PhoneStatus_Call::set_thumbnail(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.thumbnail_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.thumbnail)
}
inline std::string* PhoneStatus_Call::mutable_thumbnail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_thumbnail();
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.thumbnail)
  return _s;
}
inline const std::string& PhoneStatus_Call::_internal_thumbnail() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.thumbnail_.Get();
}
inline void PhoneStatus_Call::_internal_set_thumbnail(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.thumbnail_.Set(value, GetArena());
}
inline std::string* PhoneStatus_Call::_internal_mutable_thumbnail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.thumbnail_.Mutable( GetArena());
}
inline std::string* PhoneStatus_Call::release_thumbnail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.thumbnail)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.thumbnail_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.thumbnail_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PhoneStatus_Call::set_allocated_thumbnail(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.thumbnail_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.thumbnail_.IsDefault()) {
          _impl_.thumbnail_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.thumbnail)
}

// -------------------------------------------------------------------

// PhoneStatus

// repeated .HU.PhoneStatus.Call calls = 1;
inline int PhoneStatus::_internal_calls_size() const {
  return _internal_calls().size();
}
inline int PhoneStatus::calls_size() const {
  return _internal_calls_size();
}
inline void PhoneStatus::clear_calls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.calls_.Clear();
}
inline ::HU::PhoneStatus_Call* PhoneStatus::mutable_calls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.calls)
  return _internal_mutable_calls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::HU::PhoneStatus_Call>* PhoneStatus::mutable_calls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:HU.PhoneStatus.calls)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_calls();
}
inline const ::HU::PhoneStatus_Call& PhoneStatus::calls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.calls)
  return _internal_calls().Get(index);
}
inline ::HU::PhoneStatus_Call* PhoneStatus::add_calls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::HU::PhoneStatus_Call* _add = _internal_mutable_calls()->Add();
  // @@protoc_insertion_point(field_add:HU.PhoneStatus.calls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::HU::PhoneStatus_Call>& PhoneStatus::calls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:HU.PhoneStatus.calls)
  return _internal_calls();
}
inline const ::google::protobuf::RepeatedPtrField<::HU::PhoneStatus_Call>&
PhoneStatus::_internal_calls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.calls_;
}
inline ::google::protobuf::RepeatedPtrField<::HU::PhoneStatus_Call>*
PhoneStatus::_internal_mutable_calls() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.calls_;
}

// optional uint32 signal_strength = 2;
inline bool PhoneStatus::has_signal_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PhoneStatus::clear_signal_strength() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signal_strength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PhoneStatus::signal_strength() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.signal_strength)
  return _internal_signal_strength();
}
inline void PhoneStatus::set_signal_strength(::uint32_t value) {
  _internal_set_signal_strength(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.signal_strength)
}
inline ::uint32_t PhoneStatus::_internal_signal_strength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signal_strength_;
}
inline void PhoneStatus::_internal_set_signal_strength(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signal_strength_ = value;
}

// -------------------------------------------------------------------

// PhoneStatusInput

// optional string caller_number = 1;
inline bool PhoneStatusInput::has_caller_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PhoneStatusInput::clear_caller_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.caller_number_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneStatusInput::caller_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatusInput.caller_number)
  return _internal_caller_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PhoneStatusInput::set_caller_number(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.caller_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.PhoneStatusInput.caller_number)
}
inline std::string* PhoneStatusInput::mutable_caller_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_caller_number();
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatusInput.caller_number)
  return _s;
}
inline const std::string& PhoneStatusInput::_internal_caller_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.caller_number_.Get();
}
inline void PhoneStatusInput::_internal_set_caller_number(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.caller_number_.Set(value, GetArena());
}
inline std::string* PhoneStatusInput::_internal_mutable_caller_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.caller_number_.Mutable( GetArena());
}
inline std::string* PhoneStatusInput::release_caller_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.PhoneStatusInput.caller_number)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.caller_number_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.caller_number_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PhoneStatusInput::set_allocated_caller_number(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.caller_number_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.caller_number_.IsDefault()) {
          _impl_.caller_number_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatusInput.caller_number)
}

// optional string caller_id = 2;
inline bool PhoneStatusInput::has_caller_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PhoneStatusInput::clear_caller_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.caller_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhoneStatusInput::caller_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.PhoneStatusInput.caller_id)
  return _internal_caller_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PhoneStatusInput::set_caller_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.caller_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.PhoneStatusInput.caller_id)
}
inline std::string* PhoneStatusInput::mutable_caller_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_caller_id();
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatusInput.caller_id)
  return _s;
}
inline const std::string& PhoneStatusInput::_internal_caller_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.caller_id_.Get();
}
inline void PhoneStatusInput::_internal_set_caller_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.caller_id_.Set(value, GetArena());
}
inline std::string* PhoneStatusInput::_internal_mutable_caller_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.caller_id_.Mutable( GetArena());
}
inline std::string* PhoneStatusInput::release_caller_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.PhoneStatusInput.caller_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.caller_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.caller_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PhoneStatusInput::set_allocated_caller_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.caller_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.caller_id_.IsDefault()) {
          _impl_.caller_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatusInput.caller_id)
}

// -------------------------------------------------------------------

// GenericNotificationRequest

// required string id = 1;
inline bool GenericNotificationRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericNotificationRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericNotificationRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericNotificationRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.GenericNotificationRequest.id)
}
inline std::string* GenericNotificationRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationRequest.id)
  return _s;
}
inline const std::string& GenericNotificationRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GenericNotificationRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GenericNotificationRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GenericNotificationRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.GenericNotificationRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericNotificationRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationRequest.id)
}

// optional string text = 2;
inline bool GenericNotificationRequest::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenericNotificationRequest::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericNotificationRequest::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationRequest.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericNotificationRequest::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.GenericNotificationRequest.text)
}
inline std::string* GenericNotificationRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationRequest.text)
  return _s;
}
inline const std::string& GenericNotificationRequest::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void GenericNotificationRequest::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* GenericNotificationRequest::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* GenericNotificationRequest::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.GenericNotificationRequest.text)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.text_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericNotificationRequest::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationRequest.text)
}

// optional string icon = 3;
inline bool GenericNotificationRequest::has_icon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GenericNotificationRequest::clear_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericNotificationRequest::icon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationRequest.icon)
  return _internal_icon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericNotificationRequest::set_icon(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.icon_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.GenericNotificationRequest.icon)
}
inline std::string* GenericNotificationRequest::mutable_icon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationRequest.icon)
  return _s;
}
inline const std::string& GenericNotificationRequest::_internal_icon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.icon_.Get();
}
inline void GenericNotificationRequest::_internal_set_icon(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.icon_.Set(value, GetArena());
}
inline std::string* GenericNotificationRequest::_internal_mutable_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.icon_.Mutable( GetArena());
}
inline std::string* GenericNotificationRequest::release_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.GenericNotificationRequest.icon)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.icon_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.icon_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericNotificationRequest::set_allocated_icon(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.icon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.icon_.IsDefault()) {
          _impl_.icon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationRequest.icon)
}

// -------------------------------------------------------------------

// GenericNotificationResponse

// required string id = 1;
inline bool GenericNotificationResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericNotificationResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericNotificationResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericNotificationResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.GenericNotificationResponse.id)
}
inline std::string* GenericNotificationResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationResponse.id)
  return _s;
}
inline const std::string& GenericNotificationResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GenericNotificationResponse::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GenericNotificationResponse::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GenericNotificationResponse::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.GenericNotificationResponse.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericNotificationResponse::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationResponse.id)
}

// required bool handled = 2;
inline bool GenericNotificationResponse::has_handled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenericNotificationResponse::clear_handled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.handled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool GenericNotificationResponse::handled() const {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationResponse.handled)
  return _internal_handled();
}
inline void GenericNotificationResponse::set_handled(bool value) {
  _internal_set_handled(value);
  // @@protoc_insertion_point(field_set:HU.GenericNotificationResponse.handled)
}
inline bool GenericNotificationResponse::_internal_handled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.handled_;
}
inline void GenericNotificationResponse::_internal_set_handled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.handled_ = value;
}

// -------------------------------------------------------------------

// StartGenericNotifications

// -------------------------------------------------------------------

// StopGenericNotifications

// -------------------------------------------------------------------

// BluetoothPairingRequest

// required string phone_address = 1;
inline bool BluetoothPairingRequest::has_phone_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BluetoothPairingRequest::clear_phone_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phone_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothPairingRequest::phone_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingRequest.phone_address)
  return _internal_phone_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BluetoothPairingRequest::set_phone_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingRequest.phone_address)
}
inline std::string* BluetoothPairingRequest::mutable_phone_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_address();
  // @@protoc_insertion_point(field_mutable:HU.BluetoothPairingRequest.phone_address)
  return _s;
}
inline const std::string& BluetoothPairingRequest::_internal_phone_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_address_.Get();
}
inline void BluetoothPairingRequest::_internal_set_phone_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_address_.Set(value, GetArena());
}
inline std::string* BluetoothPairingRequest::_internal_mutable_phone_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phone_address_.Mutable( GetArena());
}
inline std::string* BluetoothPairingRequest::release_phone_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.BluetoothPairingRequest.phone_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phone_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BluetoothPairingRequest::set_allocated_phone_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phone_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_address_.IsDefault()) {
          _impl_.phone_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.BluetoothPairingRequest.phone_address)
}

// optional .HU.BluetoothPairingMethod pairing_method = 2;
inline bool BluetoothPairingRequest::has_pairing_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BluetoothPairingRequest::clear_pairing_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pairing_method_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::BluetoothPairingMethod BluetoothPairingRequest::pairing_method() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingRequest.pairing_method)
  return _internal_pairing_method();
}
inline void BluetoothPairingRequest::set_pairing_method(::HU::BluetoothPairingMethod value) {
  _internal_set_pairing_method(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingRequest.pairing_method)
}
inline ::HU::BluetoothPairingMethod BluetoothPairingRequest::_internal_pairing_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::BluetoothPairingMethod>(_impl_.pairing_method_);
}
inline void BluetoothPairingRequest::_internal_set_pairing_method(::HU::BluetoothPairingMethod value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::BluetoothPairingMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pairing_method_ = value;
}

// -------------------------------------------------------------------

// BluetoothPairingResponse

// optional bool already_paired = 1;
inline bool BluetoothPairingResponse::has_already_paired() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BluetoothPairingResponse::clear_already_paired() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.already_paired_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BluetoothPairingResponse::already_paired() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingResponse.already_paired)
  return _internal_already_paired();
}
inline void BluetoothPairingResponse::set_already_paired(bool value) {
  _internal_set_already_paired(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingResponse.already_paired)
}
inline bool BluetoothPairingResponse::_internal_already_paired() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.already_paired_;
}
inline void BluetoothPairingResponse::_internal_set_already_paired(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.already_paired_ = value;
}

// optional .HU.BluetoothPairingResponse.PAIRING_STATUS status = 2;
inline bool BluetoothPairingResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BluetoothPairingResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HU::BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingResponse.status)
  return _internal_status();
}
inline void BluetoothPairingResponse::set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingResponse.status)
}
inline ::HU::BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::BluetoothPairingResponse_PAIRING_STATUS>(_impl_.status_);
}
inline void BluetoothPairingResponse::_internal_set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::BluetoothPairingResponse_PAIRING_STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// BluetoothAuthData

// optional string data = 1;
inline bool BluetoothAuthData::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BluetoothAuthData::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothAuthData::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.BluetoothAuthData.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BluetoothAuthData::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.BluetoothAuthData.data)
}
inline std::string* BluetoothAuthData::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:HU.BluetoothAuthData.data)
  return _s;
}
inline const std::string& BluetoothAuthData::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void BluetoothAuthData::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* BluetoothAuthData::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* BluetoothAuthData::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.BluetoothAuthData.data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BluetoothAuthData::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.BluetoothAuthData.data)
}

// -------------------------------------------------------------------

// NAVMessagesStatus

// optional .HU.NAVMessagesStatus.STATUS status = 1;
inline bool NAVMessagesStatus::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NAVMessagesStatus::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::HU::NAVMessagesStatus_STATUS NAVMessagesStatus::status() const {
  // @@protoc_insertion_point(field_get:HU.NAVMessagesStatus.status)
  return _internal_status();
}
inline void NAVMessagesStatus::set_status(::HU::NAVMessagesStatus_STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.NAVMessagesStatus.status)
}
inline ::HU::NAVMessagesStatus_STATUS NAVMessagesStatus::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::NAVMessagesStatus_STATUS>(_impl_.status_);
}
inline void NAVMessagesStatus::_internal_set_status(::HU::NAVMessagesStatus_STATUS value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::NAVMessagesStatus_STATUS_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// NAVTurnMessage

// optional string event_name = 1;
inline bool NAVTurnMessage::has_event_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NAVTurnMessage::clear_event_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NAVTurnMessage::event_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.event_name)
  return _internal_event_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NAVTurnMessage::set_event_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.event_name)
}
inline std::string* NAVTurnMessage::mutable_event_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:HU.NAVTurnMessage.event_name)
  return _s;
}
inline const std::string& NAVTurnMessage::_internal_event_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_name_.Get();
}
inline void NAVTurnMessage::_internal_set_event_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(value, GetArena());
}
inline std::string* NAVTurnMessage::_internal_mutable_event_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.event_name_.Mutable( GetArena());
}
inline std::string* NAVTurnMessage::release_event_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.NAVTurnMessage.event_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.event_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.event_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NAVTurnMessage::set_allocated_event_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.event_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.event_name_.IsDefault()) {
          _impl_.event_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.NAVTurnMessage.event_name)
}

// optional .HU.NAVTurnMessage.TURN_SIDE turn_side = 2;
inline bool NAVTurnMessage::has_turn_side() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NAVTurnMessage::clear_turn_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_side_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::HU::NAVTurnMessage_TURN_SIDE NAVTurnMessage::turn_side() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_side)
  return _internal_turn_side();
}
inline void NAVTurnMessage::set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value) {
  _internal_set_turn_side(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_side)
}
inline ::HU::NAVTurnMessage_TURN_SIDE NAVTurnMessage::_internal_turn_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::NAVTurnMessage_TURN_SIDE>(_impl_.turn_side_);
}
inline void NAVTurnMessage::_internal_set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::NAVTurnMessage_TURN_SIDE_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.turn_side_ = value;
}

// optional .HU.NAVTurnMessage.TURN_EVENT turn_event = 3;
inline bool NAVTurnMessage::has_turn_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NAVTurnMessage::clear_turn_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_event_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HU::NAVTurnMessage_TURN_EVENT NAVTurnMessage::turn_event() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_event)
  return _internal_turn_event();
}
inline void NAVTurnMessage::set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value) {
  _internal_set_turn_event(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_event)
}
inline ::HU::NAVTurnMessage_TURN_EVENT NAVTurnMessage::_internal_turn_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::NAVTurnMessage_TURN_EVENT>(_impl_.turn_event_);
}
inline void NAVTurnMessage::_internal_set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::NAVTurnMessage_TURN_EVENT_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.turn_event_ = value;
}

// optional bytes image = 4;
inline bool NAVTurnMessage::has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NAVTurnMessage::clear_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.image_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NAVTurnMessage::image() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.image)
  return _internal_image();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NAVTurnMessage::set_image(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.image)
}
inline std::string* NAVTurnMessage::mutable_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:HU.NAVTurnMessage.image)
  return _s;
}
inline const std::string& NAVTurnMessage::_internal_image() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.image_.Get();
}
inline void NAVTurnMessage::_internal_set_image(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_.Set(value, GetArena());
}
inline std::string* NAVTurnMessage::_internal_mutable_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.image_.Mutable( GetArena());
}
inline std::string* NAVTurnMessage::release_image() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:HU.NAVTurnMessage.image)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.image_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.image_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NAVTurnMessage::set_allocated_image(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.image_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.image_.IsDefault()) {
          _impl_.image_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HU.NAVTurnMessage.image)
}

// optional int32 turn_number = 5;
inline bool NAVTurnMessage::has_turn_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NAVTurnMessage::clear_turn_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NAVTurnMessage::turn_number() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_number)
  return _internal_turn_number();
}
inline void NAVTurnMessage::set_turn_number(::int32_t value) {
  _internal_set_turn_number(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_number)
}
inline ::int32_t NAVTurnMessage::_internal_turn_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_number_;
}
inline void NAVTurnMessage::_internal_set_turn_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.turn_number_ = value;
}

// optional int32 turn_angle = 6;
inline bool NAVTurnMessage::has_turn_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NAVTurnMessage::clear_turn_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NAVTurnMessage::turn_angle() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_angle)
  return _internal_turn_angle();
}
inline void NAVTurnMessage::set_turn_angle(::int32_t value) {
  _internal_set_turn_angle(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_angle)
}
inline ::int32_t NAVTurnMessage::_internal_turn_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_angle_;
}
inline void NAVTurnMessage::_internal_set_turn_angle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.turn_angle_ = value;
}

// -------------------------------------------------------------------

// NAVDistanceMessage

// optional int32 distance = 1;
inline bool NAVDistanceMessage::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NAVDistanceMessage::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NAVDistanceMessage::distance() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.distance)
  return _internal_distance();
}
inline void NAVDistanceMessage::set_distance(::int32_t value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.distance)
}
inline ::int32_t NAVDistanceMessage::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void NAVDistanceMessage::_internal_set_distance(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.distance_ = value;
}

// optional int32 time_until = 2;
inline bool NAVDistanceMessage::has_time_until() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NAVDistanceMessage::clear_time_until() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_until_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NAVDistanceMessage::time_until() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.time_until)
  return _internal_time_until();
}
inline void NAVDistanceMessage::set_time_until(::int32_t value) {
  _internal_set_time_until(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.time_until)
}
inline ::int32_t NAVDistanceMessage::_internal_time_until() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_until_;
}
inline void NAVDistanceMessage::_internal_set_time_until(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_until_ = value;
}

// optional uint64 display_distance = 3;
inline bool NAVDistanceMessage::has_display_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NAVDistanceMessage::clear_display_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_distance_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NAVDistanceMessage::display_distance() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.display_distance)
  return _internal_display_distance();
}
inline void NAVDistanceMessage::set_display_distance(::uint64_t value) {
  _internal_set_display_distance(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.display_distance)
}
inline ::uint64_t NAVDistanceMessage::_internal_display_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_distance_;
}
inline void NAVDistanceMessage::_internal_set_display_distance(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.display_distance_ = value;
}

// optional .HU.NAVDistanceMessage.DISPLAY_DISTANCE_UNIT display_distance_unit = 4;
inline bool NAVDistanceMessage::has_display_distance_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NAVDistanceMessage::clear_display_distance_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_distance_unit_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage::display_distance_unit() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.display_distance_unit)
  return _internal_display_distance_unit();
}
inline void NAVDistanceMessage::set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value) {
  _internal_set_display_distance_unit(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.display_distance_unit)
}
inline ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage::_internal_display_distance_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>(_impl_.display_distance_unit_);
}
inline void NAVDistanceMessage::_internal_set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.display_distance_unit_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace HU


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::HU::TouchInfo_TOUCH_ACTION> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::TouchInfo_TOUCH_ACTION>() {
  return ::HU::TouchInfo_TOUCH_ACTION_descriptor();
}
template <>
struct is_proto_enum<::HU::SensorEvent_DrivingStatus_STATUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::SensorEvent_DrivingStatus_STATUS>() {
  return ::HU::SensorEvent_DrivingStatus_STATUS_descriptor();
}
template <>
struct is_proto_enum<::HU::SensorEvent_Light_HEADLIGHT_STATE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::SensorEvent_Light_HEADLIGHT_STATE>() {
  return ::HU::SensorEvent_Light_HEADLIGHT_STATE_descriptor();
}
template <>
struct is_proto_enum<::HU::SensorEvent_Light_TURN_INDICATOR_STATE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::SensorEvent_Light_TURN_INDICATOR_STATE>() {
  return ::HU::SensorEvent_Light_TURN_INDICATOR_STATE_descriptor();
}
template <>
struct is_proto_enum<::HU::SensorEvent_GearData_GEAR> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::SensorEvent_GearData_GEAR>() {
  return ::HU::SensorEvent_GearData_GEAR_descriptor();
}
template <>
struct is_proto_enum<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>() {
  return ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor();
}
template <>
struct is_proto_enum<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>() {
  return ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor();
}
template <>
struct is_proto_enum<::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>() {
  return ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor();
}
template <>
struct is_proto_enum<::HU::ShutdownRequest_REASON> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::ShutdownRequest_REASON>() {
  return ::HU::ShutdownRequest_REASON_descriptor();
}
template <>
struct is_proto_enum<::HU::MediaSetupResponse_MEDIA_STATUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::MediaSetupResponse_MEDIA_STATUS>() {
  return ::HU::MediaSetupResponse_MEDIA_STATUS_descriptor();
}
template <>
struct is_proto_enum<::HU::VoiceSessionRequest_VOICE_STATUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::VoiceSessionRequest_VOICE_STATUS>() {
  return ::HU::VoiceSessionRequest_VOICE_STATUS_descriptor();
}
template <>
struct is_proto_enum<::HU::AudioFocusRequest_AUDIO_FOCUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::AudioFocusRequest_AUDIO_FOCUS>() {
  return ::HU::AudioFocusRequest_AUDIO_FOCUS_descriptor();
}
template <>
struct is_proto_enum<::HU::AudioFocusResponse_AUDIO_FOCUS_STATE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::AudioFocusResponse_AUDIO_FOCUS_STATE>() {
  return ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor();
}
template <>
struct is_proto_enum<::HU::PhoneStatus_PHONE_STATE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::PhoneStatus_PHONE_STATE>() {
  return ::HU::PhoneStatus_PHONE_STATE_descriptor();
}
template <>
struct is_proto_enum<::HU::BluetoothPairingResponse_PAIRING_STATUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::BluetoothPairingResponse_PAIRING_STATUS>() {
  return ::HU::BluetoothPairingResponse_PAIRING_STATUS_descriptor();
}
template <>
struct is_proto_enum<::HU::NAVMessagesStatus_STATUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::NAVMessagesStatus_STATUS>() {
  return ::HU::NAVMessagesStatus_STATUS_descriptor();
}
template <>
struct is_proto_enum<::HU::NAVTurnMessage_TURN_SIDE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::NAVTurnMessage_TURN_SIDE>() {
  return ::HU::NAVTurnMessage_TURN_SIDE_descriptor();
}
template <>
struct is_proto_enum<::HU::NAVTurnMessage_TURN_EVENT> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::NAVTurnMessage_TURN_EVENT>() {
  return ::HU::NAVTurnMessage_TURN_EVENT_descriptor();
}
template <>
struct is_proto_enum<::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>() {
  return ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor();
}
template <>
struct is_proto_enum<::HU::STATUS> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::STATUS>() {
  return ::HU::STATUS_descriptor();
}
template <>
struct is_proto_enum<::HU::SENSOR_TYPE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::SENSOR_TYPE>() {
  return ::HU::SENSOR_TYPE_descriptor();
}
template <>
struct is_proto_enum<::HU::AUDIO_TYPE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::AUDIO_TYPE>() {
  return ::HU::AUDIO_TYPE_descriptor();
}
template <>
struct is_proto_enum<::HU::STREAM_TYPE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::STREAM_TYPE>() {
  return ::HU::STREAM_TYPE_descriptor();
}
template <>
struct is_proto_enum<::HU::BluetoothPairingMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::BluetoothPairingMethod>() {
  return ::HU::BluetoothPairingMethod_descriptor();
}
template <>
struct is_proto_enum<::HU::VIDEO_FOCUS_MODE> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::VIDEO_FOCUS_MODE>() {
  return ::HU::VIDEO_FOCUS_MODE_descriptor();
}
template <>
struct is_proto_enum<::HU::VIDEO_FOCUS_REASON> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::HU::VIDEO_FOCUS_REASON>() {
  return ::HU::VIDEO_FOCUS_REASON_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_AndroidAuto_2eproto_2epb_2eh
